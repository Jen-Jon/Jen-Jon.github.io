[{"contents":"最近奥密克戎袭卷合肥，造成了这座千万级人口的城市进入近似半停摆的状态。整天都能在外面看到所谓的“大白”，和数不清的救护车。也能在各种社交媒体上刷到类似“某个小区被封控”/“某栋楼的住户被整车整车地拉去隔离”这类的信息流。其实之前都会觉得没啥大不了的，毕竟Covid-19爆发已经三年了，我却还没感染过（当然即便感染了也没啥大不了的，我对自己机体的抵抗力还是很有信心的）。但是不巧，在10月24日这天，也就是“1024程序员节”这天，我被社区要求去集中隔离了。起初我还是蛮抗拒的，毕竟也在网路上看到那些很烂的隔离点，我感觉让我在那住一个星期，没有人跟你说话，不能出门活动\u0026hellip;\u0026hellip;失去了一个正常人的自由，我是会疯掉的（当然事实是我没有疯掉）。但是最后我发现给我拉去的其实是一个“四星级”酒店，在酒店里隔离。这让我的心情瞬间好了许多，毕竟这个酒店平时住一晚也要3-400元呢，这波小赚啊\u0026hellip;\n就在我心中窃喜的时候，却被告知餐费是需要自己负担的。标准是40元人民币一餐。当时一想，40块钱应该能吃得很不错吧，再加上酒店环境也不错，所以就觉得也没啥。但实际是，餐食真的很一般，中餐和晚餐好歹还有着15元的水平，早餐\u0026hellip;额，我不太好说，你们自己看图吧：\n这种很一般的餐食对于我这种每天都坚持健身的人来说，带来的结果就是四天下来，整个人看起来都消瘦了许多：\n幸运的是，本来要隔离7天的我，在今天核酸结果（阴性）出来之后被告知可以解除隔离了！！Yes, 我现在是弗雷曼（Freeman）了！\n","date":"2022-10-28T00:00:00Z","permalink":"https://jen-jon.github.io/posts/20221028/","tags":"隔离；Covid-19；新冠后遗症","title":"隔离日寄","type":"lifestyle"},{"contents":"import torch torch.__version__ '1.8.2' 编写PyTorch模型的基本知识 我们首先来定义一个简单的Module。Module是PyTorch模型的基本组成单位。其中包含：\n一个构造函数，为模块的调用作准备；\n一组参数和子模块，它们由构造函数初始化，并可由模块在调用期间使用；\n一个forward函数，这是在调用模块时运行的代码。\n来看看下面这个例子：\nclass MyCell(torch.nn.Module): def __init__(self): super(MyCell, self).__init__() def forward(self, x, h): new_h = torch.tanh(x + h) return new_h, new_h my_cell = MyCell() x = torch.rand(3, 4) h = torch.rand(3, 4) print(my_cell(x, h)) (tensor([[0.5848, 0.6401, 0.5124, 0.6093], [0.2706, 0.4608, 0.9002, 0.7638], [0.9597, 0.7959, 0.6197, 0.6299]]), tensor([[0.5848, 0.6401, 0.5124, 0.6093], [0.2706, 0.4608, 0.9002, 0.7638], [0.9597, 0.7959, 0.6197, 0.6299]])) 从上面代码中可以发现，\n创建了一个torch.nn.Module的子类；\n定义了一个构造函数，并且没有做任何动作除了调用父类super的构造函数；\n定义了一个forward函数，接收两个输入并返回两个输出；forward函数中的实际内容并不重要，类似于一种假的RNN单元，是一个应用在循环中的函数。\n最后，将该类实例化，并创建x和h，它们是3x4的随机矩阵。然后通过my_cell(x, h)调用该实例，同样这也调用了forward函数。\n接下来做点更有趣的：\nclass MyCell(torch.nn.Module): def __init__(self): super(MyCell, self).__init__() self.linear = torch.nn.Linear(4, 4) def forward(self, x, h): new_h = torch.tanh(self.linear(x) + h) return new_h, new_h my_cell = MyCell() print(my_cell) print(my_cell(x, h)) MyCell( (linear): Linear(in_features=4, out_features=4, bias=True) ) (tensor([[-0.0131, 0.2256, 0.5951, 0.4361], [ 0.0035, 0.7586, 0.6020, 0.0687], [ 0.6873, 0.3057, 0.7030, 0.3927]], grad_fn=\u0026lt;TanhBackward\u0026gt;), tensor([[-0.0131, 0.2256, 0.5951, 0.4361], [ 0.0035, 0.7586, 0.6020, 0.0687], [ 0.6873, 0.3057, 0.7030, 0.3927]], grad_fn=\u0026lt;TanhBackward\u0026gt;)) 我们重新定义了MyCell模块，但在其中添加了self.linear属性，并在forward函数中调用了self.linear。\n这里究竟发生什么了呢？torch.nn.Linear是PyTorch标准库中的Module。正如同MyCell，可以使用调用语法来调用它。我们正在构建一个由Modules组成的层次结构。\nModule中的print会打印出Module的子类层次结构的直观表示。在我们的示例中，可以看到Linear子类以及其参数。\n通过这种方式组合模块，我们能够简洁和高可读地使用可重用组件来编写模型。\n你可能会注意到输出结果中的grad_fn，这是PyTorch自动微分的一个细节，称之为autograd。简而言之，这套系统允许我们通过潜在的复杂程序来计算导数。这种设计增加了模型编写方面的灵活性。\n接下来我们来研究一下所谓的灵活性：\nclass MyDecisionGate(torch.nn.Module): def forward(self, x): if x.sum() \u0026gt; 0: return x else: return -x class MyCell(torch.nn.Module): def __init__(self): super(MyCell, self).__init__() self.dg = MyDecisionGate() self.linear = torch.nn.Linear(4, 4) def forward(self, x, h): new_h = torch.tanh(self.dg(self.linear(x)) + h) return new_h, new_h my_cell = MyCell() print(my_cell) print(my_cell(x, h)) MyCell( (dg): MyDecisionGate() (linear): Linear(in_features=4, out_features=4, bias=True) ) (tensor([[ 0.4873, -0.0183, 0.5451, 0.6425], [ 0.1686, 0.3009, 0.6721, 0.3504], [ 0.9206, 0.2258, 0.6589, 0.5597]], grad_fn=\u0026lt;TanhBackward\u0026gt;), tensor([[ 0.4873, -0.0183, 0.5451, 0.6425], [ 0.1686, 0.3009, 0.6721, 0.3504], [ 0.9206, 0.2258, 0.6589, 0.5597]], grad_fn=\u0026lt;TanhBackward\u0026gt;)) 我们再一次重新定义了MyCell类，但在这里我们定义了MyDecisionGate。这个模块用来控制流。控制流由循环和if语句等内容组成。\n许多框架采用了计算符号导数的方法，并且给定完整的程序表示。但在PyTorch中，我们使用“梯度胶带”。我们在操作发生时记录它们，并在计算导数回放它们。这样就不必显式地为语言中的所有构造定义导数。\nTorchScript基础 现在以我们上述示例为例，看看如何使用TorchScript。\n简而言之，TorchScript提供了一些工具来捕获模型的定义，甚至考虑到了PyTorch的灵活性和动态性。让我们从被称为tracing的工具来开始探究。\nTracing Modules class MyCell(torch.nn.Module): def __init__(self): super(MyCell, self).__init__() self.linear = torch.nn.Linear(4, 4) def forward(self, x, h): new_h = torch.tanh(self.linear(x) + h) return new_h, new_h my_cell = MyCell() x, h = torch.rand(3, 4), torch.rand(3, 4) traced_cell = torch.jit.trace(my_cell, (x, h)) print(traced_cell) traced_cell(x, h) MyCell( original_name=MyCell (linear): Linear(original_name=Linear) ) (tensor([[-0.6178, 0.1537, 0.2786, 0.4218], [-0.1340, 0.6531, 0.3963, 0.8801], [-0.7938, 0.7117, 0.6256, 0.6363]], grad_fn=\u0026lt;TanhBackward\u0026gt;), tensor([[-0.6178, 0.1537, 0.2786, 0.4218], [-0.1340, 0.6531, 0.3963, 0.8801], [-0.7938, 0.7117, 0.6256, 0.6363]], grad_fn=\u0026lt;TanhBackward\u0026gt;)) 我们稍微往前回溯了一点，采用MyCell类的第二个版本。和之前一样，我们实例化了它，但这一次我们调用了torch.jit.trace，并将实例化的Module传入，并传入网络中的示例输入。\n这个过程中到底发生了什么？它调用了实例化Module，记录了Module运行时发生的操作，并创建了torch.jit.ScriptModule的实例（TracedModule便是其实例）。\nTorchScript将其定义记录在中间表示（Intermediate Representation），在深度学习中通常被称为graph。我们可以通过使用.graph属性检查该graph：\nprint(traced_cell.graph) graph(%self.1 : __torch__.MyCell, %input : Float(3, 4, strides=[4, 1], requires_grad=0, device=cpu), %h : Float(3, 4, strides=[4, 1], requires_grad=0, device=cpu)): %21 : __torch__.torch.nn.modules.linear.Linear = prim::GetAttr[name=\u0026quot;linear\u0026quot;](%self.1) %23 : Tensor = prim::CallMethod[name=\u0026quot;forward\u0026quot;](%21, %input) %14 : int = prim::Constant[value=1]() # /tmp/ipykernel_18098/4265555285.py:7:0 %15 : Float(3, 4, strides=[4, 1], requires_grad=1, device=cpu) = aten::add(%23, %h, %14) # /tmp/ipykernel_18098/4265555285.py:7:0 %16 : Float(3, 4, strides=[4, 1], requires_grad=1, device=cpu) = aten::tanh(%15) # /tmp/ipykernel_18098/4265555285.py:7:0 %17 : (Float(3, 4, strides=[4, 1], requires_grad=1, device=cpu), Float(3, 4, strides=[4, 1], requires_grad=1, device=cpu)) = prim::TupleConstruct(%16, %16) return (%17) 然而，这是一种非常low-level的表示，图表中包含的大多数信息对最终用户都没有用处。取而代之的是，可以使用.code属性来提供代码的Python语法解释：\nprint(traced_cell.code) def forward(self, input: Tensor, h: Tensor) -\u0026gt; Tuple[Tensor, Tensor]: _0 = torch.add((self.linear).forward(input, ), h, alpha=1) _1 = torch.tanh(_0) return (_1, _1) 为什么要这样做呢？主要有以下几个原因：\nTorchScript代码可以在其自己的解释器中调用，该解释器基本上是一个受限的Python解释器。此解释器不获取全局解释器锁，因此可以在同一实例上同时处理许多请求。\n此格式允许我们将整个模型保存到磁盘，并将其加载到另一个环境中，例如在用非Python语言编写的服务器中。\nTorchScript为我们提供了一种表示形式，我们可以在其中对代码进行编译器优化，以提供更高效的执行。\nTorchScript允许我们与许多后端/设备运行时交互，这些后端/设备运行时需要比单个运算符更广泛的程序视图。\n我们可以看到，调用traced_cell会产生与Python模块相同的结果：\nprint(my_cell(x, h)) print(traced_cell(x, h)) (tensor([[-0.6178, 0.1537, 0.2786, 0.4218], [-0.1340, 0.6531, 0.3963, 0.8801], [-0.7938, 0.7117, 0.6256, 0.6363]], grad_fn=\u0026lt;TanhBackward\u0026gt;), tensor([[-0.6178, 0.1537, 0.2786, 0.4218], [-0.1340, 0.6531, 0.3963, 0.8801], [-0.7938, 0.7117, 0.6256, 0.6363]], grad_fn=\u0026lt;TanhBackward\u0026gt;)) (tensor([[-0.6178, 0.1537, 0.2786, 0.4218], [-0.1340, 0.6531, 0.3963, 0.8801], [-0.7938, 0.7117, 0.6256, 0.6363]], grad_fn=\u0026lt;TanhBackward\u0026gt;), tensor([[-0.6178, 0.1537, 0.2786, 0.4218], [-0.1340, 0.6531, 0.3963, 0.8801], [-0.7938, 0.7117, 0.6256, 0.6363]], grad_fn=\u0026lt;TanhBackward\u0026gt;)) Using Scripting to Convert Modules 上述示例我们使用MyCell的第二个版本而不是带有控制流加载子模块的版本是有原因的，现在我们来探究一下：\nclass MyDecisionGate(torch.nn.Module): def forward(self, x): if x.sum() \u0026gt; 0: return x else: return -x class MyCell(torch.nn.Module): def __init__(self, dg): super(MyCell, self).__init__() self.dg = dg self.linear = torch.nn.Linear(4, 4) def forward(self, x, h): new_h = torch.tanh(self.dg(self.linear(x)) + h) return new_h, new_h my_cell = MyCell(MyDecisionGate()) traced_cell = torch.jit.trace(my_cell, (x, h)) print(traced_cell.dg.code) print(traced_cell.code) def forward(self, argument_1: Tensor) -\u0026gt; Tensor: return torch.neg(argument_1) def forward(self, input: Tensor, h: Tensor) -\u0026gt; Tuple[Tensor, Tensor]: _0 = (self.dg).forward((self.linear).forward(input, ), ) _1 = torch.tanh(torch.add(_0, h, alpha=1)) return (_1, _1) /home/jensen/.conda/envs/venv_torch/lib/python3.7/site-packages/ipykernel_launcher.py:3: TracerWarning: Converting a tensor to a Python boolean might cause the trace to be incorrect. We can't record the data flow of Python values, so this value will be treated as a constant in the future. This means that the trace might not generalize to other inputs! This is separate from the ipykernel package so we can avoid doing imports until 查看.code的输出，可以发现完全找不到if-else的踪迹！WHY?! Tracing所做的正如我们所说的那样，运行代码，记录所发生的操作，并构造一个执行这些操作的ScriptModule。不幸的是，像控制流这样的操作被擦除了。\n那如何在TorchScript中准确地表示这个模块？我们提供了一个script compiler，它可以直接分析Python源代码，并将其转换为TorchScript。让我们直接使用script compiler转换MyDecisionGate：\nscripted_gate = torch.jit.script(MyDecisionGate()) my_cell = MyCell(scripted_gate) scripted_cell = torch.jit.script(my_cell) print(scripted_gate.code) print(scripted_cell.code) def forward(self, x: Tensor) -\u0026gt; Tensor: _0 = bool(torch.gt(torch.sum(x, dtype=None), 0)) if _0: _1 = x else: _1 = torch.neg(x) return _1 def forward(self, x: Tensor, h: Tensor) -\u0026gt; Tuple[Tensor, Tensor]: _0 = (self.dg).forward((self.linear).forward(x, ), ) new_h = torch.tanh(torch.add(_0, h, alpha=1)) return (new_h, new_h) 太棒了！我们现在已经准确地捕获了我们的程序在TorchScript中的行为。现在让我们尝试运行该程序：\n# New inputs x, h = torch.rand(3, 4), torch.rand(3, 4) scripted_cell(x, h) (tensor([[0.7933, 0.2852, 0.3526, 0.0098], [0.7790, 0.6442, 0.5631, 0.6060], [0.4623, 0.2208, 0.0442, 0.8844]], grad_fn=\u0026lt;TanhBackward\u0026gt;), tensor([[0.7933, 0.2852, 0.3526, 0.0098], [0.7790, 0.6442, 0.5631, 0.6060], [0.4623, 0.2208, 0.0442, 0.8844]], grad_fn=\u0026lt;TanhBackward\u0026gt;)) 混合Scripting和Tracing 有些情况下需要使用tracing而不是scripting（例如，模块中含有许多架构决策，这些决策是基于我们不希望出现在TorchScript中常量Python值做出的）。这种情况下，可以将scripting和tracing结合起来使用：torch.jit.script将会内联一个traced模块，tracing将会内联一个scripted模块。\n第一种情况的示例：\nclass MyRNNLoop(torch.nn.Module): def __init__(self): super(MyRNNLoop, self).__init__() self.cell = torch.jit.trace(MyCell(scripted_gate), (x, h)) def forward(self, xs): h, y = torch.zeros(3, 4), torch.zeros(3, 4) for i in range(xs.size(0)): y, h = self.cell(xs[i], h) return y, h run_loop = torch.jit.script(MyRNNLoop()) print(run_loop.code) print(run_loop.cell.code) print(run_loop.cell.dg.code) def forward(self, xs: Tensor) -\u0026gt; Tuple[Tensor, Tensor]: h = torch.zeros([3, 4], dtype=None, layout=None, device=None, pin_memory=None) y = torch.zeros([3, 4], dtype=None, layout=None, device=None, pin_memory=None) y0 = y h0 = h for i in range(torch.size(xs, 0)): _0 = (self.cell).forward(torch.select(xs, 0, i), h0, ) y1, h1, = _0 y0, h0 = y1, h1 return (y0, h0) def forward(self, input: Tensor, h: Tensor) -\u0026gt; Tuple[Tensor, Tensor]: _0 = (self.dg).forward((self.linear).forward(input, ), ) _1 = torch.tanh(torch.add(_0, h, alpha=1)) return (_1, _1) def forward(self, x: Tensor) -\u0026gt; Tensor: _0 = bool(torch.gt(torch.sum(x, dtype=None), 0)) if _0: _1 = x else: _1 = torch.neg(x) return _1 第二种情况的例子：\nclass WrapRNN(torch.nn.Module): def __init__(self): super(WrapRNN, self).__init__() self.loop = torch.jit.script(MyRNNLoop()) def forward(self, xs): y, h = self.loop(xs) return torch.relu(y) traced = torch.jit.trace(WrapRNN(), (torch.rand(10, 3, 4))) print(traced.code) print(traced.loop.code) print(traced.loop.cell.code) print(traced.loop.cell.dg.code) def forward(self, argument_1: Tensor) -\u0026gt; Tensor: _0, y, = (self.loop).forward(argument_1, ) return torch.relu(y) def forward(self, xs: Tensor) -\u0026gt; Tuple[Tensor, Tensor]: h = torch.zeros([3, 4], dtype=None, layout=None, device=None, pin_memory=None) y = torch.zeros([3, 4], dtype=None, layout=None, device=None, pin_memory=None) y0 = y h0 = h for i in range(torch.size(xs, 0)): _0 = (self.cell).forward(torch.select(xs, 0, i), h0, ) y1, h1, = _0 y0, h0 = y1, h1 return (y0, h0) def forward(self, input: Tensor, h: Tensor) -\u0026gt; Tuple[Tensor, Tensor]: _0 = (self.dg).forward((self.linear).forward(input, ), ) _1 = torch.tanh(torch.add(_0, h, alpha=1)) return (_1, _1) def forward(self, x: Tensor) -\u0026gt; Tensor: _0 = bool(torch.gt(torch.sum(x, dtype=None), 0)) if _0: _1 = x else: _1 = torch.neg(x) return _1 因而，scripting和tracing可以在情况需要时将它们合并在一起使用。\n保存和加载模型 我们提供了以存档格式将TorchScript模块保存和加载到磁盘或从磁盘加载的APIs。这种格式包含代码、参数、属性和调试信息，这意味着存档是模型的独立表示形式，可以在完全独立的进程中加载。\n接下来让我们保存并加载wrapped RNN模块：\ntraced.save(\u0026#39;wrapped_rnn.pt\u0026#39;) loaded = torch.jit.load(\u0026#39;wrapped_rnn.pt\u0026#39;) print(loaded) print(loaded.code) RecursiveScriptModule( original_name=WrapRNN (loop): RecursiveScriptModule( original_name=MyRNNLoop (cell): RecursiveScriptModule( original_name=MyCell (dg): RecursiveScriptModule(original_name=MyDecisionGate) (linear): RecursiveScriptModule(original_name=Linear) ) ) ) def forward(self, argument_1: Tensor) -\u0026gt; Tensor: _0, y, = (self.loop).forward(argument_1, ) return torch.relu(y) 如您所见，序列化保留了模块层次结构和我们一直在研究的代码。例如，也可以将模型加载到C++中，以便在不使用Python的情况下执行。\n延伸阅读 我们已经完成了本教程！有关更复杂的演示，请查看使用TorchScript转换机器翻译模型NeurIPS的演示：\nhttps://colab.research.google.com/drive/1HiICg6jRkBnr5hvK2-VnMi88Vi9pUzEJ\n","date":"2022-09-19T00:00:00Z","permalink":"https://jen-jon.github.io/posts/20220919/","tags":"PyTorch；JIT","title":"TorchScript教程（译）","type":"technology"},{"contents":"这篇文章可以写的更好，欢迎到 https://github.com/haoel/haoel.github.io 更新\n科学上网 0. 序 1. 英文能力 2. 购买 VPS 2.1 常规 VPS 2.2 CN2 线路 2.3 NCP 线路 3. 搭建相关代理服务 3.1 设置 Docker 服务 3.2 开启 TCP BBR 拥塞控制算法 3.3 用 Gost 设置 HTTPS 服务 3.4 设置 ShadowSocks 服务 3.5 设置 L2TP/IPSec 服务 3.6 设置 PPTP 服务 4. 客户端设置 4.1 gost 客户端 4.2 Shadowsocks 客户端 4.3 VPN 客户端 5. 流量伪装和其它方式 5.1 V2Ray 5.2 Brook 6. 针对 IP 被封的解决方案 6.1 Cloudflare 6.2 V2Ray 6.3 补充 7. 家用透明网关 7.1 OpenWRT 路由器 7.2 通过树莓派做旁路网关 7.3 安装 Clash 7.4 设置 iptables 转发 8. 数据中心透明网关 8.1 AWS 网络构建 8.2 安装 Clash 8.3 配置私有子网中的 EC2 8.4 私有子网中的 Kubernetes 9. 其它 9.1 其它方式 8.2 搭建脚本 10. 代理技巧 10.1 HTTP 隧道 10.2 SSH 隧道 序 首先，我们先明确一下，我科学上网的目的主要是为了学习、工作、交友、查资料、和丰富自己的眼界，不是其它的事。\n对我来说，科学上网很重要，下面罗列一下需要科学上网，我才能真正学习工作和生活的网站：\nYoutube 和 Vimeo 上的各种大会和教学视频，除了我自己要学，我的孩子也要学。 Wikipedia 维基百科是我目前唯一信得过的百科全书，我在上面可以比较系统地翻阅各种词条。 SlideShare 上有很多的技术文档和资料的 PPT，是我的知识学习的地方。 Quora 问答网站，在上面有很多有趣的问答。 博客和论文，很多博客和论文站点都被墙了，比如：Blogspot 和 Medium。 Google 的各种服务，比如：Gmail, Map, Docs，Driver，照片，图片搜索，Voices，论文搜索…… 包括 Google 官方的各种技术文档…… 一些云服务，比如：Dropbox，IFTTT，Imgur，archive.org…… Twitter 上 Follow 一些牛人和一些官方账号，比如：AWS、Docker…… 社交 Facebook, Telegram, Whatsapp, Slack……，有一些我在国外的亲戚和朋友…… Reddit 是一个聚合网站，一个新闻和文章的集散地，你可以认为是各种频道的今日头条…… Pinterest 和 Instagram 上面有很多不错的图片和视频新闻，是我减压力的地方…… 新闻，如 BBC。 BBC 是全球比较出众的媒体，有太多的有价值资源和内容了，比如纪录片、学英文…… 编程，有很多编程的场景需要翻墙，比如，Go 语言编程时的 go get 中的很多库是放在 Google 的服务器上， 然而 Google 是全部被墙，包括 Android 和其它一些文档和资源也是一样。包括 SourceForge 的某些项目也需要科学上网，Docker Registry 也有部分被墙，还有偶尔抽风的 Github，以及不能访问的 gist…… …… 等等 是的，我的互联网不是——全是骗子的百度、充满广告的微信朋友圈、质量低下的公众号、娱乐至死的新浪微博、只有抖机灵和 “怎么看 XX” 的知乎、毫无营养的今日头条…… 在这样的网络空间里，我真的无法生存…… 这根本不是互联网，不是为我服务的互联网，而是在消费我的互联网，是让我变傻变笨的互联网…… 我不能忍，因为它影响到了我的生存……\n英文能力 首先，你应该对英文读写没什么问题!\n为什么这么说？这主要是针对计算机相关的知识，逻辑是这样的，如果你上了 Google 还是在用中文关键词，那么你好不容易出来了，结果又回去了，所以没什么意义。 换言之，科学上网的目的是为了进入广阔的世界范围与全世界的人交流，所以，英文是必备的，如果你英文有问题，VPN 过去的用处也不大。\n所以，我把这个前提条件放在第一的位置，就是说—— 真正的墙不是 GFW，而是人的大脑！ 意思是，屏蔽你获得信息能力的不是墙，而很大一部分则是我们自己的语言能力！\n购买 VPS 然后，你需要一个 VPS。 在这里，强烈建议通过自建的方式，可能成本会比托管的 “机场” 要高一些，而且还很麻烦，但是，在安全性方面会比较好一些。自己动手，自力更生，让人有更多的安全感。\n（注：当然，你也可以直接购买一些科学上网的服务，但我这里不推荐了，一方面是广告，另一方面通常这样的服务非常的不稳定，而且也容易被代理方做中间人攻击）\n现在你买一台 VPS 也不贵了，也就是一个月 10 美金左右（70 元），我个人觉得一个月花 70 元钱不算奢侈的事，而且会让你的生活质量得得改善。当然，线路好的得需要多花一些钱。。\n（注：我现在每个月投入在科学上网上的成本大概在不到 500 元人民币左右，常备 3-5 个不同国家的 VPS，因为国内的网络路由经常性的变化，所以，为了确保总是有一条快的，所以，得多备几个）。\n2.1 常规 VPS 对于 VPS，下面是一些常规选项。\nAWS LightSail 是一个非常便宜好用的服务，最低配置一个月 $3.5 美金，流量不限，目前的 Zone 不多，推荐使用日本，新加坡或美国俄勒冈（支持银联卡） AWS EC2 香港、日本或韩国申请个免费试用一年的 EC2 VPS （支持银联卡） Google Cloud Platform 提供免费试用，赠送 300 刀赠金（需要国际信用卡） Linode 买个一月 USD5 刀的 VPS Conoha 上买一个日本的 VPS，一个月 900 日元 （可以支付宝） Vultr 上买一个日本的 VPS，一个月 5 刀 （可以支付宝）(注：据说被墙的 IP 太多） Oracle Cloud 两台 VPS 无限期使用，可选美日韩等地（需要国际信用卡） 注意\n在中国，因为有太多的网络提供商，所以，国内的网络也是很奇葩的，可以看到的是，不同的地方，不同的网络，到不同的国家完全不一样，而且还经常性地调整路由，所以，经常性地有时候快有时候慢，简直就是随机的。所以，像我这样要求比较高的人，一般会备 3-5 个不同国家地区的 VPS，以保障上网的速度。\n香港网速应该是比较好的，但是香港的成本也是比较高的。台湾的网速也是不错的，日本的网速其次，新加坡再次之，然后是美国的东海岸（这里是基于北京和上海的情况）\n日本区的网络质量并不一定很好，有时候快的飞快，但有时候会有很大的丢包率（不同的网络不一样），有时候会很慢。上述的这几个 VPS 服务商中，AWS 韩国和日本会好点，然后是 Linode，最后是 Conoha 和 Vultr（如果你有更好的，请推荐）\nGoogle Cloud Platform - GCP 的香港和台湾节点也是很快的。但是你要能买 GCP 的主机，你还得先翻墙，所以，感觉有点死锁了。所以，你可能先用 Vultr（按时付费）翻墙，然后再到 GCP 上购买。\n2.2 CN2 线路 如果你需要更好更高速的网络服务（比如你要看 Youtube 的 1080P），那么，你需要下面的这些服务器资源了（价格也会高一些）\nCN2 和 GIA 是两个关键词。CN2 GIA 全称 China telecom Next Carrier Network- Global Internet Access 电信国际精品网络，特征是路由线路上骨干节点均为 59.43 开头的 IP。如果想要寻找接入 CN2 线路的国外 VPS 提供商，建议使用 Next Carrier Network 或者 CN2 这个关键词搜索即可。\n多说一句， CN2 本身又分为两种类型：\nCN2 GT: CN2 里属于 Global Transit 的产品 (又名 GIS-Global Internet Service)，在 CN2 里等级低，省级 / 出国节点为 202.97 开头，国际骨干节点有 2～4 个 59.43 开头的 CN2 节点。在出国线路上拥堵程度一般，相对于 163 骨干网的稍强，相比 CN2 GIA，性价比也较高。\nCN2 GIA: CN2 里属于 Global Internet Access 的产品，等级最高，省级 / 出国 / 国际骨干节点都以59.43开头，全程没有202.97开头的节点。在出国线路上表现最好，很少拥堵，理论上速度最快最稳定，当然，价格也相对 CN2 GT 偏高。\n关于 CN2 线路的主机提供商，下面罗列几个\n搬瓦工 这应该是美区最好的一个用来科学上网的 VPS 提供商了，实测飞快。购买时你需要注意 VPS 规格上的 CN2 和 GIA 的描述。（注：点击主页右上角的 regisiter 以后，你可以看到页面上方有两个导航条，在下面的导航条上点 Services -\u0026gt; Order New Services 就可以看到所有的列表了。买完后，你可能需要重装一下操作系统，装成 64 位带 BBR 的 ） Gigsgigscloud CN2 GIA 在香港的节点是很不错的，当然，价格也很不错（建议几个人一起平摊费用） Hostdare 的 CN2 GIA 产品也是三网直连，KVM 和 OpenVZ 两种架构，KVM 产品长期缺货 更多的可以参考这篇文章《CN2 GIA VPS 主机收集整理汇总 - 电信, 联通, 移动三网 CN2 GIA 线路 VPS 主机》（注：随时间推移，这篇文章的内容可能会失效）\n重点说一下，CN2 GIA + 香港机房，你会得到巨快无比的上网速度（无论你在中国的哪个位置，无论使用哪家运营商，CN2 GIA 都是最优的），然而，香港地区的 VPS 的确是有点贵了。在 Youtube.com 上看 4K 的视频毫无压力。虽然阿里云和腾讯的也有，但是被查到的风险基本上是 100%，不建议使用，被抓了别怪我没警告过你。\n2.3 NCP 线路 NCP 全称 New Cross Pacific（新跨太平洋海底光缆系统）。 2018 年 11 月底，中国到美国之间的海底光缆新开通了 NCP 线路，并且容量更大（系统设计容量超过 80Tbps），路由更少（中国上海到美国中间路由节点只有 11 个，ping 值 110ms）。\nNCP 线路全长 13,000 公里，连接美国俄勒冈州希尔斯伯勒，连接崇明（中国大陆），南汇（中国大陆），临港（中国大陆），釜山（韩国），头城（台湾），和丸山（日本）。\n相对于第二条中美直达海底光缆系统（跨太平洋快线，TPE），现阶段 NCP 线路的网络流量更少更稳定。特征是华东 / 中地区流量会经过 NCP 直达路由节点，IP 地址为 202.97.95.201/202。\n关于 NCP 线路的主机提供商，下面罗列两个（欢迎补充）\n50KVM VPS 截止 2018 年 12 月 2 日 KVM 产品最低价格￥81.60 / 月。 OLVPS 截止 2018 年 12 月 2 日 KVM 产品最低价格 ¥22 / 月。（特别注意 ： 在 OLVPS 上的《服务条款》 中有一条说明：“禁止 OpenV_P_N/Socks5/PPTP/L2TP 等软件、公共代理”，所以，可能 OLPVS 并不太适合） 搭建相关代理服务 注：如下的搭建和安装脚本可参看本库的 scripts 目录下的脚本，如： Ubuntu 18.04 Installation Script （感谢网友 @gongzili456 开发）\n3.1 设置 Docker 服务 首先，你要安装一个 Docker CE 服务，这里你要去看一下 docker 官方的安装文档：\nCentOS 上的 Docker CE 安装 Ubuntu 上的 Docker CE 安装 然后开始设置你的 VPN/SS 服务\n3.2 开启 TCP BBR 拥塞控制算法 TCP BBR（Bottleneck Bandwidth and Round-trip propagation time）是由 Google 设计，于 2016 年发布的拥塞算法。以往大部分拥塞算法是基于丢包来作为降低传输速率的信号，而 BBR 则基于模型主动探测。该算法使用网络最近出站数据分组当时的最大带宽和往返时间来创建网络的显式模型。数据包传输的每个累积或选择性确认用于生成记录在数据包传输过程和确认返回期间的时间内所传送数据量的采样率。该算法认为随着网络接口控制器逐渐进入千兆速度时，分组丢失不应该被认为是识别拥塞的主要决定因素，所以基于模型的拥塞控制算法能有更高的吞吐量和更低的延迟，可以用 BBR 来替代其他流行的拥塞算法，例如 CUBIC。Google 在 YouTube 上应用该算法，将全球平均的 YouTube 网络吞吐量提高了 4%，在一些国家超过了 14%。\nBBR 之后移植入 Linux 内核 4.9 版本，并且对于 QUIC 可用。\n如果开启，请参看 《开启 TCP BBR 拥塞控制算法 》\n3.3 用 Gost 设置 HTTPS 服务 gost 是一个非常强的代理服务，它可以设置成 HTTPS 代理，然后把你的服务伪装成一个 Web 服务器，我感觉这比其它的流量伪装更好，也更隐蔽。这也是这里强烈推荐的一个方式。\n为了更为的隐蔽，你需要一个域名（可以上 GoDaddy，但一定要使用美国版），然后使用 Let’s Encrypt 来签 一个证书。使用 Let’s Encrypt 证书你需要在服务器上安装一个 certbot，点击 certbot 这个链接，你可以选择你的服务器，操作系统，然后就跟着指令走吧。\n接下来，你需要申请一个证书（我们使用 standalone 的方式，然后，你需要输入你的电子邮件和你的域名）：\n$ sudo certbot certonly --standalone 证书默认生成在 /etc/letsencrypt/live/\u0026lt;YOUR.DOMAIN.COM/\u0026gt; 目录下，这个证书 90 天后就过期了，所以，需要使用一个 cron job 来定期更新（稍后给出）\n接下来就是启动 gost 服务了，我们这里还是使用 Docker 的方式建立 gost 服务器。\n#!/bin/bash # 下面的四个参数需要改成你的 DOMAIN=\u0026#34;YOU.DOMAIN.NAME\u0026#34; USER=\u0026#34;username\u0026#34; PASS=\u0026#34;password\u0026#34; PORT=443 BIND_IP=0.0.0.0 CERT_DIR=/etc/letsencrypt CERT=${CERT_DIR}/live/${DOMAIN}/fullchain.pem KEY=${CERT_DIR}/live/${DOMAIN}/privkey.pem sudo docker run -d --name gost \\ -v ${CERT_DIR}:${CERT_DIR}:ro \\ --net=host ginuerzh/gost \\ -L \u0026#34;http2://${USER}:${PASS}@${BIND_IP}:${PORT}?cert=${CERT}\u0026amp;key=${KEY}\u0026amp;probe_resist=code:404\u0026amp;knock=www.google.com\u0026#34; 上面这个脚本，你需要配置：域名 (DOMAIN), 用户名 (USER), 密码 (PASS) 和 端口号 (PORT) 这几个变量。\n关于 gost 的参数， 你可以参看其文档：Gost Wiki，上面我设置一个参数 probe_resist=code:404 意思是，如果服务器被探测，或是用浏览器来访问，返回 404 错误，也可以返回一个网页（如：probe_resist=file:/path/to/file.txt 或其它网站 probe_resist=web:example.com/page.html）\n注意：开启了探测防御功能后，当认证失败时服务器默认不会响应 407 Proxy Authentication Required，但某些情况下客户端需要服务器告知代理是否需要认证 (例如 Chrome 中的 SwitchyOmega 插件)。通过 knock 参数设置服务器才会发送 407 响应。对于上面的例子，我们的knock参数配置的是www.google.com，所以，你需要先访问一下 https://www.google.com 让服务端返回一个 407 后，SwitchyOmega 才能正常工作。\n注意：如果认证信息（也就是用户名和密码）中包含特殊字符，则可以（应该是必须！否则客户端一侧会有很多不兼容）通过 auth 参数来设置：\ngost -L :8080?auth=YWRtaW46MTIzNDU2 -F ss://:8338?auth=Y2hhY2hhMjA6QWEjJiEkMTIzNEA1Njc4 auth 的值为 user:passbase64 编码值\n如无意外，你的服务就启起来了。你可以使用下面的命令验证你的 gost 服务是否正常。\ncurl -v \u0026#34;https://www.google.com\u0026#34; --proxy \u0026#34;https://DOMAIN\u0026#34; --proxy-user \u0026#39;USER:PASS\u0026#39; 接下来就是证书的自动化更新。\n可以使用命令 crontab -e 来编辑定时任务：\n0 0 1 * * /usr/bin/certbot renew --force-renewal 5 0 1 * * /usr/bin/docker restart gost 这样，服务器就配置完成了。客户端请移动后面的客户端章节。\n3.4 设置 ShadowSocks 服务 （注：ShadowSocks 被查的机率非常大，不推荐使用）\nShadowSocks 的 Docker 启动脚本 （其中的 SS_PORT 和 SS_PASSWD 需要重新定义一下）\n#!/bin/bash SS_PORT=1984 SS_PASSWD=MyPasswd sudo docker run -dt --name ss \\ -p ${SS_PORT}:${SS_PORT} mritd/shadowsocks \\ -s \u0026#34;-s 0.0.0.0 -p ${SS_PORT} -m aes-256-cfb -k ${SS_PASSWD} --fast-open\u0026#34; 3.5 设置 L2TP/IPSec 服务 （注：VPN 方式被查的机率非常大，不推荐使用）\nL2TP/IPSec 的启动脚本，其中的三个环境变量 USER， PASS 和 PSK 需要替换一下。\n#!/bin/bash USER=someone PASS=password PSK=psk_key sudo docker run -d --privileged \\ -e PSK=${PSK} \\ -e USERNAME=${USER} -e PASSWORD=${PASS} \\ -p 500:500/udp \\ -p 4500:4500/udp \\ -p 1701:1701/tcp \\ -p 1194:1194/udp \\ siomiz/softethervpn 3.6 设置 PPTP 服务 （注：PPTP 不安全，请不要使用）\nsudo docker run -d --privileged --net=host -v {/path_to_file/chap-secrets}:/etc/ppp/chap-secrets \\ mobtitude/vpn-pptp PPTP 使用 /etc/ppp/chap-secrets 文件设置用户名和密码，所以你需要给 docker 容器提供这个文件，下面是这个文件的示例：\n# Secrets for authentication using PAP # client server secret acceptable local IP addresses fuckgfw * whosyourdaddy * 客户端设置 4.1 gost 客户端 大多数的代理服务都支持 https 的代理，但是我们需要智能代理（也就是该翻的时候翻，不用翻的时候不翻），那么我们可以重用 ShadowSocks 的客户端。\n对于电脑来说，你同样可以 下载 gost 程序，然后使用下面的命令行：\ngost -L ss://aes-128-cfb:passcode@:1984 -F \u0026#39;https://USER:PASS@DOMAIN:443\u0026#39; 这样用 gost 在你的本机启动了一个 ShadowSocks 的服务，然后，把请求转到你在上面配置的 HTTPS 服务器上，这样就完成转接。\n┌─────────────┐ ┌─────────────┐ ┌─────────────┐ │ ShadowSocks │ │ │ │ │ │ Client ├──► Gost Client ├────────────► Gost Server │ │ (PAC Auto) │ │ │ │ │ └─────────────┘ └─────────────┘ └─────────────┘ ShadowSocks Client 主要完成：自动设置操作系统代理服务器的 pac （自动设置翻墙或是不翻墙的路由）\n这样，你的 ShadowSocks 客户端只需要简单的配置一个本机的 SS 配置就好了。\n对于手机端\niPhone，可以考虑使用 ShadowRocket （需要付费），其中使用 HTTPS 的代理，配置上就好了。 Android，可以考虑使用这个 Plugin - ShadowsocksGostPlugin 注明：如果你之前使用了 Chrome 插件 SwitchyOmega，如果无法直接配置 HTTPS 代理，具体原因可能是因为你设置了probe_resist以开启探测防御功能。这里，你需要在服务器端设置 knock 参数（参看 用 Gost 设置 HTTPS 服务 中的 “注意” 一节 ）\n或是，干脆使用 gost 客户端在本机启动一个 SOCKS5 的代理服务用来代替（gost -L socks5://:1080 -F 'https://USER:PASS@DOMAIN:443'），然后在 SwitchyOmega 配置代理为’127.0.0.1:1080’即可。比如:\n4.2 Shadowsocks 客户端 对于 Shadowsocks 客户端，可以到这里查看 Shadowsocks Clients\nMacOS 上你可以下载 ShadowsocksX-NG Windows 上你可以下载 Shadowsocks-Windows，需要先安装 .NET Framework Android 的客户端，你可以用手机访问并下载 Shadowsocks-Android iPhone 端就比较麻烦了。因为国内全都被下架了。 你需要注册一个美国的苹果 ID. 然后 iTunes/App Store 用这个美区的 ID 登录（不是退出 iCloud ，而是退出 App Store） 然后搜索 Potatso Lite ，ShadowRocket, Wingy, Quantumult 等。（我使用前两个） 注意\n关于如何注册美区 Apple ID 账号，你可以参看如下的这几篇文章（我不保证这些文章可不可用，但是你可以自行 Google）。 5 分钟注册美国区 Apple ID（18 年亲测有效） 2018 年 6 月亲测：注册美国地区苹果 apple ID 帐号终极教程 iOS 开发之注册美国 Apple Id 不需要绑定信用卡，亲测可用 4.3 VPN 客户端 对于 L2TP/IPSec，几乎所有的客户端操作系统（无论是 Windows/Mac/Linux 的电脑，还是 iPhone/Android）都支持，你可以自行 Google。\nMac OS X PPTP/L2TP 设置教程 Windows 7 操作系统配置 L2TP VPN 方法 流量伪装和其它方式 无论你用 VPN，SS，SSR，都有可能被识别，只有使用 HTTP over TLS 的样子，才会跟正常的流量混在一起，很难被识别，所以，目前来说，V2Ray 客户端 + Nginx + V2Ray 服务端的方式，或是 gost 的 HTTPS 的方式，基本上来说，在网络四层上看到的都是 TLS 的包，很难被识别。这种代理服务我觉得只能做探测，或是得到更多的算力来做统计学分析。所以，V2Ray 和 gost 的服务器端用 nginx 再挡一道，那么就很难被发现了。\n注： 说句老实话，我其时并不想害怕别人知道自己的上什么样的网站，因为我觉得我访问的都是合法的网站，但是就今天这个局势我也没办法——为什么要让像我这样的光明正大的良民搞得跟偷鸡摸狗之徒一样……\n5.1 V2Ray V2Ray 可以配置成一个非常隐蔽的代理软件。\nV2Ray 用户手册：https://www.v2fly.org V2Ray 项目地址：https://github.com/v2fly/v2ray-core 一般来说，祼用 V2Ray 不是一个很好的方式，现在比较流行的是使用 nginx 来代理，也就是 V2Ray + WebSocket + TLS + Nginx，可以参看这篇文章《V2Ray+WebSocket+TLS+Nginx 配置与使用教程》（需要翻墙）。\n我个人觉得，配置起来比较复杂，而且环节太多，不如直接用 gost 的 https/http2 的方式配置起来简单，所以，没有放在前面。\n5.2 Brook Brook 是一个由 Go 语言编写的跨平台代理软件，支持 Linux/MacOS/Windows/Android/iOS 各个平台。\nBrook Github 项目：https://github.com/txthinking/brook Github Wiki 教程：https://github.com/txthinking/brook/wiki / 使用说明 (中文) 服务器一行命令安装：\nwget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/brook.sh \u0026amp;\u0026amp; chmod +x brook.sh \u0026amp;\u0026amp; bash brook.sh 运行 brook.sh 会出菜单项，你可以按菜单项来，主要就是设置端口号，密码。很简单的，我这里就不截图了，因为这个脚本运行起来中文菜单式的。\n然后你可以在 Brook 项目的 Github 首页上下载不同平台的客户端。设置起来也很简单！\n注意: 如果运行出现下载错误，可能是因为 brook 的下载文件名问题，你需要自己修改一下脚本：\nDownload_brook(){ [[ ! -e ${file} ]] \u0026amp;\u0026amp; mkdir ${file} cd ${file} if [[ ${bit} == \u0026#34;x86_64\u0026#34; ]]; then -\twget --no-check-certificate -N \u0026#34;https://github.com/txthinking/brook/releases/download/${brook_new_ver}/brook\u0026#34; +\twget --no-check-certificate -N \u0026#34;https://github.com/txthinking/brook/releases/download/${brook_new_ver}/brook_linux_amd64\u0026#34; +\tmv brook_linux_amd64 brook else wget --no-check-certificate -N \u0026#34;https://github.com/txthinking/brook/releases/download/${brook_new_ver}/brook_linux_386\u0026#34; mv brook_linux_386 brook fi 针对 IP 被封的解决方案 花钱购买的 VPS 即便做了流量伪装依然有很大的几率 IP 被封锁，大多 VPS 服务商并不提供更换 IP 的服务，使用 CDN 可以让被封锁的 VPS 继续发挥翻墙功能。\n6.1 Cloudflare Cloudflare 是一个 CDN 服务商，目前国内依然能正常的访问，可以作为跳板来实现翻墙。\n注册 Cloudflare 帐号，并有一个空闲域名（三级域名即可），交给 Cloudflare 托管并将域名指向被封的 VPS IP，注意开启 Proxied 并且 SSL-TLS 使用 Flexible 选项。\nCloudflare 只需免费方案足以，不必花钱。\n注：如果你要用 Cloudflare 来代理 gost 服务的话，你得使用 Websocket 协议\nserver: gost -L=mwss://user:password@:443 client: gost -L socks5://:1080 -F mwss://user:password@yourdomain:443 cloudflare: ssl/tls:full 6.2 V2Ray VPS 上正常安装并配置好 V2Ray，注意两点:\n传输协议必须要使用 ws 要使用 80 或者 8080 端口 如果端口有其他用途，那么用 Nginx/Caddy 之类软件，做一个 WebSocket proxy 到 V2Ray 即可。\n6.3 补充 客户端注意使用网址来连接。\n目前支持 WebSocket 的免费 CDN 似乎只有 Cloudflare 一家，国内 CDN 服务商既不支持也不安全，不要考虑了。如果有更好的服务商欢迎补充。\n网络延迟比直连增加不少，如果是频繁操作会很痛苦。网络带宽如果运气好可能比直连还优化了，用来看 Youtube 搞不好更流畅。\n家用透明网关 7.1 OpenWRT 路由器 所谓透明网关的意思是，一切都交给网关来做。最好的方式是你需要一个 OpenWRT 的路由器，推荐使用华硕的路由器，贵是贵一些，但是这几年用下来，非常不错。我用的是 华硕（ASUS） RT-AC68U 1900M AC 双频智能无线路由路 。\n路由器买来后，要刷一下固件。首先 Asuswrt 是华硕公司为他的路由器所开发的固件。Asuswrt-merlin 是一个对 Asuswrt 固件二次开发进行各种改进和修正的项目。源代码在这里：https://github.com/RMerl/asuswrt-merlin\n不必担心把路由器刷废了，华硕的路由器可以让你一键重置回来\n1）下载固件。先到 https://asuswrt.lostrealm.ca/download 下载相应的固件，并解压。（我下载的是 RT-AC68U_380.61_0.zip ）\n2）升级固件。登录到你的路由器后台 http://192.168.1.1/ ，在 系统管理 -\u0026gt; 固件升级 中上传固件文件（我上传的是：RT-AC68U_380.61_0.trx）\n3）打开 JFFS 分区。系统管理 -\u0026gt; 系统设置 -\u0026gt; Persistent JFFS2 partition\nFormat JFFS partition at next boot - 否 Enable JFFS custom scripts and configs - 是 4）打开 ssh 登录。 系统管理 -\u0026gt; 系统设置 -\u0026gt; SSH Daemon\nAllow SSH password login - 是 接下来，在 WiFi 路由器上安装 Clash，就可以了。\n大概的示意图如下所示。\nPhone/PC/Pad （无需设置） │ │ │ 1 │ ┌────────▼──────┐ │ │ │ WiFi Router │ （安装 Clash 网关） │ │ └─────┬────┬────┘ │ │ │ │ 2 │ └────────► 墙内 - China LAN 3 │ ┌─────▼──────┐ │ VPS │ │ Proxy │ └─────┬──────┘ │ │ ▼ 墙外 - Internet WAN 7.2 通过树莓派做旁路网关 如果你的路由器不能刷 OpenWRT，也就是没法通过 SSH 登录上去装软件，你就用一个别的设备。比如用一个树莓派。我正好有一个很老旧的树莓派，刷了一个老旧的 Debian 7.5 的操作系统。\n把它连上你的路由器上，然后，\n你需要把你设备上的 IP 地址、网关和 DNS 服务器都要手动设置到这个树莓派上。 于是，所有的路由就会通过路由器转到树莓派上，再由树莓派决定是否要走代理。 大概的示意图如下所示。\n1 –\u0026gt; 2 是设备把所有的请求都发给树莓派。 3 –\u0026gt; 3.1 或 3.2 是由树莓派来决走是否翻墙。 Phone/PC/Pad （设置\u0026#34;网关\u0026#34;和\u0026#34;DNS\u0026#34;为树莓派） │ │ │ 1 │ （安装 Clash 网关） ┌────────▼──────┐ 2 ┌───────────┐ │ ├──────────────► │ │ WiFi Router │ │ 树莓派 │ │ ◄──────────────┤ │ └─────┬────┬────┘ 3 └───────────┘ │ │ │ │ 3.2 │ └────────► 墙内 - China LAN 3.1 │ ┌─────▼──────┐ │ VPS │ │ Proxy │ └─────┬──────┘ │ │ ▼ 墙外 - Internet WAN 7.3 安装 Clash Clash 的 Github 项目是：Dreamacro/clash ，在它的 Release 页面上，你可以找到相关的下载。（注：在本文更新的时候，如果你需要支持 Tun，你需要下载 Clash 的 Premium 版本\nClash 支持很多翻墙协议：ShadowSocks(R), Vmess, Socks5, HTTP(s)，Snell，Trojan。\n在你的 OpenWRT 或 树莓派 下用 uname -m 查看一下你的硬件架构是什么的，比如，我的是华硕和树莓派都是 armv7l 的，所以，需要下载 clash-linux-armv7-....的版本（注：根据 clash 官方仓库 Dreamacro/clash#189 系列固件不适用 armv7l 架构的 AC68U，需选择 armv5）。 下载完解压后，加个可执行权限 chmod +x clash 就可以运行了，不过，还差一个界面和两个配置文件，它们的目录关系如下：\n├── clash \u0026lt;- 建一个 clash 的目录 │ ├── clash \u0026lt;- 运行文件 │ ├── config.yaml \u0026lt;- 配置文件 │ ├── Country.mmdb \u0026lt;- IP地址库 │ └── ui \u0026lt;- Clash 的 UI │ ├── index.html │ ├── ... UI 界面可以到 haishah/yacd 下载。放到 clash 的配置目录下 ui 目录下\n一个是 Country.mmdb 这是 IP 地址的在哪个国家的数据库。你需要到这里下载 - Country.mmdb （当然，clash 启动时，会自动下载，我这里给你一个手动下载的链接）\n另一个是 config.yaml 文件，这个文件详细解释可参看 - 官方 Wiki\n下面是个示例：\nport: 7890 socks-port: 7891 redir-port: 7892 mixed-port: 7893 ipv6: false allow-lan: true mode: Rule log-level: info external-controller: \u0026#39;0.0.0.0:9090\u0026#39; external-ui: ui secret: \u0026#39;\u0026#39; tun: enable: true stack: system dns-hijack: - tcp://8.8.8.8:53 - udp://8.8.8.8:53 dns: enable: true ipv6: false listen: 0.0.0.0:53 default-nameserver: - 114.114.114.114 #enhanced-mode: redir-host enhanced-mode: fake-ip #如果要玩netflix，需要使用fake-ip fake-ip-range: 198.18.0.1/16 nameserver: - 114.114.114.114 - 223.5.5.5 - tls://8.8.8.8:853 fallback: - tls://8.8.8.8:853 # 两个代理服务器 proxies: # http - name: \u0026#34;https01\u0026#34; type: http server: https.server.domain port: 443 username: user password: \u0026#34;password\u0026#34; tls: true # https skip-cert-verify: true - name: \u0026#34;https01\u0026#34; type: http server: https.server.domain port: 443 username: user password: \u0026#34;passowrd\u0026#34; tls: true # https skip-cert-verify: true # 配置 Group proxy-groups: # 自动切换 - name: \u0026#34;auto\u0026#34; type: url-test proxies: - us01_https #- us02_https #- hk_https # tolerance: 150 url: \u0026#39;https://www.google.com/\u0026#39; interval: 300 # 按需选择 - 可以在UI上选择 - name: \u0026#34;netflix\u0026#34; type: select proxies: - us01_https - us02_https - hk_https rules: # LAN - DOMAIN-SUFFIX,local,DIRECT - IP-CIDR,127.0.0.0/8,DIRECT - IP-CIDR,172.16.0.0/12,DIRECT - IP-CIDR,192.168.0.0/16,DIRECT - IP-CIDR,10.0.0.0/8,DIRECT # Netflix - DOMAIN-SUFFIX,fast.com,netflix - DOMAIN-SUFFIX,api-global.netflix.com,netflix - DOMAIN-SUFFIX,netflix.com,netflix - DOMAIN-SUFFIX,netflix.net,netflix - DOMAIN-SUFFIX,nflxext.com,netflix - DOMAIN-SUFFIX,nflximg.com,netflix - DOMAIN-SUFFIX,nflximg.net,netflix - DOMAIN-SUFFIX,nflxso.net,netflix - DOMAIN-SUFFIX,nflxvideo.net,netflix # 最终规则（除了中国区的IP之外的，全部翻墙） - GEOIP,CN,DIRECT - MATCH,auto 更多的规则网上可以找到很多，也可以参看这里：SS-Rule-Snippet/LAZY_RULES/clash.yaml\n这个时候你就可以启动 clash 了：\n/path/to/clash/cash -d /path/to/clash \u0026amp; 然后，你就可以把你的上网设备上的 路由网关 和 DNS 服务器都手动地配置成这个网关就好了（OpenWRT 应该不用配置了，树莓派的方式需要手动配置一下）\n7.4 设置 iptables 转发 iptables -t nat -N CLASH iptables -t nat -A CLASH -d 10.0.0.0/8 -j RETURN iptables -t nat -A CLASH -d 127.0.0.0/8 -j RETURN iptables -t nat -A CLASH -d 169.254.0.0/16 -j RETURN iptables -t nat -A CLASH -d 172.16.0.0/12 -j RETURN iptables -t nat -A CLASH -d 192.168.0.0/16 -j RETURN iptables -t nat -A CLASH -d 224.0.0.0/4 -j RETURN iptables -t nat -A CLASH -d 240.0.0.0/4 -j RETURN iptables -t nat -A CLASH -p tcp -j REDIRECT --to-ports 7892 然后，你可以保存一下这些 iptables 的规则\niptables-save \u0026gt; /etc/iptables.up.rules 编辑 /etc/network/if-pre-up.d/iptables，在网卡启动的时候加载这些规则\n#!/bin/sh /sbin/iptables-restore \u0026lt; /etc/iptables.up.rules 然后，再 chmod +x /etc/network/if-pre-up.d/iptables 加上可执行权限就好了。\n数据中心透明网关 这里仅针对 AWS 进行说明，其它云平台应该大同小异，大家可以补充。\n8.1 AWS 网络构建 构建一个 172.20.0.0/16 的 VPC，分成两个子网： 有公网 IP 的公有子网 - 172.20.1.0/24 无公网 IP 的私有子网 - 172.20.2.0/24 在公有子网里创建 EC2 NAT Instance 创建时，指定私网 IP 为 172.20.1.1 （Option）为该实例分配弹性 IP，可成为外网访问内网的跳板机 建立路由规则 创建 “互联网网关”，并把“互联网网关” 添加到公有子网 172.20.1.0/24 的路由表中 把 EC2 NAT Instance 172.20.1.1 添加到私有子网172.20.2.0/24的路由表中。 于是整个网络就如下所示。\n┌──────────┐ │ │ │ │ └──────────┘ 弹性IP 互联网网关 ┌───────────────┐ ▲ │xxx.xxx.xxx.xxx├─┐ │ └───────────────┘ │ ┌───────────┘ │ │ ┌───────┼──┼────────┐ ┌───────────────────┐ │ │ │ │ │ │ │ ┌─┴──▼──┐ │ │ ┌─┐ ┌─┐ ┌─┐ ┌─┐ │ Public Network │ │ │◄────┼───┬───┼─►└─┘ └─┘ └─┘ └─┘ │ Private Network │ └───────┘ │ │ │ │ │ EC2 NAT Instance │ │ │ ┌─┐ ┌─┐ ┌─┐ ┌─┐ │ │ 172.20.1.1 │ ├───┼─►└─┘ └─┘ └─┘ └─┘ │ │ │ │ │ │ │ (NAT Instance) │ │ │ ┌─┐ ┌─┐ ┌─┐ │ │ │ └───┼─► └─┘ └─┘ └─┘ │ │ │ │ │ └───────────────────┘ └───────────────────┘ 172.20.1.0/24 172.20.2.0/24 ▲ ▲ subnet │ │ subnet │ │ └────────── VPC ───────────┘ 172.20.0.0/16 注：你需要认真的按照 EC2 NAT Instance 的文档进行设置这个 NAT 实例。尤其需要设置下面几项：\nsudo sysctl -w net.ipv4.ip_forward=1 sudo iptables -A FORWARD -i eth0 -j ACCEPT sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE 顺便科普一下：\nnet.ipv4.ip_forward 是内核参数，主要是用来把 Linux 当成路由器来用的参数。一般来说，一个路由器至少要有两个网络接口，一个是 WAN，的一个是 LAN 的，为了让 LAN 和 WAN 的流量相通，需要进行内核上路由。 iptables -A FORWARD -i eth0 -j ACCEPT 通行所有需要转发的包，只有机器成为一个路由器时，需要在两个网卡间进行网络包转发时，才需要配置这条规则。 iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE 关键字 MASQUERADE 意思是 “伪装 “，NAT 的工作原理是就像是一个宿舍收发室对学生宿舍一样，学生宿舍的地址外部不可见，邮递员只看得见整栋宿舍收发室的地址，邮递员把快递交给收发室，收发室再把快递转给学习宿舍（反之，如果学生要对外寄邮件，也是先到收发室，收发室传给邮局）。现在的问题是，所有的学生宿舍如何才能参与到任何快递的通信中，如果把学生宿舍地址发到外部，则没人能把信送回来。如果这个收发室是个自动化的机器人，他要干的事就是，把学生宿舍的地址换成收发室地址。这就是 MASQUERADE 的意思——来自具有接收方 IP 地址的本地网络到达 Internet 某处的数据包必须进行修改，也就是让发送方的地址等于路由器的地址。 8.2 安装 Clash 在 EC2 NAT Instance 上安装 clash 透明网关，安装配置参看 7.3 安装 Clash ，基本一致。\n注：在实际操作中，没有设置 iptables 转发规则\n8.3 配置私有子网中的 EC2 只需要配置 /etc/resolv.conf 文件，把 EC2 NAT Instance 加入其中。如：\n# /etc/resolv.conf nameserver 172.20.1.1 #\u0026lt;--- 透明网关 EC2 NAT 实例 nameserver 172.20.0.2 #\u0026lt;--- AWS 的 DNS 服务 search [zone].compute.internal 8.4 私有子网中的 Kubernetes K8s 里有两组 CoreDNS 部署和配置，一组是边缘的（或是叫本地的），一组是中心的。\n边缘的 Pod 名叫 nodelocaldns，侦听在本机。如：169.254.25.10:53 中心的 Pod 名叫 coredns，侦听在 cluster IP 上，如：10.233.0.3:53 边缘的规则会把 k8s 的域名 cluster.local, in-addr.arp ip6.arpa 转给中心的 CoreDNS 处理，其它的交给本地的 /etc/resolv.conf 处理。\nKubernetes 会把如下内容打到 Pod 里的 /etc/resolv.conf\nnameserver 169.254.25.10 search default.svc.cluster.local svc.cluster.local cluster.local cn-northwest-1.compute.internal options ndots:5 查看一下 nodelocaldns 的配置：\n$ kubectl get cm nodelocaldns -n kube-system -o yaml 我们可以看到，除了 K8s 自己的域名外，其它的都交给了本机的 /etc/resolv.conf，如下所示：\n.:53 { errors cache 30 reload loop bind 169.254.25.10 forward . /etc/resolv.conf # \u0026lt;--- 注意这条语句 prometheus :9253 } 然而，本机的 /etc/resolv.conf 里有两个 DNS，一个是我们的透明网关，一个是 AWS 的。而 CoreDNS 的 forward 策略是随机挑选，所以，这样的会导致，时而交给 AWS 处理，时而交给我们自己的 clash 处理。最终导致 IP 解析紊乱。\n通过以下命令进行修改：\n$ kubectl edit cm nodelocaldns -n kube-system 修改如下：（AWS 的归 172.20.0.2， 其它的走我们自己的网关）\n+ compute.internal:53 { + errors + cache 30 + reload + loop + bind 169.254.25.10 + forward . 172.20.0.2 + prometheus :9253 + } .:53 { errors cache 30 reload loop bind 169.254.25.10 - forward . /etc/resolv.conf + forward . /etc/resolv.conf { + policy sequential + } prometheus: 9253 } 退出保存后，等大约 30 秒左右配置就会生效。\n其它 9.1 其它方式 如下还有一些其它的方式（注：均由网友提供，我没有验证过）\nOutline 是由 Google 旗下 Jigsaw 团队开发的整套翻墙解决方案。Server 端使用 Shadowsocks，MacOS, Windows, iOS, Android 均有官方客户端。使用 Outline Manager 可以一键配置 DigitalOcean。其他平台例如 AWS, Google Cloud 也提供相应脚本。主要优点就是使用简单并且整个软件栈全部开源，有专业团队长期维护。\n9.2 搭建脚本 上述的搭建和安装脚本可参看本库的 scripts 目录下的脚本（感谢网友 @gongzili456 开发）\nUbuntu 18.04 Installation Script 代理技巧 看到这里，相信已经能够按照上面的教程搭建好自己的上网环境，但是灵活的应用网络，你还需要了解一技巧，比如 SOCKS 协议, http 隧道 和 ssh 网络隧道等。\nSOCKS 协议 HTTP 隧道 10.1 HTTP 隧道 常见的软件 curl , git, wget 都能通过设置 HTTP_PROXY,HTTPS_PROXY，NO_PROXY 来配置一个网络代理，NO_PROXY用来配置不需要代理的主机 (多个用逗号隔开), 那么我们就可以编写一个 bash 函数来运行需要走代理的命令:\nwith_proxy(){ HTTPS_PROXY=http://127.0.0.1:7890 HTTP_PROXY=http://127.0.0.1:7890 \u0026#34;$@\u0026#34; } 把上面的 127.0.0.1:7890 改成你自己的网络代理, 将上面脚本写入到 ~/.bashrc 中， source ~/.bashrc 后就能使用 with_proxy 这个函数了，比如我想要使用代理网络下载一个文件 with_proxy wget https://...., 想要使用代理网络从 github clone 一个项目 with_proxy git clone https://..., 当我们不用 with_proxy 这个函数的时候命令是不会走代理的，如果在 windows 上你也想要使用这样的功能，可以使用这个项目 with-env。\n另外，你也可以使用如下的两个 alias:\nSOCKS=\u0026#34;socks5://127.0.0.1:1085\u0026#34; alias proxy=\u0026#34;export http_proxy=${SOCKS} https_proxy=${SOCKS} all_proxy=${SOCKS}\u0026#34; alias unproxy=\u0026#39;unset all_proxy http_proxy https_proxy\u0026#39; 这样，你就可以在需要代理的时候输入 proxy，不需要的时候输入 unproxy。\n10.2 SSH 隧道 另外，我们可以使用 SSH Tunnel 来建立 SOCKS5 的代理（假设本地电脑无法访问，但是某台可以 SSH 的服务器能够访问外网，那么我们就可以使用如下的命令来建议翻墙代理：\nssh -D 1080 -qCN username@server:port 解释：\n-D：本机 SOCKS 服务端口 -q : quiet 模式，没有输出 -C : 数据压缩，可以节约一些带宽 -N : 不运行远程命令，只做端口转发 登录成功以后, 本地 1080端口会开启一个 SOCKS5 协议的代理，只要配置好代理就能使用这个端口上网。\nwith_proxy(){ HTTPS_PROXY=socks5://127.0.0.1:1080 HTTP_PROXY=socks5://127.0.0.1:1080 \u0026#34;$@\u0026#34; } 如果是浏览器，配置好SwitchyOmega插件也能实现上外网。\n欢迎补充和改善！\n（全文完）\n","date":"2022-09-15T00:00:00Z","permalink":"https://jen-jon.github.io/posts/20220915/","tags":"科学上网；飞越重洋","title":"科学上网","type":"technology"},{"contents":"译者序 本文翻译自 2020 年的一篇英文博客： How NAT traversal works。\n设想这样一个问题：在北京和上海各有一台局域网的机器（例如一台是家里的台式机，一 台是连接到星巴克 WiFi 的笔记本），二者都是私网 IP 地址，但可以访问公网， 如何让这两台机器通信呢？\n既然二者都能访问公网，那最简单的方式当然是在公网上架设一个中继服务器： 两台机器分别连接到中继服务，后者完成双向转发。这种方式显然有很大的性能开销，而 且中继服务器很容易成为瓶颈。\n有没有办法不用中继，让两台机器直接通信呢？\n如果有一定的网络和协议基础，就会明白这事儿是可能的。Tailscale 的这篇史诗级长文由浅入深地展示了这种 “可能”，如果完全实现本文所 介绍的技术，你将得到一个企业级的 NAT / 防火墙穿透工具。 此外，如作者所说，去中心化软件领域中的许多有趣想法，简化之后其实都变成了 跨过公网（互联网）实现端到端直连 这一问题，因此本文的意义并不仅限于 NAT 穿透本身。\n由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\n以下是译文。\n1.1 背景：IPv4 地址短缺，引入 NAT 1.2 需求：两台经过 NAT 的机器建立点对点连接 1.3 方案：NAT 穿透 1.3.1 两个必备前提：UDP + 能直接控制 socket 1.3.2 保底方式：中继 1.4 挑战：有状态防火墙和 NAT 设备 2.1 有状态防火墙 2.1.1 默认行为（策略） 2.1.2 如何区分入向和出向包 2.2 防火墙朝向（face-off）与穿透方案 2.2.1 防火墙朝向相同 场景特点：服务端 IP 可直接访问 穿透方案：客户端直连服务端，或 hub-and-spoke 拓扑 2.2.2 防火墙朝向不同 场景特点：服务端 IP 不可直接访问 穿透方案：两边同时主动建连，在本地防火墙为对方打开一个洞 2.3 关于穿透防火墙的一些思考 2.3.1 双向主动建连：旁路信道 2.3.2 非活跃连接被防火墙清理 2.3.3 问题都解决了？不，挑战刚刚开始 3.1 NAT 设备与有状态防火墙 3.2 NAT 穿透与 SNAT/DNAT 3.3 SNAT 的意义：解决 IPv4 地址短缺问题 3.4 SNAT 过程：以家用路由器为例 3.5 SNAT 给穿透带来的挑战 4.1 STUN 原理 4.2 为什么 NAT 穿透逻辑和主协议要共享同一个 socket 4.3 STUN 的问题：不能穿透所有 NAT 设备（例如企业级 NAT 网关） 4.4 重新审视 STUN 的前提 5.1 早期术语 5.2 近期研究与新术语 5.3 老的 cone 类型划分 5.4 针对 NAT 穿透场景：简化 NAT 分类 5.5 更多 NAT 规范（RFC） 6.1 问题回顾与保底方式（中继） 6.2 中继协议：TURN、DERP 6.3 小结 7.1 穿透 hard NAT：暴力端口扫描 7.2 基于生日悖论改进暴力扫描：hard side 多开端口 + easy side 随机探测 7.3 双 hard NAT 场景 7.4 控制端口映射（port mapping）过程：UPnP/NAT-PMP/PCP 协议 7.5 多 NAT 协商（Negotiating numerous NATs） 7.6 运营商级 NAT 带来的问题 新挑战：同一 CGNAT 侧直连，STUN 不可用 解决方案：如果端口映射协议能用：一端做端口映射 解决方案：如果端口映射协议不能用：NAT hairpin 模式 7.7 全 IPv6 网络：理想之地，但并非问题全无 全球 IPv4/IPv6 部署现状 新场景：NAT64/DNS64 解决方案：CLAT (Customer-side transLATor) 解决方案：CLAT 不存在时，手动穿透 NAT64 设备 7.8 将所有解决方式集成到 ICE 协议 针对具体场景，该选择哪种穿透方式？ ICE (Interactive Connectivity Establishment) 算法 健壮性与降级 7.9 安全 8.1 跨公网 端到端直连 8.2 结束语之 TL; DR 在前一篇文章 How Tailscale Works 中， 我们已经用较长篇幅介绍了 Tailscale 是如何工作的。但其中并没有详细描述我们是 如何穿透 NAT 设备，从而实现终端设备直连的 —— 不管这些终端之间 有什么设备（防火墙、NAT 等），以及有多少设备。本文试图补足这一内容。\n1.1 背景：IPv4 地址短缺，引入 NAT 全球 IPv4 地址早已不够用，因此人们发明了 NAT（网络地址转换）来缓解这个问题。\n简单来说，大部分机器都使用私有 IP 地址，如果它们需要访问公网服务，那么，\n出向流量：需要经过一台 NAT 设备，它会对流量进行 SNAT，将私有 srcIP+Port 转 换成 NAT 设备的公网 IP+Port（这样应答包才能回来），然后再将包发出去； 应答流量（入向）：到达 NAT 设备后进行相反的转换，然后再转发给客户端。 整个过程对双方透明。\n更多关于 NAT 的内容，可参考 (译) NAT - 网络地址转换（2016）。 译注。\n以上是本文所讨论问题的基本背景。\n1.2 需求：两台经过 NAT 的机器建立点对点连接 在以上所描述的 NAT 背景下，我们从最简单的问题开始：如何在两台经过 NAT 的机器之间建立 点对点连接（直连）。如下图所示：\n直接用机器的 IP 互连显然是不行的，因为它们都是私有 IP（例如 192.168.1.x）。 在 Tailscale 中，我们会建立一个 WireGuard® 隧道 来解决这个问题 —— 但这并不是太重要，因为我们将过去几代人努力都整合到了一个工具集， 这些技术广泛适用于各种场景。例如，\nWebRTC 使用这些技术在浏览器之间完成 peer-to-peer 语音、视频和数据传输， VoIP 电话和一些视频游戏也使用类似机制，虽然不是所有情况下都很成功。 接下来，本文将在一般意义上讨论这些技术，并在合适的地方拿 Tailscale 和其他一些东西作为例子。\n1.3 方案：NAT 穿透 1.3.1 两个必备前提：UDP + 能直接控制 socket 如果想设计自己的协议来实现 NAT 穿透，那必须满足以下两个条件：\n协议应该基于 UDP。\n理论上用 TCP 也能实现，但它会给本已相当复杂的问题再增加一层复杂性， 甚至还需要定制化内核 —— 取决于你想实现到什么程度。本文接下来都将关注在 UDP 上。\n如果考虑 TCP 是想在 NAT 穿透时获得面向流的连接（ stream-oriented connection），可以考虑用 QUIC 来替代，它构 建在 UDP 之上，因此我们能将关注点放在 UDP NAT 穿透，而仍然能获得一个 很好的流协议（stream protocol）。\n对收发包的 socket 有直接控制权。\n例如，从经验上来说，无法基于某个现有的网络库实现 NAT 穿透，因为我们 必须在使用的 “主要” 协议之外，发送和接收额外的数据包。\n某些协议（例如 WebRTC）将 NAT 穿透与其他部分紧密集成。但如果你在构建自己的协议， 建议将 NAT 穿透作为一个独立实体，与主协议并行运行，二者仅 仅是共享 socket 的关系，如下图所示，这将带来很大帮助：\n1.3.2 保底方式：中继 在某些场景中，直接访问 socket 这一条件可能很难满足。\n退而求其次的一个方式是设置一个 local proxy（本地代理），主协议与这个 proxy 通信 ，后者来完成 NAT 穿透，将包中继（relay）给对端。这种方式增加了一个额外的间接层 ，但好处是：\n仍然能获得 NAT 穿透， 不需要对已有的应用程序做任何改动。 1.4 挑战：有状态防火墙和 NAT 设备 有了以上铺垫，下面就从最基本的原则开始，一步步看如何实现一个企业级的 NAT 穿透方案。\n我们的目标是：在两个设备之间通过 UDP 实现双向通信， 有了这个基础，上层的其他协议（WireGuard, QUIC, WebRTC 等）就能做一些更酷的事情。\n但即便这个看似最基本的功能，在实现上也要解决两个障碍：\n有状态防火墙 NAT 设备 有状态防火墙是以上两个问题中相对比较容易解决的。实际上，大部分 NAT 设备都自带了一个有状态防火墙， 因此要解决第二个问题，必须先解决有第一个问题。\n有状态防火墙具体有很多种类型，有些你可能见过：\nWindows Defender firewall Ubuntu’s ufw (using iptables/nftables) BSD/macOS pf AWS Security Groups（安全组） 2.1 有状态防火墙 2.1.1 默认行为（策略） 以上防火墙的配置都是很灵活的，但大部分配置默认都是如下行为：\n允许所有出向连接（allows all “outbound” connections） 禁止所有入向连接（blocks all “inbound” connections） 可能有少量例外规则，例如 allowing inbound SSH。\n2.1.2 如何区分入向和出向包 连接（connection）和方向（direction）都是协议设计者头脑中的概念，到了 物理传输层，每个连接都是双向的；允许所有的包双向传输。 那防火墙是如何区分哪些是入向包、哪些是出向包的呢？ 这就要回到 **“有状态”（stateful）**这三个字了：有状态防火墙会记录它 看到的每个包，当收到下一个包时，会利用这些信息（状态）来判断应该做什么。\n对 UDP 来说，规则很简单：如果防火墙之前看到过一个出向包（outbound），就会允许 相应的入向包（inbound）通过，以下图为例：\n笔记本电脑中自带了一个防火墙，当该防火墙看到从这台机器出去的 2.2.2.2:1234 -\u0026gt; 5.5.5.5:5678 包时，就会记录一下：5.5.5.5:5678 -\u0026gt; 2.2.2.2:1234 入向包应该放行。 这里的逻辑是：我们信任的世界（即笔记本）想主动与 5.5.5.5:5678 通信，因此应该放行（allow）其回包路径。\n某些非常宽松的防火墙只要看到有从 2.2.2.2:1234 出去的包，就 会允许所有从外部进入 2.2.2.2:1234 的流量。这种防火墙对我们的 NAT 穿透来说非 常友好，但已经越来越少见了。\n2.2 防火墙朝向（face-off）与穿透方案 2.2.1 防火墙朝向相同 场景特点：服务端 IP 可直接访问 在 NAT 穿透场景中，以上默认规则对 UDP 流量的影响不大 —— 只要路径上所有防火墙的 “朝向” 是一样的。 一般来说，从内网访问公网上的某个服务器都属于这种情况。\n我们唯一的要求是：连接必须是由防火墙后面的机器发起的。这是因为 在它主动和别人通信之前，没人能主动和它通信，如下图所示：\n穿透方案：客户端直连服务端，或 hub-and-spoke 拓扑 但上图是假设了通信双方中，其中一端**（服务端）是能直接访问到的**。 在 VPN 场景中，这就形成了所谓的 hub-and-spoke 拓扑：中心的 hub 没有任何防火墙策略，谁都能访问到； 防火墙后面的 spokes 连接到 hub。如下图所示：\n2.2.2 防火墙朝向不同 场景特点：服务端 IP 不可直接访问 但如果两个 “客户端” 想直连，以上方式就不行了，此时两边的防火墙相向而立，如下图所示：\n根据前面的讨论，这种情况意味着：两边要同时发起连接请求，但也意味着 两边都无法发起有效请求，因为对方先发起请求才能在它的防火墙上打开一条缝让我们进去！ 如何破解这个问题呢？一种方式是让用户重新配置一边或两边的防火墙，打开一个端口， 允许对方的流量进来。\n这显然对用户不友好，在像 Tailscale 这样的 mesh 网络中的扩展性也不好，在 mesh 网络中，我们假设对端会以一定的粒度在公网上移动。 此外，在很多情况下用户也没有防火墙的控制权限：例如在咖啡馆或机场中，连接的路 由器是不受你控制的（否则你可能就有麻烦了）。 因此，我们需要寻找一种不用重新配置防火墙的方式。\n穿透方案：两边同时主动建连，在本地防火墙为对方打开一个洞 解决的思路还是先重新审视前面提到的有状态防火墙规则：\n对于 UDP，其规则（逻辑）是：包必须先出去才能进来（packets must flow out before packets can flow back in）。 注意，这里除了要满足包的 IP 和端口要匹配这一条件之外，并没有要求包必须是相关的（related）。 换句话说，只要某些包带着正确的源和目的地址出去了，任何看起来像是响应的包都会被防火墙放进来 —— 即使对端根本没收到你发出去的包。 因此，要穿透这些有状态防火墙，我们只需要共享一些信息：让两端提前知道对方使用的 ip:port：\n手动静态配置是一种方式，但显然扩展性不好； 我们开发了一个 coordination server， 以灵活、安全的方式来同步 ip:port 信息。 有了对方的 ip:port 信息之后，两端开始给对方发送 UDP 包。在这个过程中，我们预 料到某些包将会被丢弃。因此，双方必须要接受某些包会丢失的事实， 因此如果是重要信息，你必须自己准备好重传。对 UDP 来说丢包是可接受的，但这里尤其需要接受。\n来看一下具体建连（穿透）过程：\n如图所示，笔记本出去的第一包，2.2.2.2:1234 -\u0026gt; 7.7.7.7:5678，穿过 Windows Defender 防火墙进入到公网。\n对方的防火墙会将这个包拦截掉，因为它没有 7.7.7.7:5678 -\u0026gt; 2.2.2.2:1234 的流量记录。 但另一方面，Windows Defender 此时已经记录了出向连接，因此会允许 7.7.7.7:5678 -\u0026gt; 2.2.2.2:1234 的应答包进来。\n接着，第一个 7.7.7.7:5678 -\u0026gt; 2.2.2.2:1234 穿过它自己的防火墙到达公网。\n到达客户端侧时，Windows Defender 认为这是刚才出向包的应答包，因此就放行它进入了！ 此外，右侧的防火墙此时也记录了：2.2.2.2:1234 -\u0026gt; 7.7.7.7:5678 的包应该放行。\n笔记本收到服务器发来的包之后，发送一个包作为应答。这个包穿过 Windows Defender 防火墙 和服务端防火墙（因为这是对服务端发送的包的应答包），达到服务端。\n成功！这样我们就建立了一个穿透两个相向防火墙的双向通信连接。 而初看之下，这项任务似乎是不可能完成的。\n2.3 关于穿透防火墙的一些思考 穿透防火墙并非永远这么轻松，有时会受一些第三方系统的间接影响，需要仔细处理。 那穿透防火墙需要注意什么呢？重要的一点是：通信双方必须几乎同时发起通信， 这样才能在路径上的防火墙打开一条缝，而且两端还都是活着的。\n2.3.1 双向主动建连：旁路信道 如何实现 “同时” 呢？一种方式是两端不断重试，但显然这种方式很浪费资源。假如双方都 知道何时开始建连就好了。\n这听上去是鸡生蛋蛋生鸡的问题了：双方想要通信，必须先提前通个信。\n但实际上，我们可以通过旁路信道（side channel）来达到这个目的 ，并且这个旁路信道并不需要很 fancy：它可以有几秒钟的延迟、只需要传送几 KB 的 信息，因此即使是一个配置非常低的虚拟机，也能为几千台机器提供这样的旁路通信服务。\n在遥远的过去，我曾用 XMPP 聊天消息作为旁路，效果非常不错。 另一个例子是 WebRTC，它需要你提供一个自己的 “信令信道”（signalling channel， 这个词也暗示了 WebRTC 的 IP telephony ancestry），并将其配置到 WebRTC API。 在 Tailscale，我们的协调服务器（coordination server）和 DERP (Detour Encrypted Routing Protocol) 服务器集群是我们的旁路信道。 2.3.2 非活跃连接被防火墙清理 有状态防火墙内存通常比较有限，因此会定期清理不活跃的连接（UDP 常见的是 30s）， 因此要保持连接 alive 的话需要定期通信，否则就会被防火墙关闭，为避免这个问题， 我们，\n要么定期向对方发包来 keepalive， 要么有某种带外方式来按需重建连接。 2.3.3 问题都解决了？不，挑战刚刚开始 对于防火墙穿透来说， 我们并不需要关心路径上有几堵墙 —— 只要它们是有状态防火墙且允许出 向连接，这种同时发包（simultaneous transmission）机制就能穿透任意多层防火墙。 这一点对我们来说非常友好，因为只需要实现一个逻辑，然后能适用于任何地方了。\n… 对吗？\n其实，不完全对。这个机制有效的前提是：我们能提前知道对方的 ip:port。 而这就涉及到了我们今天的主题：NAT，它会使前面我们刚获得的一点满足感顿时消失。\n下面，进入本文正题。\n3.1 NAT 设备与有状态防火墙 可以认为 NAT 设备是一个增强版的有状态防火墙，虽然它的增强功能 对于本文场景来说并不受欢迎：除了前面提到的有状态拦截 / 放行功能之外，它们还会在数据包经过时修改这些包。\n3.2 NAT 穿透与 SNAT/DNAT 具体来说，NAT 设备能完成某种类型的网络地址转换，例如，替换源或目的 IP 地址或端口。\n讨论连接问题和 NAT 穿透问题时，我们只会受 source NAT —— SNAT 的影响。 DNAT 不会影响 NAT 穿透。 3.3 SNAT 的意义：解决 IPv4 地址短缺问题 SNAT 最常见的使用场景是将很多设备连接到公网，而只使用少数几个公网 IP。 例如对于消费级路由器，会将所有设备的（私有） IP 地址映射为单个连接到公网的 IP 地址。\n这种方式存在的意义是：我们有远多于可用公网 IP 数量的设备需要连接到公网，（至少 对 IPv4 来说如此，IPv6 的情况后面会讨论）。NAT 使多个设备能共享同一 IP 地址，因 此即使面临 IPv4 地址短缺的问题，我们仍然能不断扩张互联网的规模。\n3.4 SNAT 过程：以家用路由器为例 假设你的笔记本连接到家里的 WiFi，下面看一下它连接到公网某个服务器时的情形：\n笔记本发送 UDP packet 192.168.0.20:1234 -\u0026gt; 7.7.7.7:5678。\n这一步就好像笔记本有一个公网 IP 一样，但源地址 192.168.0.20 是私有地址， 只能出现在私有网络，公网不认，收到这样的包时它不知道如何应答。\n家用路由器出场，执行 SNAT。\n包经过路由器时，路由器发现这是一个它没有见过的新会话（session）。 它知道 192.168.0.20 是私有 IP，公网无法给这样的地址回包，但它有办法解决：\n在它自己的公网 IP 上挑一个可用的 UDP 端口，例如 2.2.2.2:4242， 然后创建一个 NAT mapping：192.168.0.20:1234 \u0026lt;--\u0026gt; 2.2.2.2:4242， 然后将包发到公网，此时源地址变成了 2.2.2.2:4242 而不是原来的 192.168.0.20:1234。因此服务端看到的是转换之后地址， 接下来，每个能匹配到这条映射规则的包，都会被路由器改写 IP 和 端口。 反向路径是类似的，路由器会执行相反的地址转换，将 2.2.2.2:4242 变回 192.168.0.20:1234。对于笔记本来说，它根本感知不知道这正反两次变换过程。\n这里是拿家用路由器作为例子，但办公网的原理是一样的。不同之处在 于，办公网的 NAT 可能有多台设备组成（高可用、容量等目的），而且它们有不止一个公 网 IP 地址可用，因此在选择可用的公网 ip:port 来做映射时，选择空间更大，能支持 更多客户端。\n3.5 SNAT 给穿透带来的挑战 现在我们遇到了与前面有状态防火墙类似的情况，但这次是 NAT 设备：通信双方 不知道对方的 ip:port 是什么，因此无法主动建连，如下图所示：\n但这次比有状态防火墙更糟糕，严格来说，在双方发包之前，根本无法确定（自己及对方的）ip:port 信息，因为 只有出向包经过路由器之后才会产生 NAT mapping（即，可以被对方连接的 ip:port 信息）。\n因此我们又回到了与防火墙遇到的问题，并且情况更糟糕：双方都需要主动和对 方建连，但又不知道对方的公网地址是多少，只有当对方先说话之后，我们才能拿到它的地址信息。\n如何破解以上死锁呢？这就轮到 STUN 登场了。\nSTUN 既是一些对 NAT 设备行为的详细研究，也是一种协助 NAT 穿透的协议。本文主要关注 STUN 协议。\n4.1 STUN 原理 STUN 基于一个简单的观察：从一个会被 NAT 的客户端访问公网服务器时， 服务器看到的是 NAT 设备的公网 ip:port 地址，而非该 客户端的局域网 ip:port 地址。\n也就是说，服务器能告诉客户端它看到的客户端的 ip:port 是什么。 因此，只要将这个信息以某种方式告诉通信对端（peer），后者就知道该和哪个地址建连了！ 这样就又简化为前面的防火墙穿透问题了。\n本质上这就是 STUN 协议的工作原理，如下图所示：\n笔记本向 STUN 服务器发送一个请求：“从你的角度看，我的地址什么？” STUN 服务器返回一个响应：“我看到你的 UDP 包是从这个地址来的：ip:port”。 The STUN protocol has a bunch more stuff in it — there’s a way of obfuscating the ip:port in the response to stop really broken NATs from mangling the packet’s payload, and a whole authentication mechanism that only really gets used by TURN and ICE, sibling protocols to STUN that we’ll talk about in a bit. We can ignore all of that stuff for address discovery.\n4.2 为什么 NAT 穿透逻辑和主协议要共享同一个 socket 理解了 STUN 原理，也就能理解为什么我们在文章开头说，如果 要实现自己的 NAT 穿透逻辑和主协议，就必须让二者共享同一个 socket：\n每个 socket 在 NAT 设备上都对应一个映射关系（私网地址 -\u0026gt; 公网地址）， STUN 服务器只是辅助穿透的基础设施， 与 STUN 服务器通信之后，在 NAT 及防火墙设备上打开了一个连接，允许入向包进来（回忆前面内容， 只要目的地址对，UDP 包就能进来，不管这些包是不是从 STUN 服务器来的）， 因此，接下来只要将这个地址告诉我们的通信对端（peer），让它往这个地址发包，就能实现穿透了。 4.3 STUN 的问题：不能穿透所有 NAT 设备（例如企业级 NAT 网关） 有了 STUN，我们的穿透目的似乎已经实现了：每台机器都通过 STUN 来获取自己的私网 socket 对应的公网 ip:port，然后把这个信息告诉对端，然后两端 同时发起穿透防火墙的尝试，后面的过程就和上一节介绍的防火墙穿透一样了，对吗？\n答案是：看情况。某些情况下确实如此，但有些情况下却不行。通常来说，\n对于大部分家用路由器场景，这种方式是没问题的； 但对于一些企业级 NAT 网关来说，这种方式无法奏效。 NAT 设备的说明书上越强调它的安全性，STUN 方式失败的可能性就越高。（但注意，从实际意义上来说， NAT 设备在任何方面都并不会增强网络的安全性，但这不是本文重点，因此不展开。）\n4.4 重新审视 STUN 的前提 再次审视前面关于 STUN 的假设：当 STUN 服务器告诉客户端在公网看来它的地址是 2.2.2.2:4242 时，那所有目的地址是 2.2.2.2:4242 的包就都能穿透防火墙到达该客户端。\n这也正是问题所在：这一点并不总是成立。\n某些 NAT 设备的行为与我们假设的一致，它们的有状态防火墙组件只要看到有客户端自己 发起的出向包，就会允许相应的入向包进入；因此只要利用 STUN 功能，再加上两端同时 发起防火墙穿透，就能把连接打通；\nin theory, there are also NAT devices that are super relaxed, and don’t ship with stateful firewall stuff at all. In those, you don’t even need simultaneous transmission, the STUN request gives you an internet ip:port that anyone can connect to with no further ceremony. If such devices do still exist, they’re increasingly rare.\n另外一些 NAT 设备就要困难很多了，它会针对每个目的地址来生成一条相应的映射关系。 在这样的设备上，如果我们用相同的 socket 来分别发送数据包到 5.5.5.5:1234 and 7.7.7.7:2345，我们就会得到 2.2.2.2 上的两个不同的端口，每个目的地址对应一个。 如果反向包的端口用的不对，包就无法通过防火墙。如下图所示：\n知道 NAT 设备的行为并不是完全一样之后，我们来引入一些正式术语。\n5.1 早期术语 如果之前接触过 NAT 穿透，可能会听说过下面这些名词：\n“Full Cone” “Restricted Cone” “Port-Restricted Cone” “Symmetric” NATs 这些都是 NAT 穿透领域的早期术语。\n但其实这些术语相当让人困惑。我每次都要 查一下 Restricted Cone NAT 是什么意思。从实际经验来看，我并不是唯一对此感到困惑的人。 例如，如今互联网上将 “easy” NAT 归类为 Full Cone，而实际上它们更应该归类为 Port-Restricted Cone。\n5.2 近期研究与新术语 最近的一些研究和 RFC 已经提出了一些更准确的术语。\n首先，它们明确了如下事实：NAT 设备的行为差异表现在多个维度， 而并非只有早期研究中所说的 “cone” 这一个维度，因此基于 “cone” 来划分类别并不是很有帮助。 其次，新研究和新术语能更准确地描述 NAT 在做什么。 前面提到的所谓 \u0026ldquo;easy\u0026rdquo; 和 \u0026ldquo;hard\u0026rdquo; NAT，只在一个维度有不同：NAT 映射是否考虑到目的地址信息。 RFC 4787 中，\n将 easy NAT 及其变种称为 “Endpoint-Independent Mapping” (EIM，终点无关的映射)\n但是，从 “命名很难” 这一程序员界的伟大传统来说，EIM 这个词其实 也并不是 100% 准确，因为这种 NAT 仍然依赖 endpoint，只不过依赖的是源 endpoint：每个 source ip:port 对应一个映射 —— 否则你的包就会和别人的包混在一起，导致混乱。\n严格来说，EIM 应该称为 “Destination Endpoint Independent Mapping” (DEIM?)， 但这个名字太拗口了，而且按照惯例，Endpoint 永远指的是 Destination Endpoint。\n将 hard NAT 以及变种称为 “Endpoint-Dependent Mapping”（EDM，终点相关的映射） 。\nEDM 中还有一个子类型，依据是只根据 dst_ip 做映射，还是根据 dst_ip + dst_port 做映射。 对于 NAT 穿透来说，这种区分对来说是一样的：它们都会导致 STUN 方式不可用。\n5.3 老的 cone 类型划分 你可能会有疑问：根据是否依赖 endpoint 这一条件，只能组合出两种可能，那为什么传 统分类中会有四种 cone 类型呢？答案是 cone 包含了两个正交维度的 NAT 行为：\nNAT 映射行为：前面已经介绍过了， 有状态防火墙行为：与前者类似，也是分为与 endpoint 相关还是无关两种类型。 因此最终组合如下：\nNAT Cone Types\nEndpoint 无关 NAT mappingEndpoint 相关 NAT mapping (all types)Endpoint 无关防火墙Full Cone NATN/A*Endpoint 相关防火墙 (dst. IP only)Restricted Cone NATN/A*Endpoint 相关防火墙 (dst. IP+port)Port-Restricted Cone NATSymmetric NAT 分解到这种程度之后就可以看出，cone 类型对 NAT 穿透场景来说并没有什么意义。 我们关心的只有一点：是否是 Symmetric —— 换句话说，一个 NAT 设备是 EIM 还是 EDM 类型的。\n5.4 针对 NAT 穿透场景：简化 NAT 分类 以上讨论可知，虽然理解防火墙的具体行为很重要，但对于编写 NAT 穿透代码来说，这一点并不重要。 我们的两端同时发包方式（simultaneous transmission trick）能 有效穿透以上三种类型的防火墙。在真实场景中， 我们主要在处理的是 IP-and-port endpoint-dependent 防火墙。\n因此，对于实际 NAT 穿透实现，我们可以将以上分类简化成：\nEndpoint-Independent NAT mappingEndpoint-Dependent NAT mapping (dst. IP only)Firewall is yesEasy NATHard NAT 5.5 更多 NAT 规范（RFC） 想了解更多新的 NAT 术语，可参考\nRFC 4787 (NAT Behavioral Requirements for UDP) RFC 5382 (for TCP) RFC 5508 (for ICMP) 如果自己实现 NAT，那应该（should）遵循这些 RFC 的规范，这样才能使你的 NAT 行为符合业界惯例，与其他厂商的设备或软件良好兼容。\n6.1 问题回顾与保底方式（中继） 补完基础知识（尤其是定义了什么是 hard NAT）之后，回到我们的 NAT 穿透主题。\n第 1~4 节已经解决了 STUN 和防火墙穿透的问题， 但 hard NAT 对我们来说是个大问题，只要路径上出现一个这种设备，前面的方案就行不通了。 准备放弃了吗？ 这才进入 NAT 真正有挑战的部分：如果已经试过了前面介绍的所有方式 仍然不能穿透，我们该怎么办呢？\n实际上，确实有很多 NAT 实现在这种情况下都会选择放弃，向用户报一个 “无法连接” 之类的错误。 但对我们来说，这么快就放弃显然是不可接受的 —— 解决不了连通性问题，Tailscale 就没有存在的意义。 我们的保底解决方式是：创建一个中继连接（relay）实现双方的无障碍地通信。 但是，中继方式性能不是很差吗？这要看具体情况：\n如果能直连，那显然没必要用中继方式； 但如果无法直连，而中继路径又非常接近双方直连的真实路径，并且带宽足够大，那中 继方式并不会明显降低通信质量。延迟肯定会增加一点，带宽会占用一些，但 相比完全连接不上，还是更能让用户接受的。 不过要注意：我们只有在无法直连时才会选择中继方式。实际场景中，\n对于大部分网络，我们都能通过前面介绍的方式实现直连， 剩下的 Tailscale 用中继方式来解决，并不算一个很糟的方式。 此外，某些网络会阻止 NAT 穿透，其影响比这种 hard NAT 大多了。例如，我们观察到 UC Berkeley guest WiFi 禁止除 DNS 流量之外的所有 outbound UDP 流量。 不管用什么 NAT 黑科技，都无法绕过这个拦截。因此我们终归还是需要一些可靠的 fallback 机制。\n6.2 中继协议：TURN、DERP 有多种中继实现方式。\nTURN (Traversal Using Relays around NAT)：经典方式，核心理念是\n用户（人）先去公网上的 TURN 服务器认证，成功后后者会告诉你：“我已经为你分配了 ip:port，接下来将为你中继流量”， 然后将这个 ip:port 地址告诉对方，让它去连接这个地址，接下去就是非常简单的客户端 / 服务器通信模型了。 Tailscale 并不使用 TURN。这种协议用起来并不是很好，而且与 STUN 不同， 它没有真正的交互性，因为互联网上并没有公开的 TURN 服务器。\nDERP (Detoured Encrypted Routing Protocol)\n这是我们创建的一个协议，DERP，\n它是一个通用目的包中继协议，运行在 HTTP 之上，而大部分网络都是允许 HTTP 通信的。 它根据目的公钥（destination’s public key）来中继加密的流量（encrypted payloads）。 前面也简单提到过，DERP 既是我们在 NAT 穿透失败时的保底通信方式（此时的角色 与 TURN 类似），也是在其他一些场景下帮助我们完成 NAT 穿透的旁路信道。 换句话说，它既是我们的保底方式，也是有更好的穿透链路时，帮助我们进行连接升 级（upgrade to a peer-to-peer connection）的基础设施。\n6.3 小结 有了 “中继” 这种保底方式之后，我们穿透的成功率大大增加了。 如果此时不再阅读本文接下来的内容，而是把上面介绍的穿透方式都实现了，我预计：\n90% 的情况下，你都能实现直连穿透； 剩下的 10% 里，用中继方式能穿透一些（some）； 这已经算是一个 “足够好” 的穿透实现了。\n如果你并不满足于 “足够好”，那我们可以做的事情还有很多！\n本节将介绍一些五花八门的 tricks，在某些特殊场景下会帮到我们。单独使用这项技术都 无法解决 NAT 穿透问题，但将它们巧妙地组合起来，我们能更加接近 100% 的穿透成功率。\n7.1 穿透 hard NAT：暴力端口扫描 回忆 hard NAT 中遇到的问题，如下图所示，关键问题是：easy NAT 不知道该往 hard NAT 方的哪个 ip:port 发包。\n但必须要往正确的 ip:port 发包，才能穿透防火墙，实现双向互通。 怎么办呢？\n首先，我们能知道 hard NAT 的一些 ip:port，因为我们有 STUN 服务器。\n这里先假设我们获得的这些 IP 地址都是正确的（这一点并不总是成立，但这里先这么假 设。而实际上，大部分情况下这一点都是成立的，如果对此有兴趣，可以参考 REQ-2 in RFC 4787）。\nIP 地址确定了，剩下的就是端口了。总共有 65535 中可能，我们能遍历这个端口范围吗？\n如果发包速度是 100 packets/s，那最坏情况下，需要 10 分钟来找到正确的端口。 还是那句话，这虽然不是最优的，但总比连不上好。\n这很像是端口扫描（事实上，确实是），实际中可能会触发对方的网络入侵检测软件。\n7.2 基于生日悖论改进暴力扫描：hard side 多开端口 + easy side 随机探测 利用 birthday paradox 算法， 我们能对端口扫描进行改进。\n上一节的基本前提是：hard side 只打开一个端口，然后 easy side 暴力扫描 65535 个端口来寻找这个端口； 这里的改进是：在 hard size 开多个端口，例如 256 个（即同时打开 256 个 socket，目的地址都是 easy side 的 ip:port）， 然后 easy side 随机探测这边的端口。 这里省去算法的数学模型，如果你对实现干兴趣，可以看看我写的 python calculator。 计算过程是 “经典” 生日悖论的一个小变种。 下面是随着 easy side random probe 次数（假设 hard size 256 个端口）的变化，两边打开的端口有重合（即通信成功）的概率：\n随机探测次数成功概率17450%25664%102498%204899.9% 根据以上结果，如果还是假设 100 ports/s 这样相当温和的探测速率，那 2 秒钟就有约 50% 的成功概率。 即使非常不走运，我们仍然能在 20s 时几乎 100% 穿透成功，而此时只探测了总端口空间的 4%。\n非常好！虽然这种 hard NAT 给我们带来了严重的穿透延迟，但最终结果仍然是成功的。 那么，如果是两个 hard NAT，我们还能处理吗？\n7.3 双 hard NAT 场景 这种情况下仍然可以用前面的 多端口 + 随机探测 方式，但成功概率要低很多了：\n每次通过一台 hard NAT 去探测对方的端口（目的端口）时，我们自己同时也生成了一个随机源端口， 这意味着我们的搜索空间变成了二维 {src port, dst port} 对，而不再是之前的一维 dst port 空间。 这里我们也不就具体计算展开，只告诉结果：仍然假设目的端打开 256 个端口，从源端发起 2048 次（20 秒）， 成功的概率是：0.01%。\n如果你之前学过生日悖论，就并不会对这个结果感到惊讶。理论上来说，\n要达到 99.9% 的成功率，我们需要两边各进行 170,000 次探测 —— 如果还是以 100 packets/sec 的速度，就需要 28 分钟。 要达到 50% 的成功率，“只” 需要 54,000 packets，也就是 9 分钟。 如果不使用生日悖论方式，而且暴力穷举，需要 1.2 年时间！ 对于某些应用来说，28 分钟可能仍然是一个可接受的时间。用半个小时暴力穿透 NAT 之后， 这个连接就可以一直用着 —— 除非 NAT 设备重启，那样就需要再次花半个小时穿透建个新连接。但对于 交互式应用来说，这样显然是不可接受的。\n更糟糕的是，如果去看常见的办公网路由器，你会震惊于它的 active session low limit 有多么低。 例如，一台 Juniper SRX 300 最多支持 64,000 active sessions。 也就是说，\n如果我们想创建一个成功的穿透连接，就会把它的整张 session 表打爆 （因为我们要暴力探测 65535 个端口，每次探测都是一条新连接记录）！ 这显然要求这台路由器能从容优雅地处理过载的情况。 这只是创建一条连接带来的影响！如果 20 台机器同时对这台路由器发起穿透呢？绝对的灾难！ 至此，我们通过这种方式穿透了比之前更难一些的网络拓扑。这是一个很大的成就，因为 家用路由器一般都是 easy NAT，hard NAT 一般都是办公网路由器或云 NAT 网关。 这意味着这种方式能帮我们解决\nhome-to-office（家 -\u0026gt; 办公室） home-to-cloud （家 -\u0026gt; 云） 的场景，以及一部分\noffice-to-cloud （办公室 -\u0026gt; 云） cloud-to-cloud （云 -\u0026gt; 办公室） 场景。\n7.4 控制端口映射（port mapping）过程：UPnP/NAT-PMP/PCP 协议 如果我们能让 NAT 设备的行为简单点，不要把事情搞这么复杂，那建 立连接（穿透）就会简单很多。真有这样的好事吗？还真有，有专门的一种协议叫 端口映射协议（port mapping protocols）。通过这种协议禁用掉前面 遇到的那些乱七八糟的东西之后，我们将得到一个非常简单的 “请求 - 响应”。\n下面是三个具体的端口映射协议：\nUPnP IGD (Universal Plug’n’Play Internet Gateway Device)\n最老的端口控制协议， 诞生于 1990s 晚期，因此使用了很多上世纪 90 年代的技术 （XML、SOAP、multicast HTTP over UDP —— 对，HTTP over UDP ），而且很难准确和安全地实现这个协议。但以前很多路由器都内置了 UPnP 协议， 现在仍然很多。\n请求和响应：\n“你好，请将我的 lan-ip:port 转发到公网（WAN）”， “好的，我已经为你分配了一个公网映射 wan-ip:port ”。 NAT-PMP\nUPnP IGD 出来几年之后，Apple 推出了一个功能类似的协议，名为 NAT-PMP (NAT Port Mapping Protocol)。\n但与 UPnP 不同，这个协议只做端口转发，不管是在客户端还是服务端，实现起来都非常简单。\nPCP\n稍后一点，又出现了 NAT-PMP v2 版，并起了个新名字 PCP (Port Control Protocol)。\n因此要更好地实现穿透，可以\n先判断本地的默认网关上是否启用了 UPnP IGD, NAT-PMP and PCP，\n如果探测发现其中任何一种协议有响应，我们就申请一个公网端口映射，\n可以将这理解为一个加强版 STUN：我们不仅能发现自己的公网 ip:port，而且能指示我们的 NAT 设备对我们的通信对端友好一些 —— 但并不是为这个端口修改或添加防火墙规则。\n接下来，任何到达我们 NAT 设备的、地址是我们申请的端口的包，都会被设备转发到我们。\n但我们不能假设这个协议一定可用：\n本地 NAT 设备可能不支持这个协议；\n设备支持但默认禁用了，或者没人知道还有这么个功能，因此从来没开过；\n安全策略要求关闭这个特性。\n这一点非常常见，因为 UPnP 协议曾曝出一些高危漏洞（后面都修复了，因此如果是较新的设备，可以安全地使用 UPnP —— 如果实现没问题）。 不幸的是，某些设备的配置中，UPnP, NAT-PMP，PCP 是放在一个开关里的（可能 统称为 “UPnP” 功能），一开全开，一关全关。因此如果有人担心 UPnP 的安全性，他连另 外两个也用不了。\n最后，终归来说，只要这种协议可用，就能有效地减少一次 NAT，大大方便建连过程。 但接下来看一些不常见的场景。\n7.5 多 NAT 协商（Negotiating numerous NATs） 目前为止，我们看到的客户端和服务端都各只有一个 NAT 设备。如果有多个 NAT 设备会 怎么样？例如下面这种拓扑：\n这个例子比较简单，不会给穿透带来太大问题。包从客户端 A 经过多次 NAT 到达公网的过程，与前面分析的穿过多层有状态防火墙是一样的：\n额外的这层（NAT 设备）对客户端和服务端来说都不可见，我们的穿 透技术也不关心中间到底经过了多少层设备。 真正有影响的其实只是最后一层设备，因为对端需要在这一层设备上 找到入口让包进来。 具体来说，真正有影响的是端口转发协议。\n客户端使用这种协议分配端口时，为我们分配端口的是最靠近客户端的这层 NAT 设备； 而我们期望的是让最离客户端最远的那层 NAT 来分配，否则我们得到的就是一个网络中间层分配的 ip:port，对端是用不了的； 不幸的是，这几种协议都不能递归地告诉我们下一层 NAT 设备是多少 —— 虽然可以用 traceroute 之类的工具来探测网络路径，再加上 猜路上的设备是不是 NAT 设备（尝试发送 NAT 请求） —— 但这个就看运气了。 这就是为什么互联网上充斥着大量的文章说 double-NAT 有多糟糕，以 及警告用户为保持后向兼容不要使用 double-NAT。但实际上，double-NAT 对于绝大部分 互联网应用来说都是不可见的（透明的），因为大部分应用并不需要主动地做这种 NAT 穿 透。\n但我也绝不是在建议你在自己的网络中设置 double-NAT。\n破坏了端口映射协议之后，某些视频游戏的多人（multiplayer）模式就会无法使用， 也可能会使你的 IPv6 网络无法派上用场，后者是不用 NAT 就能双向直连的一个好方案。 但如果 double-NAT 并不是你能控制的，那除了不能用到这种端口映射协议之外，其他大部分东西都是不受影响的。\ndouble-NAT 的故事到这里就结束了吗？—— 并没有，而且更大型的 double-NAT 场景将展现在我们面前。\n7.6 运营商级 NAT 带来的问题 即使用 NAT 来解决 IPv4 地址不够的问题，地址仍然是不够用的，ISP（互联网服务提供商） 显然 无法为每个家庭都分配一个公网 IP 地址。那怎么解决这个问题呢？ISP 的做法是不够了就再嵌套一层 NAT：\n家用路由器将你的客户端 SNAT 到一个 “intermediate” IP 然后发送到运营商网络， ISP’s network 中的 NAT 设备再将这些 intermediate IPs 映射到少量的公网 IP。 后面这种 NAT 就称为 “运营商级 NAT”（carrier-grade NAT，或称电信级 NAT），缩写 CGNAT。如下图所示：\nCGNAT 对 NAT 穿透来说是一个大麻烦。\n在此之前，办公网用户要快速实现 NAT 穿透，只需在他们的路由器上手动设置端口映射就行了。 但有了 CGNAT 之后就不管用了，因为你无法控制运营商的 CGNAT！ 好消息是：这其实是 double-NAT 的一个小变种，因此前面介绍的解决方式大部分还仍然是适用的。 某些东西可能会无法按预期工作，但只要肯给 ISP 交钱，这些也都能解决。 除了 port mapping protocols，其他我们已经介绍的所有东西在 CGNAT 里都是适用的。\n新挑战：同一 CGNAT 侧直连，STUN 不可用 但我们确实遇到了一个新挑战：如何直连两个在同一 CGNAT 但不同家用路由器中的对端呢？如下图所示：\n在这种情况下，STUN 就无法正常工作了：STUN 看到的是客户端在公网（CGNAT 后面）看到的地址， 而我们想获得的是在 “middle network” 中的 ip:port，这才是对端真正需要的地址，\n解决方案：如果端口映射协议能用：一端做端口映射 怎么办呢？\n如果你想到了端口映射协议，那恭喜，答对了！如果 peer 中任何一个 NAT 支持端口映射协议， 对我们就能实现穿透，因为它分配的 ip:port 正是对端所需要的信息。\n这里讽刺的是：double-NAT（指 CGNAT）破坏了端口映射协议，但在这里又救了我们！ 当然，我们假设这些协议一定可用，因为 CGNAT ISP 倾向于在它们的家用路由器侧关闭 这些功能，已避免软件得到 “错误的” 结果，产生混淆。\n解决方案：如果端口映射协议不能用：NAT hairpin 模式 如果不走运，NAT 上没有端口映射功能怎么办？\n让我们回到基于 STUN 的技术，看会发生什么。两端在 CGNAT 的同一侧，假设 STUN 告诉我们 A 的地址是 2.2.2.2:1234，B 的地址是 2.2.2.2:5678。\n那么接下来的问题是：如果 A 向 2.2.2.2:5678 发包会怎么样？期望的 CGNAT 行为是：\n执行 A 的 NAT 映射规则，即对 2.2.2.2:1234 -\u0026gt; 2.2.2.2:5678 进行 SNAT。 注意到目的地址 2.2.2.2:5678 匹配到的是 B 的入向 NAT 映射，因此接着对这个包执行 DNAT，将目的 IP 改成 B 的私有地址。 通过 CGNAT 的 internal 接口（而不是 public 接口，对应公网）将包发给 B。 这种 NAT 行为有个专门的术语，叫 hairpinning（直译为发卡，意思 是像发卡一样，沿着一边上去，然后从另一边绕回来），\n大家应该猜到的一个事实是：不是所以 NAT 都支持 hairpin 模式。 实际上，大量 well-behaved NAT 设备都不支持 hairpin 模式，\n因为它们都有 “只有 src_ip 是私有地址且 dst_ip 是公网地址的包才会经过我” 之类的假设。 因此对于这种目的地址不是公网、需要让路由器把包再转回内网的包，它们会直接丢弃。 这些逻辑甚至是直接实现在路由芯片中的，因此除非升级硬件，否则单靠软件编程无法改变这种行为。 Hairpin 是所有 NAT 设备的特性（支持或不支持），并不是 CGNAT 独有的。\n在大部分情况下，这个特性对我们的 NAT 穿透目的来说都是无所谓的，因为我们期望中 两个 LAN NAT 设备会直接通信，不会再向上绕到它们的默认网关 CGNAT 来解决这个问题。\nHairpin 特性可有可无这件事有点遗憾，这可能也是为什么 hairpin 功能经常 broken 的原因。\n一旦必须涉及到 CGNAT，那 hairpinning 对连接性来说就至关重要了。\nHairpinning 使内网连接的行为与公网连接的行为完成一致，因此我们无需关心目的 地址类型，也不用知晓自己是否在一台 CGNAT 后面。\n如果 hairpinning 和 port mapping protocols 都不可用，那只能降级到中继模式了。\n7.7 全 IPv6 网络：理想之地，但并非问题全无 行文至此，一些读者可能已经对着屏幕咆哮：不要再用 IPv4 了！ 花这么多时间精力解决这些没意义的东西，还不如直接换成 IPv6！\n的确，之所以有这些乱七八糟的东西，就是因为 IPv4 地址不够了，我们一直在用越来越复杂的 NAT 来给 IPv4 续命。 如果 IP 地址够用，无需 NAT 就能让世界上的每个设备都有一个自己的公网 IP 地址，这些问题不就解决了吗？ 简单来说，是的，这也正是 IPv6 能做的事情。但是，也只说对了一半：在理想的全 IPv6 世界中，所有这些东西会变得更加简单，但我们面临的问题并不会完全消失 —— 因为有状态防火墙仍然还是存在的。\n办公室中的电脑可能有一个公网 IPv6 地址，但你们公司肯定会架设一个防火墙，只允许 你的电脑主动访问公网，而不允许反向主动建连。 其他设备上的防火墙也仍然存在，应用类似的规则。 因此，我们仍然会用到\n本文最开始介绍的防火墙穿透技术，以及 帮助我们获取自己的公网 ip:port 信息的旁路信道 仍然需要在某些场景下 fallback 到中继模式，例如 fallback 到最通用的 HTTP 中继 协议，以绕过某些网络禁止 outbound UDP 的问题。 但我们现在可以抛弃 STUN、生日悖论、端口映射协议、hairpin 等等东西了。 这是一个好消息！\n全球 IPv4/IPv6 部署现状 另一个更加严峻的现实问题是：当前并不是一个全 IPv6 世界。目前世界上\n大部分还是 IPv4， 大约 33% 是 IPv6，而且分布极度不均匀，因此某些 通信对所在的可能是 100% IPv6，也可能是 0%，或二者之间。 不幸的是，这意味着，IPv6 ** 还 ** 无法作为我们的解决方案。 就目前来说，它只是我们的工具箱中的一个备选。对于某些 peer 来说，它简直是完美工 具，但对其他 peer 来说，它是用不了的。如果目标是 “任何情况下都能穿透（连接） 成功”，那我们就仍然需要 IPv4+NAT 那些东西。\n新场景：NAT64/DNS64 IPv4/IPv6 共存也引出了一个新的场景：NAT64 设备。\n前面介绍的都是 NAT44 设备：它们将一个 IPv4 地址转换成另一 IPv4 地址。 NAT64 从名字可以看出，是将一个内侧 IPv6 地址转换成一个外侧 IPv4 地址。 利用 DNS64 设备，我们能将 IPv4 DNS 应答给 IPv6 网络，这样对终端来说，它看到的就是一个 全 IPv6 网络，而仍然能访问 IPv4 公网。\nIncidentally, you can extend this naming scheme indefinitely. There have been some experiments with NAT46; you could deploy NAT66 if you enjoy chaos; and some RFCs use NAT444 for carrier-grade NAT.\n如果需要处理 DNS 问题，那这种方式工作良好。例如，如果连接到 google.com，将这个域名解析成 IP 地址的过程会涉及到 DNS64 设备，它又会进一步 involve NAT64 设备，但后一步对用户来说是无感知的。\n但对于 NAT 和防火墙穿透来说，我们会关心每个具体的 IP 地址和端口。\n解决方案：CLAT (Customer-side transLATor) 如果设备支持 CLAT (Customer-side translator — from Customer XLAT)，那我们就很幸运：\nCLAT 假装操作系统有直接 IPv4 连接，而背后使用的是 NAT64，以对应用程序无感知。 在有 CLAT 的设备上，我们无需做任何特殊的事情。 CLAT 在移动设备上非常常见，但在桌面电脑、笔记本和服务器上非常少见， 因此在后者上，必须自己做 CLAT 做的事情：检测 NAT64+DNS64 的存在，然后正确地使用它们。 解决方案：CLAT 不存在时，手动穿透 NAT64 设备 首先检测是否存在 NAT64+DNS64。\n方法很简单：向 ipv4only.arpa. 发送一个 DNS 请求。这个域名会解析 到一个已知的、固定的 IPv4 地址，而且是纯 IPv4 地址。如果得到的 是一个 IPv6 地址，就可以判断有 DNS64 服务器做了转换，而它必然会用到 NAT64。这样 就能判断出 NAT64 的前缀是多少。\n此后，要向 IPv4 地址发包时，发送格式为{NAT64 prefix + IPv4 address} 的 IPv6 包。 类似地，收到来源格式为 {NAT64 prefix + IPv4 address} 的包时，就是 IPv4 流量。\n接下来，通过 NAT64 网络与 STUN 通信来获取自己在 NAT64 上的公网 ip:port，接 下来就回到经典的 NAT 穿透问题了 —— 除了需要多做一点点事情。\n幸运的是，如今的大部分 v6-only 网络都是移动运营商网络，而几乎所有手机都支持 CLAT。 运营 v6-only 网络的 ISPs 会在他们给你的路由器上部署 CLAT，因此最后你其实不需要做什么事情。 但如果想实现 100% 穿透，就需要解决这种边边角角的问题，即必须显式支持从 v6-only 网络连接 v4-only 对端。\n7.8 将所有解决方式集成到 ICE 协议 针对具体场景，该选择哪种穿透方式？ 至此，我们的 NAT 穿透之旅终于快结束了。我们已经覆盖了有状态防火墙、简单和高级 NAT、IPv4 和 IPv6。只要将以上解决方式都实现了，NAT 穿透的目的就达到了！\n但是，\n对于给定的 peer，如何判断改用哪种方式呢？ 如何判断这是一个简单有状态防火墙的场景，还是该用到生日悖论算法，还是需要手动处理 NAT64 呢？ 还是通信双方在一个 WiFi 网络下，连防火墙都没有，因此不需要任何操作呢？ 早期 NAT 穿透比较简单，能让我们精确判断出 peer 之间的路径特点，然后针对性地采用相应的解决方式。 但后面，网络工程师和 NAT 设备开发工程师引入了一些新理念，给路径判断造成很大困难。因此 我们需要简化客户端侧的思考（判断逻辑）。\n这就要提到 Interactive Connectivity Establishment (ICE，交换式连接建立) 协议了。 与 STUN/TURN 类似，ICE 来自电信领域，因此其 RFC 充满了 SIP、SDP、信令会话、拨号等等电话术语。 但如果忽略这些领域术语，我们会看到它描述了一个极其优雅的判断最佳连接路径的算法。\n真的？这个算法是：每种方法都试一遍，然后选择最佳的那个方法。就是这个算法，惊喜吗？\n来更深入地看一下这个算法。\nICE (Interactive Connectivity Establishment) 算法 这里的讨论不会严格遵循 ICE spec，因此如果是在自己实现一个可互操作的 ICE 客户端，应该通读 RFC 8445, 根据它的描述来实现。这里忽略所有电信术语，只关注核心的算法逻辑， 并提供几个在 ICE 规范允许范围的灵活建议。\n为实现和某个 peer 的通信，首先需要确定我们自己用的（客户端侧）这个 socket 的地址， 这是一个列表，至少应该包括：\n我们自己的 IPv6 ip:ports 我们自己的 IPv4 LAN ip:ports（局域网地址） 通过 STUN 服务器获取到的我们自己的 IPv4 WAN ip:ports（公网地址，可能会经过 NAT64 转换） 通过端口映射协议获取到的我们自己的 IPv4 WAN ip:port（NAT 设备的端口映射协议分配的公网地址） 运营商提供给我们的 endpoints（例如，静态配置的端口转发） 通过旁路信道与 peer 互换这个列表。两边都拿到对方的列表后，就开始互相探测对方提供的地址。 列表中地址没有优先级，也就是说，如果对方给的了 15 个地址，那我们应该把这 15 个地址都探测一遍。\n这些探测包有两个目的：\n打开防火墙，穿透 NAT，也就是本文一直在介绍的内容； 健康检测。我们在不断交换（最好是已认证的）“ping/pong” 包，来检测某个特定的路径是不是端到端通的。 最后，一小会儿之后，从可用的备选地址中（根据某些条件）选择 “最佳” 的那个，任务完成！\n这个算法的优美之处在于：只要选择最佳线路（地址）的算法是正确的，那就总能获得最佳路径。\nICE 会预先对这些备选地址进行排序（通常：LAN \u0026gt; WAN \u0026gt; WAN+NAT），但用户也可以自己指定这个排序行为。 从 v0.100.0 开始，Tailscale 从原来的 hardcode 优先级切换成了根据 round-trip latency 的方式，它大部分情况下排序的结果和 LAN \u0026gt; WAN \u0026gt; WAN+NAT 是一致的。 但相比于静态排序，我们是动态计算每条路径应该属于哪个类别。 ICE spec 将协议组织为两个阶段：\n探测阶段 通信阶段 但不一定要严格遵循这两个步骤的顺序。在 Tailscale，\n我们发现更优的路径之后就会自动切换过去， 所有的连接都是先选择 DERP 模式（中继模式）。这意味着连接立即就能建立（优先级最低但 100% 能成功的模式），用户不用任何等待， 然后并行进行路径发现。通常几秒钟之后，我们就能发现一条更优路径，然后将现有连接透明升级（upgrade）过去。 但有一点需要关心：非对称路径。ICE 花了一些精力来保证通信双方选择的是相同的网络 路径，这样才能保证这条路径上有双向流量，能保持防火墙和 NAT 设备的连接一直处于 open 状态。 自己实现的话，其实并不需要花同样大的精力来实现这个保证，但需要确保你所有使用的所有路径上，都有双向流量。 这个目标就很简单了，只需要定期在所有已使用的路径上发 ping/pong 就行了。\n健壮性与降级 要实现健壮性，还需要检测当前已选择的路径是否已经失败了（例如，NAT 设备维护清掉了所有状态）， 如果失败了就要降级（downgrade）到其他路径。这里有两种方式：\n持续探测所有路径，维护一个降级时会用的备用地址列表；\n直接降级到保底的中继模式，然后再通过路径探测升级到更好的路径。\n考虑到发生降级的概率是非常小的，因此这种方式可能是更经济的。\n7.9 安全 最后需要提到安全。\n本文的所有内容都假设：我们使用的上层协议已经有了自己的安全机制（ 例如 QUIC 协议有 TLS 证书，WireGuard 协议有自己的公钥）。 如果还没有安全机制，那显然是要立即补上的。一旦动态切换路径，基于 IP 的安全机制就是无用的了 （IP 协议最开始就没怎么考虑安全性），至少要有端到端的认证。\n严格来说，如果上层协议有安全机制，那即使收到是欺骗性的 ping/pong 流量，问题都不大， 最坏的情况也就是攻击者诱导两端通过他们的系统来中继流量。 而有了端到端安全机制，这并不是一个大问题（取决于你的威胁模型）。 但出于谨慎考虑，最好还是对路径发现的包也做认证和加密。具体如何做可以咨询你们的应用安全工程师。 我们终于完成了 NAT 穿透的目标！\n如果实现了以上提到的所有技术，你将得到一个业内领先的 NAT 穿透软件，能在绝大多数场景下实现端到端直连。 如果直连不了，还可以降级到保底的中继模式（对于 Tailscale 来说只能靠中继了）。\n但这些工作相当复杂！其中一些问题研究起来很有意思，但很难做到完全正确，尤其是那些 非常边边角角的场景，真正出现的概率极小，但解决它们所需花费的经历又极大。 不过，这种工作只需要做一次，一旦解决了，你就具备了某种超级能力： 探索令人激动的、相对还比较崭新的端到端应用（peer-to-peer applications）世界。\n8.1 跨公网 端到端直连 去中心化软件领域中的许多有趣想法，简化之后其实都变成了 跨过公网（互联网）实现端到端直连 这一问题，开始时可能觉得很简单，但真正做才 发现比想象中难多了。现在知道如何解决这个问题了，动手开做吧！\n8.2 结束语之 TL; DR 实现健壮的 NAT 穿透需要下列基础：\n一种基于 UDP 的协议； 能在程序内直接访问 socket； 有一个与 peer 通信的旁路信道； 若干 STUN 服务器； 一个保底用的中继网络（可选，但强烈推荐） 然后需要：\n遍历所有的 ip:port； 查询 STUN 服务器来获取自己的公网 ip:port 信息，以及判断自己这一侧的 NAT 的 “难度”（difficulty）； 使用 port mapping 协议来获取更多的公网 ip:ports； 检查 NAT64，通过它获取自己的公网 ip:port； 将自己的所有公网 ip:ports 信息通过旁路信道与 peer 交换，以及某些加密秘钥来保证通信安全； 通过保底的中继方式与对方开始通信（可选，这样连接能快速建立） 如果有必要 / 想这么做，探测对方的提供的所有 ip:port，以及执行生日攻击（birthday attacks）来穿透 harder NAT； 发现更优路径之后，透明升级到该路径； 如果当前路径断了，降级到其他可用的路径； 确保所有东西都是加密的，并且有端到端认证。 ","date":"2022-07-07T00:00:00Z","permalink":"https://jen-jon.github.io/posts/20220707/","tags":"NAT; 内网穿透","title":"NAT穿透是如何工作的（Tailscale）","type":"technology"},{"contents":"初见 事情的起因还要追溯到很久之前看了一篇论文，论文的核心就是讨论预训练策略在低层视觉任务中的作用。既然是预训练策略，那就不可避免的要用规模大一点的数据集，之所以预训练这些年在低层视觉任务中鲜被应用的，其主要的原因就是缺乏大规模数据集。这篇论文主要针对低层视觉任务中的SR（超分辨率）、DeRain（去雨）和DeNoise（去噪）三个任务，作者利用ImageNet中的图像作为基准图像，并在此基础上利用双三次插值得到低分辨率图像用于SR任务，将雨纹和高斯噪声直接加入到干净的基准图像中用于DeRain和DeNoise任务。\n但是论文中却忽略了低层视觉中一个非常重要的问题，即低光增强任务（Low-light Image Enhancement）。我觉得主要问题就是低光增强任务中所用到的配对图像数据集是很难获得的，特别是用ImageNet来生成，更是难上加难。其一，低光环境是个很复杂的环境，不是简单调低图像的亮度就能实现的，在低光环境下拍摄的图像往往是有的地方暗有的地方亮；其二，低光环境下摄得的图像往往伴随着各种复杂的噪声，简单的往图像上叠加噪声可能并不真实。前不久我克服了这两个问题，成功从ImageNet/VOC/COCO/IAPR/StreetScenes这五个数据集中挑选一些合适的图像构造了一个大规模配对的暗光图像数据集，其中共包含了153,856对暗光/正常光图像（具体数据集是如何构造的今天就不赘述了，等论文发表后我会详细跟大家解释）。我们知道，PyTorch中提供了torch.utils.data.Dataset(*args, **kwds)和torch.utils.data.DataLoader(dataset, ...)这两个类来实现数据集的构建和数据的加载，但是这两个类都是作用在CPU上的。然而我们的预训练数据集的规模达到了153,856*2张，用CPU来加载速度实在太慢了，在后续训练的过程中可能会导致模型等待数据传入的情况，即模型已经训练完一个batch的数据了，但是下一个batch的数据还在加载，没能及时传到模型中，这样会导致GPU的利用率显著下降。也就是说不仅会降低模型训练的速度，同时也没能完全压榨出显卡等硬件的性能，是一件性价比极低的事情。下面举个🌰（例子）：\nimport os import torch import torch.nn as nn from PIL import Image from torchvision import transforms from torch.utils.data import Dataset, DataLoader, random_split torch.__version__ DATA_DIR = \u0026#34;/home/jensen/workspace/DATASETS/SYNTHETIC_DATA\u0026#34; BATCH_SIZE = 128 IMAGE_SIZE = 192 syn_trans = transforms.Compose([ transforms.Resize((IMAGE_SIZE, IMAGE_SIZE)), transforms.ToTensor(), ]) class Syn_Dataset(nn.Module): def __init__(self, low_path, high_path, transforms=None): self.low_path = low_path self.high_path = high_path self.transforms = transforms def __getitem__(self, idx): low_files = os.listdir(self.low_path) high_files = os.listdir(self.high_path) low_image = Image.open(os.path.join(self.low_path, low_files[idx])) high_image = Image.open(os.path.join(self.low_path, high_files[idx])) if self.transforms: low_image = self.transforms(low_image) high_image = self.transforms(high_image) return low_image, high_image def __len__(self): return len(os.listdir(self.low_path)) dataset = Syn_Dataset(low_path=os.path.join(DATA_DIR, \u0026#34;low\u0026#34;), high_path=os.path.join(DATA_DIR, \u0026#34;low\u0026#34;), transforms=syn_trans) train_data, val_data = random_split(dataset, (152000, 1856)) val_loader = DataLoader(val_data, batch_size=BATCH_SIZE, shuffle=True, num_workers=4) %%time for idx, data in enumerate(val_loader): X, Y = data print(X.shape) 上面这个例子使用PyTorch内置的DataLoader类以batch_size = 128遍历了一遍val_dataset，并打印每个batch的尺寸。使用jupyter的%%time魔法语言来计算遍历一遍所花费的时间，从下图可以直观看到，一共花费近两分钟完成一次遍历。\n接下来再举个🌰：\nfrom torchvision import models model = models.alexnet(pretrained=False).cuda() criterion = nn.CrossEntropyLoss() for idx, data in enumerate(val_loader): X, Y = data output = model(X.cuda()) loss = criterion(out.cpu(), torch.empty(out.shape[0], dtype=torch.long).random_(1000)) loss.backward() 上面这个例子是模拟将数据输入AlexNet中处理，从下图中可以看到GPU的利用率很低（大多数时间都是0%）。主要原因是模型处理数据的时间比数据加载的时间更快，也就意味着模型通常要等待DataLoader将新的batch的数据传过来，导致GPU的利用率大多数时间都处于较低的状态甚至是空闲，严重拖慢模型训练的效率。\n要是数据规模小的话，这点时间也不算什么，但是我的数据规模是数十万级别的，每一分一秒都可以说是十分珍贵的，于是我找到了一个非常nice的加速工具：NVIDIA DALI库。\n单卡环境下的NVIDIA DALI使用 （NVIDIA DALI的具体使用方式请参阅官方文档）\n安装 首先需要确定自己的cuda版本，可以在命令行中输入nvcc -V来查询，如下图，cuda版本为10.2。\n紧接着在命令行中输入pip install nvidia-pyindex \u0026amp;\u0026amp; pip install nvidia-dali-cuda102，请注意，这里的cuda102正是对应了上面查询的cuda版本10.2。\n单卡环境下使用 所谓单卡环境下使用即训练的过程中只使用一张卡，这是最简单的形式。可以自己定义数据的迭代方式，数据的Pipeline以及加载方式。详细细节请看代码：\nimport os import torch import numpy as np from random import shuffle import nvidia.dali.fn as fn import nvidia.dali.types as types from torch.utils.data import random_split from nvidia.dali.pipeline import Pipeline from nvidia.dali.plugin.pytorch import DALIGenericIterator, LastBatchPolicy torch.__version__ class ExternalInputIterator(object): def __init__(self, batch_size, files, data_dir): self.low_dir = os.path.join(data_dir, \u0026#39;low\u0026#39;) self.high_dir = os.path.join(data_dir, \u0026#39;high\u0026#39;) self.batch_size = batch_size self.files = list(files) shuffle(self.files) def __len__(self): return len(self.files) def __iter__(self): self.i = 0 self.n = len(self.files) return self def __next__(self): if self.i \u0026gt;= self.n: self.__iter__() raise StopIteration low = [] high = [] leave_num = self.n - self.i current_batch_size = min(self.batch_size, leave_num) for _ in range(current_batch_size): filename = self.files[self.i] l = open(os.path.join(self.low_dir, filename), \u0026#39;rb\u0026#39;) h = open(os.path.join(self.high_dir, filename), \u0026#39;rb\u0026#39;) low.append(np.frombuffer(l.read(), dtype=np.uint8)) high.append(np.frombuffer(h.read(), dtype=np.uint8)) self.i += 1 return (low, high) next = __next__ len = __len__ class ExternalSourcePipeline(Pipeline): def __init__(self, data_iterator, batch_size, num_threads, device_id, img_size): super(ExternalSourcePipeline, self).__init__(batch_size, num_threads, device_id, exec_async=False, exec_pipelined=False) self.img_size = img_size self.batch = batch_size self.data_iterator = data_iterator self.lows, self.highs = fn.external_source(source=self.data_iterator, num_outputs=2, dtype=types.UINT8) def __len__(self): length = len(self.data_iterator) return (length // self.batch + 1) if (length % self.batch != 0) else (length // self.batch) def define_graph(self): low_decode = fn.decoders.image(self.lows, device=\u0026#34;mixed\u0026#34;) high_decode = fn.decoders.image(self.highs, device=\u0026#34;mixed\u0026#34;) low_resize = fn.resize(low_decode, device=\u0026#34;gpu\u0026#34;, resize_x=self.img_size, resize_y=self.img_size, interp_type=types.INTERP_TRIANGULAR) high_resize = fn.resize(high_decode, device=\u0026#34;gpu\u0026#34;, resize_x=self.img_size, resize_y=self.img_size, interp_type=types.INTERP_TRIANGULAR) self.low = fn.transpose(low_resize, perm=[2, 0, 1]) / 255.0 self.high = fn.transpose(high_resize, perm=[2, 0, 1]) / 255.0 return (self.low, self.high) def iter_setup(self): self.set_outputs(self.low, self.high) class CustomDALIGenericIterator(DALIGenericIterator): def __init__(self, pipelines, **kwargs): output_maps = [\u0026#39;lows\u0026#39;, \u0026#39;highs\u0026#39;] if not isinstance(pipelines, list): pipelines = [pipelines] super(CustomDALIGenericIterator, self).__init__(pipelines, output_maps, **kwargs) self.pipelines = pipelines # devices \u0026gt; 1 ==\u0026gt; pipelines \u0026gt; 1 def __next__(self): batch = super(CustomDALIGenericIterator, self).__next__() return self.parse_batch(batch) def __len__(self): lengths = [len(i) for i in self.pipelines] return sum(lengths) def parse_batch(self, batch): lows, highs = batch[0][\u0026#39;lows\u0026#39;], batch[0][\u0026#39;highs\u0026#39;] return lows, highs DATA_DIR = \u0026#34;/home/jensen/workspace/SYNTHESIS_DATA\u0026#34; BATCH_SIZE = 128 IMAGE_SIZE = 192 files = os.listdir(os.path.join(DATA_DIR, \u0026#39;low\u0026#39;)) train_files, val_files = random_split(files, (152000, 1856)) val_iter = ExternalInputIterator(batch_size=BATCH_SIZE, files=val_files, data_dir=DATA_DIR) val_pipe = ExternalSourcePipeline(val_iter, batch_size=BATCH_SIZE, num_threads=4, device_id=0, img_size=IMAGE_SIZE) val_loader = CustomDALIGenericIterator(val_pipe) %%time for idx, data in enumerate(val_loader): X, Y = data print(X.shape) 上面的例子使用NVIDIA DALI自定义了数据的迭代方式以及加载方式，同样使用jupyter的%%time魔法函数来计算遍历一遍所花费的时间，如下图所示，整个过程仅花费了不到3秒钟。\n此外，可以模拟将数据输入AlexNet中处理，GPU的利用率也会一直稳定在85%以上，表明GPU的性能被充分利用。\n多卡环境下的NVIDIA DALI使用 本文中所指的多卡环境是单机多卡环境，即在一台机器的多个GPU上进行分布式训练，然而多机多卡的情况并不在本文的讨论范畴之内，我也确实没有用过这种训练方式。有关多卡环境下的使用方式也可以参考官方文档。下面直接放出我的例子吧：\nimport os import nvidia.dali.fn as fn import nvidia.dali.types as types from torch.utils.data import random_split from nvidia.dali.pipeline import Pipeline from nvidia.dali.plugin.pytorch import DALIGenericIterator, LastBatchPolicy class SyntheicDataPipeline(Pipeline): \u0026#34;\u0026#34;\u0026#34; An extended Pipeline class based on the Nvidia DALI library for low-light image enhancement. The effect of the Pipeline class is somewhat similar to the Dataset class in Pytorch and the transforms function in torchvision. Mainly is to carry on some simple preprocessing to the input data. Args: batch_size (int): batch_size. data_dir (str): the folder path of the paired image. (excluding the \u0026#39;low\u0026#39; and\u0026#39; high\u0026#39; folders) files (list): A list of paired image filenames. image_size (int | tuple): image size after resize operation. Default: 192 num_threads (int): number of CPU threads used by the pipeline. Default: 2 device_id (int): id of GPU used by the pipeline. Default: 0 seed (int): seed used for random number generation. Default: -1 shard_id (int): index of the shard to read. Default: 0 num_shards (int): partitions the data into the specified number of parts (shards). Default: 1 random_shuffle (bool): determines whether to randomly shuffle data. Default: True Examples: When you have a GPU, device_id and shard_id should be set to 0 and num_shards should be set to 1. When you have four GPU, the value range for device_id and shard_id is [0-3] (device_id and shard_id values are usually the same), and num_shards should be set to 4. For details, please refer to the official DALI documentation: https://docs.nvidia.com/deeplearning/dali/user-guide/docs/ or my blog (which will be updated in the near future): https://jensen.dlab.ac.cn/ . \u0026#34;\u0026#34;\u0026#34; def __init__(self, batch_size, data_dir, files, image_size=192, num_threads=-1, device_id=0, seed=-1, shard_id=0, num_shards=1, random_shuffle=True, **kwargs): super(SyntheicDataPipeline, self).__init__(batch_size=batch_size, num_threads=num_threads, device_id=device_id, seed=seed, **kwargs) self.types = [\u0026#39;low\u0026#39;, \u0026#39;high\u0026#39;] self.data_dir = [os.path.join(data_dir, name) for name in self.types] self.files = list(files) self.image_size = image_size self.shard_id = shard_id self.num_shards = num_shards self.random_shuffle = random_shuffle def define_graph(self): low_inputs, _ = fn.readers.file(file_root=self.data_dir[0], files=self.files, seed=1234, shard_id=self.shard_id, num_shards=self.num_shards, random_shuffle=self.random_shuffle, pad_last_batch=True, name=\u0026#34;main_reader\u0026#34;) high_inputs, _ = fn.readers.file(file_root=self.data_dir[1], files=self.files, seed=1234, shard_id=self.shard_id, num_shards=self.num_shards, random_shuffle=self.random_shuffle, pad_last_batch=True) inputs = {\u0026#39;low\u0026#39;: low_inputs, \u0026#39;high\u0026#39;: high_inputs} images = {x: fn.decoders.image(inputs[x], device=\u0026#34;mixed\u0026#34;) for x in self.types} resizes = {x: fn.resize(images[x], device=\u0026#34;gpu\u0026#34;, resize_x=self.image_size, resize_y=self.image_size, interp_type=types.INTERP_TRIANGULAR) for x in self.types} self.tensors = {x: fn.transpose(resizes[x], perm=[2, 0, 1]) / 255.0 for x in self.types} return (self.tensors[\u0026#39;low\u0026#39;], self.tensors[\u0026#39;high\u0026#39;]) def iter_setup(self): self.set_outputs(self.tensors[\u0026#39;low\u0026#39;], self.tensors[\u0026#39;high\u0026#39;]) class SyntheicDataIterator(DALIGenericIterator): \u0026#34;\u0026#34;\u0026#34; An extended Iterator class based on the Nvidia DALI library for low-light image enhancement. The effect of the Iterator class is somewhat similar to the Dataloader class in Pytorch. Args: pipelines (nvidia.dali.Pipeline): pipelines. reader_name (str): name of the reader which will be queried to the shard size, number of shards and all other properties necessary to count properly the number of relevant and padded samples that iterator needs to deal with. last_batch_policy (int): strategy for processing the last batch data. (especially if the size of the last batch data is smaller than batch_size) output_map (list): list of strings which maps consecutive outputs of DALI pipelines to user specified name. Example: loader = SyntheicDataIterator(...) for idx, data in enumerate(loader): low, high = data ... For details, please refer to the official DALI documentation: https://docs.nvidia.com/deeplearning/dali/user-guide/docs/ or my blog (which will be updated in the near future): https://jensen.dlab.ac.cn/ . \u0026#34;\u0026#34;\u0026#34; def __init__(self, pipelines, reader_name, last_batch_policy, output_map=[\u0026#39;low\u0026#39;, \u0026#39;high\u0026#39;], **kwargs): super(SyntheicDataIterator, self).__init__(pipelines=pipelines, output_map=output_map, reader_name=reader_name, last_batch_policy=last_batch_policy, **kwargs) def _parse_data(self, data): low_data, high_data = data[0][\u0026#39;low\u0026#39;], data[0][\u0026#39;high\u0026#39;] return low_data, high_data def __next__(self): data = super(SyntheicDataIterator, self).__next__() return self._parse_data(data) def __len__(self): return super(SyntheicDataIterator, self).__len__() DATA_DIR = \u0026#34;/home/jensen/workspace/SYNTHESIS_DATA\u0026#34; BATCH_SIZE = 128 IMAGE_SIZE = 192 files = os.listdir(os.path.join(DATA_DIR, \u0026#39;low\u0026#39;)) train_files, val_files = random_split(files, (152000, 1856)) pipe = SyntheicDataPipeline(batch_size=BATCH_SIZE, num_threads=4, device_id=0, seed=1234, data_dir=DATA_DIR, files=val_files, image_size=IMAGE_SIZE, shard_id=0, num_shards=1) val_loader = SyntheicDataIterator(pipe, reader_name=\u0026#34;main_reader\u0026#34;, auto_reset=True, last_batch_policy=LastBatchPolicy.PARTIAL) for idx, data in enumerate(val_loader): X, Y = data print(X.shape) 上面的例子其实还是单机单卡的环境，但是只要稍微修改一下就可以实现单机多卡。即将SyntheicDataPipeline类中的device_id和shard_id以及num_shards这三个参数稍作修改。device_id很好理解了，例如一台机器有四张GPU，则device_id分别为0、1、2、3。假如在第二张GPU上进行运算，则device_id就是2，此外shard_id一般与device_id保持一致，它是指第几个分片（分布式训练的实质就是将一个大batch的数据均分到每个GPU上来并行运算，因此第一张GPU上输入的数据应当就是均分数据得到的第一个分片）。num_shards这个参数也很好理解，它的意思即一共有多少张GPU。虽然看起来很简单，但是还是有三个参数需要修改，似乎还是有点麻烦，但是不用担心，实际上这些参数都是不需要人为去设定。因为通常分布式训练都需要从命令行传入一个参数--nproc_per_node，通过这一个参数都能自适应的完成上述参数的修改，在实际训练的时候，只需做如下修改即可：device_id=args.local_rank、shard_id=args.local_rank、num_shards=args.world_size。\n好了，本篇博客到这里就应该要结束了，本文中提到的方法通常都能适用于各种深度学习任务，只是不同的任务在数据读取上可能会有一些异同，但我相信这些问题都可以通过参阅官方文档中的nvidia.dali.fn使用说明来解决。接下来如果有时间的话我会再介绍一下如何使用NVIDIA APEX库来实现分布式训练以及如何将NVIDIA DALI和APEX库结合起来使用。\n","date":"2022-06-08T00:00:00Z","permalink":"https://jen-jon.github.io/posts/20220608/","tags":"NVIDIA DALI; Deep Learning","title":"NVIDIA DALI踩坑教程","type":"technology"},{"contents":"发现想要保持博文的更新频率和内容质量是一件让人特别头疼的事情。至少，在我毕业之前都是很难保证的，每天会被各种各样的事情各种各样的任务（老板的任务罢了）绑架，根本没有时间去总结\u0026hellip;\u0026hellip;\n最近其实折腾了很多有意思的东西，熟悉我的朋友都知道，现阶段我是做计算摄影相关的任务的尤其是暗光图像质量增强的任务，因为上次被开题报告折磨，所以一时间想出了很多新点子（俗称创新点）。但是正所谓点子可以乱想，但实现点子的过程可是各种踩坑\u0026hellip;\u0026hellip;好啦，具体细节我暂时还不能讲（毕竟我实验还没做完，论文更是一个字还没写呢！），但是可以预告一下接下来的内容：\nPyTorch和Python性能的提升 NVIDIA DALI库的使用 如何合成暗光图像？ \u0026hellip; ","date":"2022-05-25T00:00:00Z","permalink":"https://jen-jon.github.io/posts/20220525/","tags":"博文预告","title":"内容预告","type":"summary"},{"contents":"入门教程 Cython概念 Cython本质上就是具有C数据类型的Python。\n除了极少数例外，几乎所有的Python代码都是有效的Cython代码。Cython的编译器会把代码转换成等效于调用Python/C API的C代码。\n由于Cython的参数和变量可以背声明为具有C数据类型，因此可以自由地混用操作Python值和C值的代码，而Cython会自动转换需要转换的地方。此外，Python中的引用计数保存和错误检查也是自动的，而且Python的异常处理机制，包括try-except和try-finally同样可行，即使是在操作C数据时。\nCython的第一个程序 Cython可以接受几乎所有有效的Python源文件，因此在Cython的启程之路上最大的拦路虎之一就是如何去编译拓展文件。\n首先从标准的Python Hello, World开始：\nprint(\u0026#34;Hello, World\u0026#34;) 将这段代码保存为helloworld.pyx。现在需要创建一个setup.py，这就像是一个Python的Makefile，因此setup.py应该像这样：\nfrom distutils.core import setup from Cython.Build import cythonize setup( ext_modules = cythonize(\u0026#34;helloworld.pyx\u0026#34;) ) 接着使用下面的命令行来建立Cython文件：\npython setup.py build_ext --inplace 在类Unix系统中，这行命令会在你的本地文件夹中创建一个叫做helloworld*.so的文件。在Windows系统中，它叫helloworld*.pyd。现在运行Python解释器，然后把这个文件当成一个普通的Python模块简单的import它就可以使用了：\nimport helloworld Hello, World 恭喜！此时你已经知道如何去创建一个Cython拓展了，但是这个例子会给人一种不知道Cython有何优势的感觉，所以接下来介绍更有现实意义的例子。\nPyximport模块 如果Cython模块不需要任何外部的C库或者特殊的安装方式，那便可以直接使用pyximport模块。该模块由Paul Prescod开发，用来直接使用import来载入*.pyx文件，而不需要在每次更改代码的时候都重新运行一遍setup.py文件。pyximport模块的使用方式如下：\nimport pyximport; pyximport.install() import helloworld Hello, World pyximport模块也支持对普通Python模块的实验性编译，这可以使得在Python导入每个*.pyx和*.py模块上自动运行Cython，包括标准库和被安装的包。Cython在编译大量Python模块的时候也会经常失败，此时import机制将会回溯，转而去载入Python源模块：\nimport pyximport; pyximport.install(pyimport=True) （注意，这种方式现已不推荐！）\n例子：字符串转整数 在之前Python基础中有一个简单的字符串转整数的例子：\nfrom functools import reduce DIGITS = {\u0026#39;0\u0026#39;: 0, \u0026#39;1\u0026#39;: 1, \u0026#39;2\u0026#39;: 2, \u0026#39;3\u0026#39;: 3, \u0026#39;4\u0026#39;: 4, \u0026#39;5\u0026#39;: 5, \u0026#39;6\u0026#39;: 6, \u0026#39;7\u0026#39;: 7, \u0026#39;8\u0026#39;: 8, \u0026#39;9\u0026#39;: 9} def str2int(s): def fn(x, y): return x * 10 + y def char2num(s): return DIGITS[s] return reduce(fn, map(char2num, s)) 现在可以跟着上面Hello, World的例子照葫芦画瓢。首先将文件拓展名更改为str2int.pyx，接下来创建setup.py文件：\nfrom distutils.core import setup from Cython.Build import cythonize setup( ext_modules=cythonize(\u0026#34;str2int.pyx\u0026#34;), ) 创建拓展的命令与helloworld.pyx的例子相同:\npython setup.py build_ext --inplace 使用拓展的方式也很简单：\nimport str2int str2int.str2int(\u0026#39;2021111052\u0026#39;) 2021111052 也可以使用pyximport模块来导入拓展：\nimport pyximport; pyximport.install() import str2int str2int.str2int(\u0026#39;2021111052\u0026#39;) 2021111052 Cython特性 下面通过一个小例子来介绍Cython的特性。\n# 加载Cython扩展 %load_ext Cython %%cython def primes(int nb_primes): cdef int n, i, len_p cdef int p[1000] if nb_primes \u0026gt; 1000: nb_primes = 1000 len_p = 0 # p中当前元素的数量 n = 2 while len_p \u0026lt; nb_primes: # 是否是质数？ for i in p[:len_p]: if n % i == 0: # 存在一个因数则跳过，不是质数 break else: # 一个因数都没有，是质数 p[len_p] = n len_p += 1 n += 1 result_as_list = [prime for prime in p[:len_p]] return result_as_list primes(10) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] 可以发现，函数的开始部分就像普通的Python函数定义，除了参数nb_primes被声明为int类型，这意味着这个参数被传入时会被转换为C的整数类型（如果转换失败则是TypeError）。\n在函数体中，使用了cdef语句来定义一些局部的C变量：\n... cdef int n, i, len_p # 定义一些局部的C变量 cdef int p[1000] ... 在处理过程中，结果被保存在一个C数组p中，并且最后被复制到一个Python列表中：\n... p[len_p] = n # 结果被保存在C数组中 ... result_as_list = [prime for prime in p[:len_p]] # 复制到Python列表中 ... 注意，在上述例子中，不能创建太大的数组，因为数组是被分配在C函数调用的栈上的，而这些栈资源是有限的。如果需要更大的数组或者这些数组的长度只有在程序运行时才能被确定，可以使用Cython对C内存进行分配或者使用Numpy数组等等进行提高效率。 在C中声明一个静态数组需要在编译时确定数组的大小，所以程序中需要确保传入的参数不得大于数组的大小，否则会抛出类似C中的段错误：\n... if nb_primes \u0026gt; 1000: nb_primes = 1000 # 防止传入的参数超过数组大小 ... 值得注意的是下面这段代码：\n... for i in p[:len_p]: if n % i == 0: break ... 这段代码使用候选数字依次除以已经找到的每一个质数来判断候选数字数不是质数。因为这里面没有Python对象被引用，循环被整体翻译成了C代码，所以运行速度大幅提高。请注意迭代C数组p的方式：\n... for i in p[:len_p]: # 虽然循环被翻译成C代码，但依然可以像操作Python列表一样使用切片，提高运行效率 ... 在返回结果之前，需要先将C数组复制到一个Python列表里，因为Python不能读取C数组。Cython可以自动将很多C类型转换为Python类型：\n... result_as_list = [prime for prime in p[:len_p]] # 复制到Python列表中 ... 请注意，正如Python声明一个Python列表的形式，result_as_list没有被显式声明，因此它会被视为一个Python对象。\n至此，Cython的基本用法已经明了，但Cython究竟帮我们节省了多少工作量还是值得探究的。可以在cythonize()中传入参数annotate=True生成一个HTML文件：\nfrom distutils.core import setup from Cython.Build import cythonize setup( ext_modules = cythonize(\u0026#34;primes.pyx\u0026#34;, annotate=True) ) 在HTML文件中可以发现，黄色行代表改行与Python进行交互，交互的越多颜色就越深。白色行则表示没有与Python进行交互，该部分代码被完全翻译成C代码。\n这些黄色行会操作Python对象、生成异常或是做一些其他更高级的操作，因此都不能被翻译成简单快速的C代码，函数声明和返回使用了Python的解释器所以这些行也是黄色的。 此外，按照逻辑if n % i == 0:这行语句可以直接通过C代码实现，为什么会标黄呢？可以发现Cython在这里默认使用Python在运行时的除法检查。可以使用编译器指令cdivision=True禁止这种检查。\n性能对比 针对上述primes的例子，下面是一个Python版的相同程序：\ndef primes_python(nb_primes): p = [] n = 2 while len(p) \u0026lt; nb_primes: # 是否是质数？ for i in p: if n % i == 0: break # 如果循环中未发生break else: p.append(n) n += 1 return p %%time cython = primes(1000) CPU times: user 1.62 ms, sys: 0 ns, total: 1.62 ms Wall time: 1.62 ms %%time python = primes_python(1000) CPU times: user 24.6 ms, sys: 0 ns, total: 24.6 ms Wall time: 23.7 ms cython == python True 从上述对比中可以发现，Cython的速度几乎数十倍优于Python。很明显C比Python对于CPU的缓存的支持性更好，Python中一切皆对象，均以字典的形式存在，对于CPU缓存是不友好的。一般来说Cython的速度会是Python的2倍到1000倍之间，具体取决于调用Python解释器的次数。\nC++版本的Primes 上面的Cython调用的都是C API，当然Cython也可以调用C++（部分C++的标准库可以在Cython代码中被直接导入）。下面是使用C++标准库中vector后的primes函数：\n# distutils: language=c++ from libcpp.vector cimport vector def primes(unsigned int nb_primes): cdef int n, i cdef vector[int] p p.reserve(nb_primes) # allocate memory for \u0026#39;nb_primes\u0026#39; elements. n = 2 while p.size() \u0026lt; nb_primes: # vector的size()和len()类似 for i in p: if n % i == 0: break else: p.push_back(n) # push_back is similar to append() n += 1 return p # 在转换到Python对象时，vector可以被自动转换为Python列表 第一行# distutils: language=c++是编译器指令，告诉Cython把代码编译成C++，这样就可以使用C++的特性和C++标准库(注意，pyximport无法把Cython代码编译成C++，需要使用setup.py)。\n可以看到，C++的vector API和Python的列表API非常相似，在Cython中经常可以做替换。\n更多在Cython中使用C++的细节请参阅在Cython中使用C++。\n更多Cython语言基础请参阅语言基础。\n中文Cython文档请参阅Cython中文文档。\n","date":"2022-05-11T00:00:00Z","permalink":"https://jen-jon.github.io/posts/20220511/","tags":"Cython; Python","title":"Cython教程","type":"technology"},{"contents":"\nWe stand with the people of Ukraine and everyone protesting against the Russian government’s act of war and aggression against a peaceful nation. We stand with everyone resisting this invasion, its means and the distortion of information used against it. We stand with Ukraine’s unity and resilience. 我们与乌克兰人民和所有抗议俄罗斯政府对一个和平国家的战争和侵略行为的人站在一起。我们与每个人站在一起，抵制这种入侵，抵制其手段，抵制对其使用的歪曲信息。我们与乌克兰的团结和韧性站在一起。 We stand for everything this invasion and its means of aggression violate – freedom, self-expression, love, the right to a future. Everything we are, as a human being and a developer, has always depended on tolerance, solidarity and peace. These conditions are not only vital but require continuous commitment, energy, and thoughtful action. 我们支持这种入侵及其侵略手段所侵犯的一切\u0026ndash;自由、自我表达、爱、拥有未来的权利。我们的一切，作为一个人和一个开发者，一直依赖于宽容、团结和和平。这些条件不仅是至关重要的，而且需要持续的承诺、精力和深思熟虑的行动。 As well as declaring our support, we have made donations to the following organisations: 在宣布支持的同时，我们还向以下组织进行了捐赠： Red Cross in Ukraine Outright International UNHCR - The UN Refugee Agency for Ukraine We invite you to join us by supporting these charities and we are proud to stand with Ukraine! 我们邀请你加入我们的行列，支持这些慈善机构，我们很自豪能与乌克兰站在一起！ Sincerely, Jensen Слава Україні! ","date":"2022-04-23T00:00:00Z","permalink":"https://jen-jon.github.io/we-stand-with-ukraine/","tags":null,"title":"We Stand With Ukraine!","type":null},{"contents":"最近俄罗斯与乌克兰之间的冲突愈演愈烈，似乎没有要停下来的意思。国内的社交媒体上，我看到大多数的国人言语上都是支持俄罗斯的，当下中国和俄罗斯的关系非常铁，所以国人这种态度其实可以理解的。\n但是我觉得吧，战争是个很复杂的东西，你说不出来那一方是对的，那一方是错误的，因为战争的每一方都是站在维护自己国家的利益的角度上考虑的，所以没有对错。泽连斯基想加入欧盟，可能是为了改善乌克兰颓废的经济；想加入北约，也可能是因为14年的克里米亚危机给乌克兰人民带来了巨大的危机感。普京吞并克里米亚也是出于维护俄罗斯的国家利益，毕竟黑海舰队总不能没有出海口；入侵乌克兰也是美国一步一步的挑唆所导致\u0026hellip;\u0026hellip;美国背信弃义在前，北约五次东扩越来越让俄罗斯没有安全感\u0026hellip;\u0026hellip;\n虽然，战争没有对错，但战争的结局一定没有赢家，所有人都是输家，毕竟世界早已连接在一起，没有人可以隔岸观火\u0026hellip;\u0026hellip;\n这场战争或者说是争端，最令我唏嘘的可能就是“安-225”运输机的损坏，据悉2月27日，世界上最大的运输机“安-225”在基辅郊外的机场被俄方损坏。我一直都不想发这个博客，因为俄乌战场上的新闻真真假假，实在让人难以分辨。我一直在等待安东诺夫公司官方的声明，声明“安-225”还好好的。 今天凌晨，安东诺夫公司发了一条推特：“DREAMS do not burn🇺🇦!”，并没有解释更多。我个人的理解是，“安-225”不在了，但是梦想永不会被烧毁。\n看到了网友为“安-225”送别的话，我稍微修改了一下：\n制造一架安-225需要整个苏联，毁灭一架安-225却只需要一发炮弹。\n没想到“Mriya”的命运是以这样凄惨的结果而告终，它带着航空史上无尽的梦幻回归了31年前红色帝国消失的那场暴风雪。\n此别竟是永别！\n某种程度上，安-225代表着人类挑战天空的最高峰。\n从绑火箭飞天的万户到莱特兄弟，再到如今，挑战飞行是不论肤色国籍，人类共同的梦幻。\n今天，我们很可能要与这场大梦告别，但我相信，未来还会有这样的杰作，带着咆哮的涡流划开天空的云彩。\n彼时，定会有人想起这对巨翼，永远地埋葬在基辅的黑土地里。\n愿世界和平！PEACE!\n","date":"2022-03-02T00:00:00Z","permalink":"https://jen-jon.github.io/posts/20220302/","tags":"感悟；生活","title":"别了，Mriya！","type":"lifestyle"},{"contents":"函数知识点汇总 调用函数 Python内置了很多有用的函数可以直接调用。 要掉用一个函数需要知道函数的名称与参数，可以从Python的官方网站查看文档，也可以通过help函数查询帮助信息，如help(abs)。\n调用函数时，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地告诉你所调用的函数需要几个参数；如果传入参数数量正确，但是参数类型不被函数所接受，也会报TypeError错误。\n也有函数可以接受任意多个参数，并返回最大的那个，如max函数：\nmax(1, 3) # 3 max(1, -3, 2) # 2 2 数据类型转换 Python内置的函数还包括数据类型转换函数，如int、str等。\n函数名其实就是指向一个函数对象的引用，因此完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：\nm = max # 变量m指向max函数 m(1, 3, 5) # 因此可以通过变量m调用max函数 5 定义函数 Python中定义函数需要使用def语句，再在其后依次写出函数名、左括号、参数、右括号和冒号，然后再在缩进块中编写函数体，最后使用return语句返回。例子：求绝对值函数my_abs：\ndef my_abs(x): if x \u0026gt;= 0: return x else: return -x 函数体内部语句在执行时一旦执行到return语句就执行完毕，并返回结果。如果函数体中没有return语句，函数执行到最后也会返回，只是返回的结果为None，也可以写成return None或return。\n空函数 如果定义一个啥都不做的空函数可以在其函数体部分使用pass语句。比如：\nif height \u0026lt; 180: pass 参数检查 正如上文所述，调用函数时若参数个数不对，Python解释器会抛出TypeError错误并提示，但是如果参数类型不正确，Python解释器是不会像调用内置函数那样自动检查的，这可能会导致函数体执行过程中出现问题，可以使用Python的内置函数isinstance检查参数类型：\ndef my_abs(x): if not isinstance(x, (int, float)): raise TypeError(\u0026#34;bad operand type\u0026#34;) # 若传入错误的参数类型，函数则会抛出错误 if x \u0026gt;= 0: return x else: return -x 返回多个值 可以使用return A, B语句返回两个值，当然也可以拓展到多个值。但其实这只是一种假象，Python函数返回的依然是单一值，但是当返回值不止一个时，返回值会被自动包装成一个tuple。\n函数的参数 定义函数时，参数的名字和位置确定下来，函数的接口定义就完成了。虽然Python函数定义非常简答，但其却异常灵活。\n位置参数 例子：计算二次方的函数：\ndef power(x): return x ** x 对于函数power，参数x就是一个位置参数，当调用power函数时，必须传入有且仅有的一个参数x。 但是上面的函数实际用起来却不合适，倘若要计算三次方、四次方\u0026hellip;岂不是要写很多函数。OK，可以稍微修改一下power函数：\ndef power(x, n): s = 1 while n \u0026gt; 0: n -= 1 s *= x return s 这个修改后的power函数便可以计算任意次方数，而且此时它拥有两个位置参数x和n，调用时，需要按位置顺序依次给这两个参数赋值。\n默认参数 但是似乎日常开发中用到二次方计算的情况远大于其他次方，此时可以使用默认参数，将第二个参数n的默认值设为2:\ndef power(x, n = 2): s = 1 while n \u0026gt; 0: n -= 1 s *= x return s 于是调用power(5)时就相当于调用power(5, 2)，而对于n ≠ 2的情况，则需明确地传入n的值。 使用默认参数可以简化函数的调用，但是有诸多坑：\n默认参数必须放在必选参数的后面； 有多个默认参数时，既可以按顺序提供部分默认参数，也可以不按顺序提供部分默认参数，但是不按顺序提供时，需要把参数名字写上； （如add_student('Jensen', 'Male', city = 'Hefei')，意思为city用传进去的值，其他默认参数继续使用默认值）\n默认参数必须指向不变的对象； （如例子：\ndef add_end(L = []): L.append(\u0026#39;END\u0026#39;) return L 连续调用两次add_end()后，返回['END', 'END']，这是因为默认参数是变量，指向[]，每次调用默认参数的值都会发生改变。）\n可变参数 Python中还可以定义可变参数，即传入的参数个数是可变的，仅需在参数前加上一个*号即可：\ndef calc(seed, *nums): sum = 0 for n in nums: sum += n * n return seed, sum calc(1, 2, 3, 4) # 1对应参数seed，后面几个参数都对应可变参数nums (1, 29) 在calc函数内部，参数nums接收到的是一个tuple，调用该函数时，可以传入任意个参数，包括1个参数（即必选参数seed）。 如果已经有了一个list或者tuple，可以在list或tuple前面加一个*来将其中的元素变为可变参数传入：\nalist = [2, 5, 6, 7] calc(1, *alist) # 将list变成转变为可变参数 (1, 114) 关键字参数 关键字参数允许传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动封装为一个dict。与可变参数类似，也可以先组装一个dict，再在dict前加上**来降关键字参数传入：\ndef person(name, age, **kw): print(\u0026#34;name: \u0026#34;, name, \u0026#34;, age: \u0026#34;, age, \u0026#34;, otr: \u0026#34;, kw) info = {\u0026#39;city\u0026#39;: \u0026#39;HFE\u0026#39;, \u0026#39;major\u0026#39;: \u0026#39;Computer Science\u0026#39;} person(\u0026#39;Jensen\u0026#39;, 22) # 可以只传入必选参数 person(\u0026#39;Jensen\u0026#39;, 22, city = \u0026#39;Hefei\u0026#39;, uni = \u0026#39;HFUT\u0026#39;) # 传入两个含参数名的参数 person(\u0026#39;Jensen\u0026#39;, 22, **info) # 将提前组装好的info解析传入 name: Jensen , age: 22 , otr: {} name: Jensen , age: 22 , otr: {'city': 'Hefei', 'uni': 'HFUT'} name: Jensen , age: 22 , otr: {'city': 'HFE', 'major': 'Computer Science'} 命名关键字参数 若要限制关键字参数的名字，只接收city和job作为关键字参数，需要在函数的参数表中添加一个分隔符*，分隔符后面的参数被视为命名关键字参数：\ndef person(name, age, *, city, uni): # 分隔符*后面的参数即为命名关键字参数 print(\u0026#34;name: \u0026#34;, name, \u0026#34;, age: \u0026#34;, age, \u0026#34;, city: \u0026#34;, city, \u0026#34;, uni: \u0026#34;, uni) 如果函数参数表中已经有了一个可变参数，则后面跟着的命名关键字参数就不再需要加一个分隔符*了：\ndef person(name, age, *args, city, uni): # 已有可变参数，不需要再加分隔符 print(\u0026#34;name: \u0026#34;, name, \u0026#34;, age: \u0026#34;, age, \u0026#34;, city: \u0026#34;, city, \u0026#34;, uni: \u0026#34;, uni) print(\u0026#34;\\nargs: \u0026#34;, args) 命名关键字参数必须传入参数名，否则Python解释器将会将其视为位置参数，而出现报错。\n命名关键字参数也可以有缺省值（默认值），调用时可不传入。\n参数组合 在Python中定义函数，上述几种参数都可以组合使用，顺序必须遵循：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。但是并不建议使用太多组合，否则函数接口的可读性很差：\ndef final(a, b, c = 0, *args, d, **kw): print(\u0026#34;a: \u0026#34;, a, \u0026#34;, b: \u0026#34;, b , \u0026#34;, d: \u0026#34;, d, \u0026#34;, args: \u0026#34;, args, \u0026#34;, d: \u0026#34;, d, \u0026#34;, kw: \u0026#34;, kw) final(1, 2, 3, 4, d = 5, name = \u0026#39;final function\u0026#39;) a: 1 , b: 2 , d: 5 , args: (4,) , d: 5 , kw: {'name': 'final function'} 递归函数 在Python函数体内部调用自身本身，这个函数即为递归函数。例子：阶乘函数：\ndef fact(n): if n == 1: # 只有当n==1时需要特殊处理 return 1 return n * fact(n - 1) fact(1), fact(10) (1, 3628800) 使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过内存中的栈这种数据结构实现的，每进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈中就会减一层栈帧。由于栈的大小有限，因此递归次数过多会导致栈溢出。比如运行fact(10000)，Python解释器会抛错RecursionError: maximum recursion depth exceeded in comparison。\n可以通过尾递归优化解决递归调用栈溢出。尾递归是指函数返回时调用自身本身，并且return语句不能包含表达式。这样无论递归本身调用多少次，都只占用一个栈帧，不会出现栈溢出的问题。上面的fact函数的return语句使用了乘法表达式，因此不是尾递归：\ndef fact(n): return fact_iter(n, 1) def fact_iter(num, product): if num == 1: return product return fact_iter(num - 1, num * product) fact(10) # 执行fact(10000)依旧会报错 3628800 可以发现，上面改进的fact函数仅返回递归函数本身，num - 1和num * product在函数调用前就会被计算，不影响函数调用。遗憾的是，包括Python在内的大多数编程语言都没有对尾递归做优化，因此即便有改进的fact函数也会导致栈溢出，比如执行fact(10000)，Python解释器依旧会抛出RecursionError的错误。\nPython高级特性 切片 取一个list或tuple的前三个元素，使用Python提供的切片功能，一行就可以完成：\nnames = [\u0026#39;Jensen\u0026#39;, \u0026#39;Eric\u0026#39;, \u0026#39;Jerry\u0026#39;, \u0026#39;Anderson\u0026#39;, \u0026#39;Taylor\u0026#39;] names[0:3] # 输出 [\u0026#39;Jensen\u0026#39;, \u0026#39;Eric\u0026#39;, \u0026#39;Jerry\u0026#39;] names[0:3]表示从索引0处开始取直到索引3为止，但却不包括索引3。即索引为0，1，2正好三个元素，如果开始的索引是0则可以省略，如names[:3]。（小技巧：可以通过names[:]原样复制整个列表）\n类似的，Python也支持取倒数切片，如取最后一个元素names[-1]，取后三个元素names[-3:]。\n切片操作很有用，先创建一个0-99的列表：\nL = list(range(100)) 可以通过切片操作轻松去除某一段子列表：\nL[:10] # 取前十个元素；输出：[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] L[-10:] # 取后十个元素；输出：[90, 91, 92, 93, 94, 95, 96, 97, 98, 99] L[25:35] # 取第25-35个元素；输出：[25, 26, 27, 28, 29, 30, 31, 32, 33, 34] L[:10:2] # 前十个元素间隔一个取一个；输出：[0, 2, 4, 6, 8] L[::10] # 所有元素，每间隔10个取一个；输出：[0, 10, 20, 30, 40, 50, 60, 70, 80, 90] [0, 10, 20, 30, 40, 50, 60, 70, 80, 90] 字符串也可以视作一种list，其中的每个元素就是字符串中的每个字符。因此，字符串也可以使用切片操作，得到的子列表依然是字符串。\n（上述操作，对于元组Tuple均使用，Tuple和List非常类似，但是Tuple一旦初始化就不能修改。）\n迭代 若给定一个list或tuple，可以通过循环来遍历它们，这种遍历就是迭代。在Python中使用for ... in来完成迭代，不仅可以用在list或tuple上，还可以作用在其他可迭代对象（如dict）上：\nd = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3} for key in d: print(key) # 输出：a, b, c，默认迭代dict的key 迭代dict时，默认是迭代key，若要迭代value可以用for value in d.values()，若要同时迭代key和value，可以用for k, v in d.items()。上文提到了字符串也可以视作一种列表，因此也可作用于for循环。简而言之无论是list还是其他数据类型，只要是可迭代对象，for循环就可以正常运行。\n可以通过collections.abs模块的Iterable类型判断：\nfrom collections.abc import Iterable isinstance(\u0026#39;abc\u0026#39;, Iterable) # str是否可迭代？ True isinstance(123, Iterable) # int是否可迭代？ False isinstance([1, 2, 3], Iterable) # list是否可迭代？ True 可以使用Python内置的enumerate函数把一个list变成索引-元素对，从而可以在for循环中同时迭代索引和元素本身，这种用法在PyTorch的train loop中十分常见：\nL = [100, \u0026#39;Jensen\u0026#39;, 99, \u0026#39;Eric\u0026#39;, 98] # 不仅仅作用于list，其他可迭代对象如字符串、元组都适用 for idx, value in enumerate(L): print(idx, value) # 会同时打印索引和列表中的元素值 0 100 1 Jensen 2 99 3 Eric 4 98 上面的for循环同时引用了两个变量，这在Python中十分常见：\nfor x, y in ((1, 2), (2, 3), (3, 4)): print(x, y) 1 2 2 3 3 4 列表生成器 列表生成式是Python内置的简单却强大的创建list的生成器，例子：生成list([1, 2, 3, 4, 5, 6, 7, 8, 9])可以用list(range(1, 10))简单生成。\n若要生成[1*1, 2*2, ..., 100*100]的列表怎么办？可以使用列表生成式[x * x for x in range(1, 101)]。\nfor循环后面还可以加上if判断，可以筛选出仅偶数的平方[x * x for x in range(1, 101) if x % 2 == 0]。\n还可以使用两层循环，生成全排列：\n[m + n for m in \u0026#39;ABC\u0026#39; for n in \u0026#39;XYZ\u0026#39;] # 两层全排列，三层及以上的循环就很少用到了 ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] 运用列表生成式可以写出非常简洁的代码，例子：列出当前目录下的所有文件和目录名：\nimport os [dir for dir in os.listdir(\u0026#39;.\u0026#39;)] ['Functions.ipynb', '.ipynb_checkpoints', 'Advanced Feature.ipynb'] 上文提到for循环可以同时引用两个变量，因此列表生成式也可以使用多个变量来生成list：\nd = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;:2 , \u0026#39;c\u0026#39;: 3} [k + \u0026#39;=\u0026#39; + v for k, v in d.items()] # 输出：[\u0026#39;a=1\u0026#39;, \u0026#39;b=2\u0026#39;, \u0026#39;c=3\u0026#39;] if\u0026hellip;else 在一个列表生成式中，for前面的if ... else是表达式必须要带else子句，而for后面的if是过滤条件，不能带else。\n如执行[x for x in range(1, 11) if x % 2 == 0 else 0]会报错，执行[x if x % 2 == 0 for x in range(1, 11)]也会报错，然而执行下面这行则运行正常：\n[x if x % 2 == 0 else 0 for x in range(1, 11)] # for前面的if ... else是表达式必须要带else子句 [0, 2, 0, 4, 0, 6, 0, 8, 0, 10] 生成器 若创建了一个十分庞大的列表，但仅仅需要访问其中的几个元素，那么这个列表占用的很多空间都白白浪费了。在Python中可以使用一种边循环边计算的机制：生成器。生成器可以使得列表元素按照某种算法推算出来，不必创建完整的list。\n创建生成器的方法有多种，首先把一个列表生成器的[]换成()就创建了一个生成器g = (x * x for x in range(1, 10))。可以通过next函数将生成器中的每个元素依次打印出来。\n因为生成器保存的是算法，每次调用next函数就计算生成器的下一个元素值，直到计算到最后一个元素后抛出StopIteration的错误。但是一直调用next的方式实在是太傻了，由于生成器也是可迭代对象，可以使用for循环：\ng = (x * x for x in range(1, 10)) for i in g: print(i) 1 4 9 16 25 36 49 64 81 若需要推算的算法十分复杂，无法使用列表生成式实现时，可以使用函数来实现，例如斐波那契数列函数：\ndef fib(max): n, a, b = 0, 0, 1 while n \u0026lt; max: print(b) a, b = b, a + b n += 1 return \u0026#39;done\u0026#39; 上面的函数可以输出斐波那契数列的前N个数，可以从第一个元素开始推算出后续任意元素，这种逻辑非常类似生成器。要把fib函数变成生成器，只需要把print(b)改成yield b就好了：\ndef fib(max): n, a, b = 0, 0, 1 while n \u0026lt; max: yield b # 将print(b)改成yield b a, b = b, a + b n += 1 return \u0026#39;done\u0026#39; fib(10) # 输出： \u0026lt;generator object fib at 0xXXXXX\u0026gt;，说明fib(10)是一个生成器 \u0026lt;generator object fib at 0x7f38c9d9ade0\u0026gt; 但是生成器与普通函数执行流程不一样，普通函数是顺序执行，执行到return或者最后一行后返回，而生成器在每次调用next函数时执行，遇到yield语句返回，下次执行时再从上次返回的yield处继续执行，例子：\n（注意：多次调用生成器会生成多个相互独立的生成器对象。）\ndef odd(): print(\u0026#39;step 1\u0026#39;) yield 1 print(\u0026#39;step 2\u0026#39;) yield 3 print(\u0026#39;step 3\u0026#39;) yield 5 o = odd() next(o) # 输出：step 1；返回：1 next(o) # 输出：step 2；返回：3 next(o) # 输出：step 3；返回：5 此时后面已经没有yield可以执行了，再调用就会抛“StopIteration”错 step 1 step 2 step 3 5 生成器对象创建好后，可以使用for循环迭代，但会发现for循环拿不到生成器return返回的值，因此必须捕获StopIteration错误，返回值就包含在StopIteration的value中：\ng = fib(10) while True: try: x = next(g) print(\u0026#39;g: \u0026#39;, x) except StopIteration as e: print(\u0026#39;Generator return value: \u0026#39;, e.value) break g: 1 g: 1 g: 2 g: 3 g: 5 g: 8 g: 13 g: 21 g: 34 g: 55 Generator return value: done 迭代器 根据上文可发现可以直接作用于for循环的数据类型有：\n集合数据类型：如list、tuple、dict、set、str等； 生成器； 上述这些可直接作用于for循环的对象被统称为可迭代（Iterable）对象，可以使用isinstance函数判断一个对象是否是可迭代对象：isinstance([], Iterable)。\n可以被next函数调用并不断返回下一个值的对象成为迭代器（Iterator），也可以使用isinstance函数判断一个对象是否是迭代器对象：isinstance([], Iterator)。\n因此，生成器即是可迭代对象，也是迭代器。但是list、dict、str等虽然是可迭代对象，但不是迭代器，可以使用iter函数把它们变成迭代器。\nIterator的计算是惰性的，只有在需要返回下一个数据时它才会计算，本质上Python的for循环就是通过不断调用next函数实现的。\n函数式编程 高阶函数 变量可以指向函数 如果把函数本身赋值给变量f = abs，此时变量f已经指向了abs函数本身，调用f()和调用abs()完全相同。\n函数名也是变量 函数名其实就是指向函数的变量，对于abs函数，完全可以把其函数名看作是变量，只是指向一个可以计算绝对值的函数。如果abs = 100即将abs指向100，那就无法再通过abs调用求绝对值函数了，实际代码中绝不允许这样写。\n传入函数 既然变量可以指向函数，函数的参数能够接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就叫做高阶函数：\ndef add(x, y ,f): return f(x) + f(y) 当调用abs(-6, 5, abs)时，参数x、y、f分别接收-6、5和abs。\nmap \u0026amp; reduce map函数接收两个参数，一个是函数另一个时可迭代对象，map将传入的函数依次作用在可迭代对象的每个元素上，并把结果作为新的迭代器对象返回。例子：将一个求二次方的函数作用在一个列表上：\ndef f(x): return x * x m = map(f, [1, 2, 3, 4 ,5, 6, 7, 8]) # 求二次方函数作用在列表中的每一个元素上 list(m) [1, 4, 9, 16, 25, 36, 49, 64] map作为一个高阶函数，将运算规则抽象化，不但可以简单地求二次方，还可以计算任意复杂的函数，如把列表中的元素全都转换为字符list(map(str, [1, 2, 3, 4, 5, 6, 7, 'A', 'B']))。\nreduce函数也是接收一个函数和一个可迭代对象。reduce把函数作用在可迭代对象上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，如：reduce(f, [x, y, z, k]) = f(f(f(x, y), z), k)。\n例子：对一个列表序列求和：\nfrom functools import reduce def add(x, y): return x + y reduce(add, [2, 5, 6, 7, 5]) # 相当于 add(add(add(add(2, 5), 6), 7), 5) 25 例子：将字符串转换为整数：\nfrom functools import reduce DIGITS = {\u0026#39;0\u0026#39;: 0, \u0026#39;1\u0026#39;: 1, \u0026#39;2\u0026#39;: 2, \u0026#39;3\u0026#39;: 3, \u0026#39;4\u0026#39;: 4, \u0026#39;5\u0026#39;: 5, \u0026#39;6\u0026#39;: 6, \u0026#39;7\u0026#39;: 7, \u0026#39;8\u0026#39;: 8, \u0026#39;9\u0026#39;: 9} def str2int(s): def fn(x, y): return x * 10 + y def char2num(s): return DIGITS[s] return reduce(fn, map(char2num, s)) str2int(\u0026#39;2021111052\u0026#39;) 2021111052 上述str2int函数还可以进一步使用lambda函数简化为：\nfrom functools import reduce DIGITS = {\u0026#39;0\u0026#39;: 0, \u0026#39;1\u0026#39;: 1, \u0026#39;2\u0026#39;: 2, \u0026#39;3\u0026#39;: 3, \u0026#39;4\u0026#39;: 4, \u0026#39;5\u0026#39;: 5, \u0026#39;6\u0026#39;: 6, \u0026#39;7\u0026#39;: 7, \u0026#39;8\u0026#39;: 8, \u0026#39;9\u0026#39;: 9} def str2int(s): return reduce(lambda x, y: x * 10 + y, map(lambda x: DIGITS[x], s)) # 运用lambda表达式可以简化函数 str2int(\u0026#39;13579\u0026#39;) 13579 filter Python内置的filter函数用于过滤可迭代对象中的元素，与上文类似，filter函数也接收一个函数和一个可迭代序列，将传入的函数依次作用于序列中的每个元素，根据返回值是True或False来决定保留还是丢弃该元素。例如删掉一个列表中的奇数，只保留偶数：\ndef odd(n): return n % 2 == 0 list(filter(odd, [2, 5, 6, 7, 5, 0, 1, 3, 9])) # 结果： [2, 6, 0] 例子：删去一个列表中的空字符串：\ndef not_empty(s): return s and s.strip() list(filter(not_empty, [\u0026#39;A\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;C\u0026#39;, None])) # 与map/reduce类似，filter返回的是迭代器对象，需要用list()获得所有结果 ['A', 'C'] sorted Python内置的sorted函数可以对可迭代对象进行排序，与上述几种高姐函数不同，sorted函数直接返回一个列表。\nsorted一般接收一个可迭代对象作为参数，还可以再接收一个key函数来实现自定义的排序，如按绝对值大小排序：sorted([2, 5, 6 ,7, 9, 0, -3, -11], key = abs)。key指定的函数将作用于列表的每一个元素上，sorted根据key指定的函数返回的结果进行排序。\n例子：对字符串进行排序：\nsorted([\u0026#39;Jensen\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39;eric\u0026#39;, \u0026#39;yiming\u0026#39;]) # 默认依照ASCII的大小顺序排列，ASCII码中，\u0026#39;J\u0026#39; \u0026lt; \u0026#39;B\u0026#39; \u0026lt; \u0026#39;e\u0026#39; \u0026lt; \u0026#39;y\u0026#39; ['Bob', 'Jensen', 'eric', 'yiming'] 有些时候按照ASCII码排序不太直观，按照字母序排序更合适：\nsorted([\u0026#39;Jensen\u0026#39;, \u0026#39;Bob\u0026#39;, \u0026#39;eric\u0026#39;, \u0026#39;yiming\u0026#39;], key = str.lower) # 把字符串全变成小写或者大写(str.upper)即可 若要按照字母序逆序排列，不必改动key函数，仅需传入第三个参数reverse = True即可：sorted(['Jensen', 'Bob', 'eric', 'yiming'], key = str.lower, reverse = True)。\nd = {\u0026#39;A\u0026#39;: \u0026#39;America\u0026#39;, \u0026#39;C\u0026#39;: \u0026#39;China\u0026#39;, \u0026#39;R\u0026#39;: \u0026#39;Russia\u0026#39;} sorted(d.values()) # 对字典的值进行排序，返回列表：[\u0026#39;America\u0026#39;, \u0026#39;China\u0026#39;, \u0026#39;Russia\u0026#39;] ['America', 'China', 'Russia'] 返回函数 函数作为返回值 高阶函数除了可以接受函数作为参数之外，还可以把参数作为结果值返回。通常情况下，求和函数：\ndef calc_sum(*nums): ax = 0 for n in nums: ax += n return ax 如若不需要立即求和，而是像Swift语言中的延迟加载，需要用到的时候再计算，则可以不返回求和的结果，而是返回求和函数：\ndef lazy_sum(*nums): def sum(): ax = 0 for n in nums: ax += n return ax return sum f = lazy_sum(1, 3, 4, 5, 7 ,9) # 此时调用lazy_sum函数返回的并不是求和结果，而是求和函数 f() # 执行求和函数得到结果 29 上面的例子中需要注意，每次调用lazy_sum函数时都会返回一个新的独立的求和函数，它们的调用互不影响。内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum函数返回sum时，相关参数和变量都保存在返回的sum函数中，这种程序结构被称为“闭包”。\n闭包 当一个函数返回一个函数后，其内部的局部变量还被返回的函数所引用，这种模式就称为“闭包”。需要注意的是，返回的函数并没有立刻执行，而是直到被调用才执行。返回闭包时请牢记一点，即返回函数不要引用任何循环变量，或者后续会发生变化的变量：\ndef count(): fs = [] for i in range(1, 4): def f(): return i * i fs.append(f) return fs f1, f2, f3 = count() # 直觉上看，f1、f2、f3应当依次返回1，4，9 f1(), f2(), f3() # 但实际上三个返回的均是9 (9, 9, 9) 调用上述f1、f2和f3函数返回的结果均为9，其原因是返回函数引用了变量i，但是并没有立即执行，而是等三个函数都返回时再被调用执行，此时所引用的变量i已经变成了3，所以最终结果变成了9。若一定要引用循环变量，可以再在创建一个函数，用该函数的参数绑定循环变量当前的值：\ndef count(): def f(j): return lambda: j * j # 绑定此时的j值 fs = [] for i in range(1, 4): fs.append(f(i)) # f(i)立即执行，因此当前的i值被传入被绑定 return fs f1, f2, f3 = count() f1(), f2(), f3() (1, 4, 9) nonlocal 使用闭包时，如果内层函数只是读外层函数的局部变量，那似乎没有什么问题：\ndef inc(): x = 0 def fn(): return x + 1 # 仅读取外层局部变量x return fn f = inc() print(f()) # 输出：1 print(f()) # 输出：1 但是如果对外层变量赋值，Python解释器会把x视作fn函数的局部变量，但又因x作为内层函数的局部变量并没有进行初始化，所以会报错。\n若对外层变量赋值，实际上是想引用外层函数的局部变量x，所以需要在fn函数内部加一个nolocal x的声明：\ndef inc(): x = 0 def fn(): nonlocal x # 如果注释这行，Python解释器则会将x视为fn函数内部的局部变量 x += 1 return x return fn f = inc() print(f()) print(f()) 1 2 匿名函数 Lambda 上文已经多次用到了匿名函数即Lambda表达式，有些时候传入函数时，不需要显式地定义函数，直接传入匿名函数更方便。比如匿名函数lambda x: x * x实际上就是：\ndef f(x): return x * x 关键字lambda表示匿名函数，冒号前的x表示函数参数。匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。\n匿名函数也是函数对象，也可以像函数一样，将匿名函数赋值给一个变量，再利用变量来调用该函数；同样，也可以把匿名函数作为返回值返回。\n装饰器 装饰器可以增强函数的功能，比如在调用某个函数前后自动打印日志，但又不希望修改函数的本体，这种在代码运行期间动态增加功能的方式被称为装饰器。例子：定义一个能打印日志的装饰器：\ndef log(func): def wrapper(*args, **kw): print(\u0026#39;call %s():\u0026#39; % func.__name__) # .__name__属性存储了函数的名称 return func(*args, **kw) return wrapper @log # 装饰器 def date(): print(\u0026#39;2021-12-11\u0026#39;) date() # 调用date函数不仅会运行函数本身，还会在函数输出前打印一行日志 call date(): 2021-12-11 观察上面的log函数，因其是一个装饰器，所以接收一个函数作为参数，并返回一个函数。可以借助Python的@语法讲装饰器置于函数date的定义处，调用date时，不仅会允许其本身，还会在其输出前打印一行日志。\n把@log放到date函数的定义处相当于执行了语句date = log(date)。\nwrapper函数的参数定义是(*args, **kw)，因此wrapper函数可以接受任意参数的调用。在wrapper函数内首先打印日志，再紧接着调用传入的原始函数。\n如果装饰器本身需要传入参数，那就要用上述提到的闭包方法返回一个装饰器函数，比如一个自定义log文本的装饰器函数：\ndef log(text): # 接收自定义log文本 def decorator(func): # @functools.wraps(func) # 取消注释可以将原始func函数中的属性复制到wrapper函数中，下文介绍 def wrapper(*args, **kw): print(\u0026#39;%s %s(): \u0026#39; % (text, func.__name__)) return func(*args, **kw) return wrapper # 闭包 return decorator # 闭包 @log(\u0026#39;excute\u0026#39;) # 传入参数的装饰器 def date(): print(\u0026#39;2021-12-11\u0026#39;) date() # 相当于执行了date = log(\u0026#39;excute\u0026#39;)(date)，即参数是date函数，返回wrapper函数 excute date(): 2021-12-11 上述两种装饰器的定义都没有问题，上文提到__name__属性存储了函数的名称，但是经过装饰器装饰的函数，其__name__属性都发生了变化，执行date.__name__会发现输出不再是date而是wrapper，因为上述代码返回的是wrapper函数。\n因此，需要使用Python内置的functools.wraps函数把原始date函数的属性复制到wrapper函数中，否则一些依赖函数签名的代码执行就会出错：\nimport functools def log(func): @functools.wraps(func) # 可以将原始func函数中的属性复制到wrapper函数中 def wrapper(*args, **kw): print(\u0026#39;call %s(): \u0026#39; % func.__name__) return func(*args, **kw) return wrapper @log def date(): print(\u0026#39;2021-12-11\u0026#39;) date.__name__ 'date' 偏函数 所谓偏函数即把一个函数的某些参数给固定住（设置默认值），返回一个新的函数，使得函数调用更加简单，在Python中可以使用内置的functools.partial轻松实现。当函数的参数个数太多时，可以通过此方法固定部分参数简化调用。\n众所周知int函数可以将字符串转换为整数，当仅传入字符串时，int函数默认按照十进制转换。但是还可以给int函数传入额外的base参数（其默认值为10）来实现进制转换：\nint(\u0026#39;25675\u0026#39;, base=16) # 将‘25675’转换为十六进制整数 153205 假如要经常使用十六进制转换，上述写法不免显得多余，可以使用functools.partial函数创建一个偏函数：\nimport functools int16 = functools.partial(int, base=16) # int16函数直接可以将字符串转换为十六进制整数 int16(\u0026#39;25675\u0026#39;) 153205 Python内置的functools.partial函数实际上可以接收函数对象、可变参数和关键字参数三种类型的参数，所以上述functools.partial(int, base=16)中的base参数实际上是关键字参数。\n下面是使用可变参数的max函数的偏函数：\nimport functools max2 = functools.partial(max, 10, -11) # 10和-11组成了可变参数 max2(19) # 相当于执行max(10, -11, 19) # 也可以如下写法，具体参考函数那一节： # nums = [10, -11] # max2 = functools.partial(max, *nums) 19 面向对象编程 类和实例 面向对象最重要的概念就是类和实例，以Student类为例，在Python中，定义类是通过class关键字：\nclass Student(object): pass class后面紧跟着类名即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的。通常如果没有合适的继承类就默认继承object类，这是所有类最终都会继承的类。\n定义好一个类之后就可以根据类创建出相应的实例，创建实例是通过类名+()实现的：\nclass Student(object): # 默认继承Object类 pass stu = Student() # stu是Student类的一个实例 stu, Student (\u0026lt;__main__.Student at 0x7ff5c8788d30\u0026gt;, __main__.Student) 执行上一个block语句会发现，变量stu指向的就是一个Student实例，后面的0x......是实例在内存中的地址，每一个实例的地址都不一样，而Student本身则是一个类。\n可以自由的给一个实例变量绑定属性如stu.name = 'Jensen'。通常情况下会使用__init__构造函数在创建实例的时候就把一些必须绑定的属性强制传入：\nclass Student(object): def __init__(self, name, score): # 第一个参数永远是self即代表实例本身，不需要手动传入 self.name = name self.score = score stu = Student(\u0026#39;Jensen\u0026#39;, 100) # 构造实例时会自动调用构造函数，又构造函数后创建实例就不能传入空参数，必须传入构造函数匹配的参数（self不用传） stu.name, stu.score ('Jensen', 100) 数据封装 面向对象编程中一个非常重要的概念就是数据封装。在上面的Student类中，每个实例就拥有各自的name和score这些数据，可以通过函数来访问这些数据：\ndef print_score(stu): print(\u0026#39;%s: %s\u0026#39; % (stu.name, stu.score)) 可以将print_score函数封装在Student内部，这样就把数据封装起来了，这些封装数据的函数和类本身是相关联的被称为累的方法：\nclass Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): # 类的方法必须要有self参数 print(\u0026#39;%s: %s\u0026#39; % (self.name, self.score)) stu = Student(\u0026#39;Jensen\u0026#39;, 20) stu.print_score() Jensen: 20 访问限制 上一个block中，虽然数据已经封装在类内部，但是外部代码还是可以直接调用实例变量修改数据的值：stu.name = 'Shen Yiming'，这样会使得数据变得不可靠。\n如果要让内部属性不可以被外部代码直接访问，可以在属性的名称前加上两个下划线__，使属性变成类的私有属性，只可以被类的方法访问，外部代码无法访问，通过访问限制保护，使得代码更加健壮：\nclass Student(object): def __init__(self, name, score): self.__name = name # 属性变量名前加两个下划线__，即私有属性 self.__score = score def print_score(self): print(\u0026#39;%s: %s\u0026#39; % (self.__name, self.__score)) stu = Student(\u0026#39;Jensen\u0026#39;, 20) # stu.__name # 若执行此代码，则会报错没有__name属性 stu.print_score() Jensen: 20 如果此时又要允许外部代码有限制的修改内部数据，可以给Student类再添加一个set方法：\ndef Student(object): ... def set_name(self, name): # set方法，可以在方法体里添加一些参数检查，避免传入无效参数 self.__name = name def set_score(self, score): self.__score = score 需要注意的是，Python中还有很多变量名类似__XXX__，这些不是私有变量，而是特殊变量，是可以直接通过类名.XXX等方式直接访问的，所以不可以使用这些作为变量名。\n还有一些形如_name的变量名，这样的实例变量在外部是可以直接访问的，但这种写法希望你将其视为私有变量，不要随意访问。\n实际上，私有变量如__name在实例内部被改成了_Student__name，所以可以在外部通过stu._Student__name访问私有变量__name，但是强烈不建议这样做。\n请注意下面的错误用法：\nstu = Student(\u0026#39;Jensen\u0026#39;, 20) stu.__name = \u0026#39;Yiming\u0026#39; # 设置__name变量 上面的写法只是给实例变量stu绑定了一个__name属性，与类内部的私有变量__name没有任何关系，因为其已经被修改为_Student__name。\n继承和多态 在面向对象的程序设计中，定义一个类可以从某个现有的类继承，新定义的类被称为子类，而被继承的类被称为基类或父类、超类。\n继承最主要的用处就是子类获得了父类的全部功能：\nclass Animal(object): # 基类 def run(self): print(\u0026#39;Animal is running...\u0026#39;) class Dog(Animal): # 子类，继承自Animal类，自动获得Animal类的run方法 pass class Cat(Animal): pass 但是猫和狗继承自基类的run函数指代的范围太广泛了，子类可以重写基类的方法，仅需在子类中重新定义改方法即可：\nclass Animal(object): def run(self): print(\u0026#39;Animal is running...\u0026#39;) class Dog(Animal): def run(self): # 重写基类的run方法 print(\u0026#39;Dog is running...\u0026#39;) class Cat(Animal): def run(self): # 重写基类的run方法 print(\u0026#39;Cat is running...\u0026#39;) dog, cat = Dog(), Cat() dog.run() # 子类的run方法覆盖了父类的run，代码运行时总会调用子类的run方法 cat.run() Dog is running... Cat is running... 多态 多态即子类实例即属于子类本身，也属于子类所继承的基类：\na, b, c = list(), Animal(), Dog() print(isinstance(a, list)) # a是list类型 print(isinstance(b, Animal)) # b是Animal类型 print(isinstance(c, Dog)) # c是Dog类型 print(isinstance(c, Animal)) # c不仅是Dog类型，也是Animal类型 print(isinstance(b, Dog)) # b不是Dog类型 True True True True False 从上一个block的代码中可以发现，在继承关系中，如果一个实例的数据类型是某个子类，那他的数据类型也可被看作是基类。但是反过来却不行，如上面的b是Animal类型但却不是Dog类型。\n再看一个多态的例子：\nclass Animal(object): def run(self): print(\u0026#39;Animal is running...\u0026#39;) class Dog(Animal): def run(self): print(\u0026#39;Dog is running...\u0026#39;) class Cat(Animal): def run(self): print(\u0026#39;Cat is running...\u0026#39;) def run_twice(animal): animal.run() animal.run() run_twice(Animal()) # 正常打印 run_twice(Dog()) # 不需要对run_twice，任何依赖Animal作为参数的函数都可以不加修改正常运行，原因就在于多态 run_twice(Cat()) # 实际上，任何具有run方法的类的实例都可以传入正常运行 Animal is running... Animal is running... Dog is running... Dog is running... Cat is running... Cat is running... 对于一个变量，只需要知道它是Animal类型，无需确切地知道它的子类型就可以放心地调用run方法，而具体调用的run方法是作用在Animal、Dog还是Cat对象上，由运行时该对象的确切类型决定。调用方只管调用不管细节，而当新增一种Animal子类时，只需确保run方法编写正确，不用管原来的代码是如何调用的，这就是著名的开闭原则：\n对扩展开放：允许新增Animal子类； 对修改封闭：不需要修改依赖Animal类型的run_twice等函数； 继承还可以一级一级地继承下来，好比爷爷到爸爸、再到儿子这样的关系。而任何类最终都可以追溯到object类，这些继承关系看上去就像一颗倒着的树。\n静态语言 vs 动态语言 对于静态语言如Java来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run方法。\n对于Python这样的动态语言来说则不一定要传入Animal类型，如上文所说只需保证传入的对象有一个run方法就可以了。\n获取对象信息 可以用type函数来判断对象类型，基本类型都可以通过type函数判断：\nprint(type(123)) print(type(\u0026#39;Jensen\u0026#39;)) print(type(None)) # 如果一个变量指向函数或类，也可以用type函数判断 a = abs print(type(abs)) print(type(a)) # 变量指向函数 \u0026lt;class 'int'\u0026gt; \u0026lt;class 'str'\u0026gt; \u0026lt;class 'NoneType'\u0026gt; \u0026lt;class 'builtin_function_or_method'\u0026gt; \u0026lt;class 'builtin_function_or_method'\u0026gt; type返回的是对应的Class类型，在if语句中可以比较两个变量的type类型来进行判断：\n# type返回的是对应Class的类型，如str、int type(123) == type(456), type(\u0026#39;jensen\u0026#39;) == str, type(123) == str (True, True, False) 若需要判断一个对象是否是函数则可以使用Python内置的types模块中定义的常量：\nimport types def func(): pass type(func) == types.FunctionType # True. 自定义函数类型 type(abs) == types.BuiltinFunctionType # True. 内置函数类型 type(lambda x: x) == types.LambdaType # True. 匿名函数类型 type((x for x in range(10))) == types.GeneratorType # True. 生成器类型 使用isinstance() 对于类的继承关系来说，使用type函数就很不方便，如果要判断类的类型，可以使用isinstance函数：\na = Animal() # 基类 d = Dog() # 子类，基类是Animal h = Husky() # 子类，基类是Dog isinstance(h, Dog) # True isinstance(h, Animal) # True isinstance(d, Animal) # True isinstance(d, Husky) # False，子类属于基类类型，反过来不正确 能用type函数判断的基本类型也可以用isinstance函数判断：\nisinstance(\u0026#39;a\u0026#39;, str) # True isinstance(123, int) # True isinstance(func, types.FunctionType) # True，（详见上一个block） isinstance(b\u0026#39;a\u0026#39;, bytes) # True 还可以判断一个变量是否属于某些类型中的一种：\nisinstance([1, 2, 3], (list, tuple)) # True，[1, 2 ,3]属于(list, tuple)中的list isinstance(\u0026#39;jensen\u0026#39;, (str, int)) # True，\u0026#39;jensen\u0026#39;属于(str, int)中的str True 使用dir() 若想要获得一个对象的所有属性和方法可以使用dir函数，它返回一个包含字符串的list：\ndir(\u0026#39;Jensen\u0026#39;) ['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'] 前面提到形如__XXX__的属性和方法在Python中是有特殊用途的，比如__len__方法返回长度，在Python中可以使用len函数试图获取一个对象的长度，实际上就是调用该对象的__len__方法，所以len('Jensen')和'Jensen'.__len__()是等价的。\n当自己写类时若也想用len函数的话可以在类中写一个__len__方法：\nclass TestLen(object): def __len__(self): # 拥有这个方法后就可以使用len(TestLen) return 120 test = TestLen() len(test) 120 除此之外都是普通属性或方法，如'Jensen'.upper()即返回大写的字符串。\n可以通过getattr、setattr、hasattr等函数查看一个对象的状态：\nclass TestClass(object): def __init__(self, x): self.x = x def power(self): return self.x * self.x test = TestClass(9) hasattr(test, \u0026#39;x\u0026#39;) # True，是否有x属性 setattr(test, \u0026#39;y\u0026#39;, 10) # True，设置一个属性y，值为10 hasattr(test, \u0026#39;y\u0026#39;) # True，是否有y属性 getattr(test, \u0026#39;y\u0026#39;) # 10，获得y属性的值 # getattr(test, \u0026#39;z\u0026#39;) # 若取消注释，则会抛出AttributeError错误 getattr(test, \u0026#39;z\u0026#39;, 404) # 404，获取z属性的值，如果没有z属性则创建z属性并赋值404，再返回z属性的值 hasattr(test, \u0026#39;power\u0026#39;) # True，是否有power方法 func = getattr(test, \u0026#39;power\u0026#39;) # 将power方法赋给test变量 func() #81，调用func指向的函数，等价于test.power() 81 实例属性与类属性 由于Python是动态语言，所以根据类创建的实例可以任意绑定属性，可以通过实例变量或者self变量：\nclass Student(object): def __init__(self, name): self.name = name # 通过self变量绑定属性 s = Student(\u0026#39;Jensen\u0026#39;) s.score = 99 # 通过实例变量绑定属性 如果Student类本身需要绑定一个属性，可以在类中直接定义属性，这种属性称为类属性，归类所有：\nclass Student(object): name = \u0026#39;Students\u0026#39; 类属性可以通过类名直接访问Student.name，当类的实例没有name属性时也会调用类的name属性。当类的实例中有了和类属性同名的属性，那么实例属性则会覆盖类属性。所以编写程序时切勿将类属性和实例属性使用相同的名字。\n面向对象高级编程 正常情况下，创建一个类实例后可以给改实例绑定任何属性和方法，这就是动态语言的灵活性优势：\nclass Student(object): pass s = Student() s.name = \u0026#39;Jensen\u0026#39; # 动态地给实例绑定一个属性 还可以给实例动态地绑定一个方法：\nfrom types import MethodType def set_score(self, score): # 定义一个函数作为实例方法 self.score = score s.set_name = MethodType(set_name, s) # 动态地给实例绑定一个方法 当时上述方法很明显存在局限性即属性和方法只是绑定在实例s上，对于其他Student的实例是不起作用的，为了给所有的实例都绑定相应地属性和方法，可以选择绑定类属性和类方法：\ndef set_score(self, score): self.score = score Student.name = \u0026#39;NAME\u0026#39; # 给类绑定属性 Student.set_score = set_score # 给类绑定方法 s = Student(), s.set_score(99) # 给类绑定方法和属性后，所有类的实例都可调用 s.name # 输出\u0026#39;NAME\u0026#39; s.score # 输出99 动态语言允许在程序运行过程中动态的给类加上一些功能，这在Java等静态语言中是不可想象的。\n使用__slots__ 若想要限制实例的属性如只允许Student实例添加name和age属性，可以在定义类的时候定义一个特殊的_slots__变量以限制类实例能添加的属性：\nclass Student(object): __slots__ = (\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;) # 用元祖定义允许绑定的属性名称 s = Student() s.name = \u0026#39;Eric\u0026#39; # 绑定属性name s.age = \u0026#39;22\u0026#39; # 绑定属性age # s.score = 99 # 若取消注释则报AttributeError错 上个block中由于score没有被放置到__slots__中，所以实例无法绑定score属性，若强行绑定则会得到AttributeError错误。\n需要注意的是，__slots__定义的属性仅对当前类的实例起作用，而对于继承的子类是不起作用的，除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上基类的__slots__。\n使用@property 在绑定属性时，如果直接把属性暴露出去，虽然写起来十分的简单，但是，没有办法检查参数，比如s.score = 10000就显得十分不合理。可以在Student类的set_score方法中添加if语句来做判断，将score设置在0到100之间，但每次给score赋值都要调用set_score未免显得过于麻烦，不如直接给属性赋值来得方便。\n还记得前面提到的装饰器吗，可以使用Python内置的@property装饰器可以将一个方法变成属性调用：\nclass Student(object): @property # 将一个getter方法变成属性，此时@property本身又创建了一个装饰器@score.setter def score(self): return self._score @score.setter # 将一个setter方法变成属性赋值 def score(self, value): if not isinstance(value, int): raise ValueError(\u0026#39;Score must be an integer!\u0026#39;) if value \u0026lt; 0 or value \u0026gt; 100: raise ValueError(\u0026#39;Score must between 0 ~ 100!\u0026#39;) self._score = value s = Student() # s.score = 101 # 若取消注销，则会报错ValueError s.score = 90 # 实际上转化为调用s.set_score(90) s.score # 实际上转化为调用s.get_score() 90 还可以只定义只读属性，只定义getter方法而不定义setter方法就是一个只读属性，例如下面这个例子中，birth是可读写属性然而age就是一个只读属性：\nclass Student(object): @property def birth(self): return self._birth @birth.setter def birth(self, value): self._birth = value @property def age(self): return 2021 - self.birth 需要注意的是，属性的方法名不要和实例变量名重名：\nclass Student(object): @property def birth(self): return self.birth # 实例变量名和方法名重名 上面的代码会报RecursionError错，因为调用s.birth会默认转换为s.get_birth()调用，然而return self.birth也会转换为调用get_birth方法，因此会一直迭代下去，最终报错。\n多重继承 继承是面向对象编程的重要方式，因为通过继承，子类就可以拓展基类的功能。\n比如Animal类可能会有Dog和Bird等子类，但是Dog和Bird又能向下细分出好几类，Dog可能会有Hounds和Herdings等子类、Bird可能有Flyable和Runnable等子类。\n鸵鸟Ostrich既属于Bird类又属于Runnable类，若要一层一层写继承关系实在太复杂，在Python中允许有多重继承关系即MixIn：\nclass Ostrich(Bird, Runnable): # Ostrich类同时继承了Bird类和Runnable类 pass 这样一来，不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。\n定制类 前面已经提到了__slots__和__len__等特殊方法的用法了，除此之外，Python的类中还内置能很多其他的特殊函数可以帮助定制类。\n__str__ 正常在打印一个类的实例时，总会打印出来一串看起来不好看的字符如\u0026lt;__main__.Student object at 0xXXXXX\u0026gt;，如何才能将输出格式化，只需在类的内部定义好__str__方法就可以了：\nclass Student(object): def __init__(self, name): self.name = name def __str__(self): return \u0026#39;Student object (name: %s)\u0026#39; % self.name print(Student(\u0026#39;Jensen\u0026#39;)) # 打印输出\u0026#34;Student object (name: Jensen)\u0026#34; Student(\u0026#39;Jensen\u0026#39;) # 在交互界面下打印出来的还是和之前的一样，这是因为交互界面调用的是__repr__方法 上述代码在交互界面下直接打印还是会和之前一样，得到的结果非常不美观，此时在类中__str__方法块后面加上__repr__ = __str__就可以了。\n__iter__ 若想一个类被用于for...in循环中，类似列表那样，可以在类中实现一个__iter__方法，让类实例变成可迭代对象，然后Python的for循环就会不断调用该对象的__next__方法拿到循环的下一个值，直到遇到StopIteration退出循环，如斐波那契数列：\nclass Fib(object): def __init__(self): self.a, self.b = 0, 1 def __iter__(self): return self # 实例本身就是迭代对象，故返回自己 def __next__(self): self.a, self.b = self.b, self.a + self.b # 计算后续值 if self.a \u0026gt; 100000: # 退出循环的条件 raise StopIteration() return self.a # 返回下一个值 for n in Fib(): # 在循环中迭代Fib实例 print(n) 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 __getitem__ Fib实例虽然可以作用于for循环，看起来有点像list，但是list可以根据索引取值，然而Fib实例还不行，需要在类中实现__getitem__方法，例子：简单的可通过下标获取元素的斐波那契数列：\nclass Fib(object): def __getitem__(self, n): a, b = 1, 1 for x in range(n): a, b = b, a + b return a f = Fib() f[10] # 输出89，可以通过下标索引获得第11个元素的值 但是上面的代码并不支持list中的切片语法即f[5:10]，因为__getitem__传入的参数可能是int也可能是slice，要对这两种参数做判断：\nclass Fib(object): def __getitem__(self, n): if isinstance(n, int): # 若参数为整型 a, b = 1, 1 for x in range(n): a, b = b, a + b return a if isinstance(n, slice): # 若参数为切片 start = n.start # 获取切片的起点索引 end = n.stop # 获取切片的终点索引 if start is None: start = 0 # 若起点索引为空，则设置为0 L = [] a, b = 1, 1 for x in range(end): if x \u0026gt;= start: L.append(a) a, b = b, a + b return L f = Fib() f[10] # 输出 89 f[:5] # 输出 [1, 1, 2, 3, 5] f[5:10] # 输出 [8, 13, 21, 34, 55] [8, 13, 21, 34, 55] 但是上面block的代码还是不够完善，比如没有对step参数作处理即f[:10:2]，也没有对负数索引作处理，所以要用__getitem__完整地复刻list的功能还有很多工作要做。\n若想把对象视为dict，那么__getitem__的参数也可能是一个作为key的对象如str，与之对应的是__setitem__方法，可以将对象视作list或dict来对其赋值。最后还有一个__delitem__方法，用于删除某个元素。\n__getattr__ 上文提到，当调用的类的方法或属性不存在时就会报AttirbuteError错，避免这个错误除了给类添加一个score属性之外，还可以写一个__getattr__方法动态地返回一个属性：\nclass Student(object): def __init__(self): self.name = \u0026#39;Jensen\u0026#39; def __getattr__(self, attr): if attr == \u0026#39;score\u0026#39;: # 若参数名为score return 99 # 返回 99 if attr == \u0026#39;age\u0026#39;: # 若参数名为age return lambda: 22 # 返回匿名函数 raise AttributeError(\u0026#39;\\\u0026#39;Student\\\u0026#39; object has no attribute \\\u0026#39;%s\\\u0026#39;\u0026#39; % attr) # 调用其他参数均报错 s = Student() s.name # 输出 \u0026#39;Jensen\u0026#39; s.score # 输出 99 s.age() # 输出 22，调用匿名函数 __call__ 一个对象实例可以有自己的属性和方法，可通过instance.method()的形式来调用，若想直接用instance()的形式来调用，在Python中可以在类中重写__call__方法来实现：\nclass Student(object): def __init__(self, name): self.name = name def __call__(self): print(\u0026#39;My name is %s.\u0026#39; % self.name) s = Student(\u0026#39;Jensen\u0026#39;) s(). # 打印输出 \u0026#39;My name is Jensen.\u0026#39; __call__方法还可以定义参数，对实例进行直接调用就像对一个函数进行调用一样，所以完全可以把对象看成函数，因为函数和对象二者之间本来就没啥根本的区别。\n可以通过callable方法判断一个变量是否是可以被调用的：\ncallable(max) # True，max函数可以被调用 callable(None) # False，None不可以被调用 callable(\u0026#39;hello\u0026#39;) # False，字符串不可以被调用 callable(Student()) # True，若去掉上面Student类代码中的__call__方法后就会变成不可调用即False 使用枚举类 当需要定义常量时，一般会用大写变量通过整数来定义比如JAN = 1, FEB = 2, ...，虽然定义起来十分简单但缺点是类型依然是int变量。在Python中可以用内置的Enum类为这样的枚举类型定义一个类型，每个常量都是类的唯一实例：\nfrom enum import Enum Month = Enum(\u0026#39;Month\u0026#39;, (\u0026#39;Jan\u0026#39;, \u0026#39;Feb\u0026#39;, \u0026#39;Mar\u0026#39;, \u0026#39;Apr\u0026#39;, \u0026#39;May\u0026#39;, \u0026#39;Jun\u0026#39;, \u0026#39;Jul\u0026#39;, \u0026#39;Aug\u0026#39;, \u0026#39;Sep\u0026#39;, \u0026#39;Oct\u0026#39;, \u0026#39;Nov\u0026#39;, \u0026#39;Dec\u0026#39;)) # Month类型的枚举类，可以Month.Jan来引用一个常量 for name, member in Month.__members__.items(): # 可以枚举其所有成员，value是默认自动赋给成员的int常量，默认从1开始计数 print(name, \u0026#39; ==\u0026gt; \u0026#39;, member, \u0026#39;, \u0026#39;, member.value) 也可以从Enum类派生出自定义类：\nfrom enum import Enum, unique @unique # @unique可以检查确保没有重复值 class Weekday(Enum): Sun = 0 # Sun的value被设置为0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6 # 访问这些枚举类型有若干种方法： day1 = Weekday.Mon print(day1) print(Weekday.Tue) print(Weekday[\u0026#39;Wed\u0026#39;]) print(Weekday.Sun.value) print(Weekday(6)) print(day1 == Weekday.Mon) print(Weekday.Mon == Weekday[\u0026#39;Fri\u0026#39;]) # Weekday(7) # 若取消注释会报ValueError错，因为没有枚举类型的value为7 for name, member in Weekday.__members__.items(): print(name, \u0026#39; ==\u0026gt; \u0026#39;, member, \u0026#39;, \u0026#39;, member.value) Weekday.Mon Weekday.Tue Weekday.Wed 0 Weekday.Sat True False Sun ==\u0026gt; Weekday.Sun , 0 Mon ==\u0026gt; Weekday.Mon , 1 Tue ==\u0026gt; Weekday.Tue , 2 Wed ==\u0026gt; Weekday.Wed , 3 Thu ==\u0026gt; Weekday.Thu , 4 Fri ==\u0026gt; Weekday.Fri , 5 Sat ==\u0026gt; Weekday.Sat , 6 使用元类 type() 动态语言和静态语言最大的区别就是函数和类的定义，不是在编译时定义的而是在运行时动态创建的。\n比如要定义一个Hello类，可以写一个hello.py模块：\nclass Hello(object): def hello(self, name = \u0026#39;world\u0026#39;): print(\u0026#39;Hello, %s.\u0026#39; % name) 当Python解释器载入hello模块时就会依次执行该模块的所有语句，结果就是动态创建出一个Hello的类对象：\nfrom hello import Hello h = Hello() h.hello() # 打印输出\u0026#34;Hello, world.\u0026#34; print(type(Hello)) # 打印输出\u0026#34;\u0026lt;class \u0026#39;type\u0026#39;\u0026gt;\u0026#34; print(type(h)) # 打印输出\u0026#34;\u0026lt;class \u0026#39;hello.Hello\u0026#39;\u0026gt;\u0026#34; 类的定义是运行时动态创建的，type函数除了可以查看一个类型或变量的类型，也是能在运行时动态创建类的函数。type函数既可以返回一个对象的类型，又可以创建出新的类型，如可以通过type函数创建出Hello类，无需通过class Hello(object)...的定义：\ndef func(self, name = \u0026#39;world\u0026#39;): # 先定义类的方法 print(\u0026#39;Hello, %s.\u0026#39; % name) Hello = type(\u0026#39;Hello\u0026#39;, (object,), dict(hello = func)) # 创建Hello类 h = Hello() h.hello() print(type(Hello)) print(type(h)) Hello, world. \u0026lt;class 'type'\u0026gt; \u0026lt;class '__main__.Hello'\u0026gt; 要创建一个类对象，type函数需依次传入3个参数：\n类的名称 继承的基类集合，支持多重继承 类的方法名与函数绑定（在上一个block中，将函数func绑定到方法名hello上） 通过type函数创建的类和直接用class定义的类本质上是完全一样的，但正常情况下都使用class定义类。\nmetaclass 除了上文提到type可以动态创建类之外，还可以使用metaclass（元类）控制类的创建行为。正常情况下都是先定义类，再根据类的定义创建相应的实例，元类的意思即：但如何创建出类，则需要根据metaclass创建类。\n先定义元类 ==\u0026gt; 创建类 ==\u0026gt; 创建实例\n所以，元类允许创建类或者修改类，也就是说可以把类看成是依据元类创建出来的“实例”。元类是Python面向对象里最难理解最难使用的魔术代码。\n例子：使用metaclass给自定义类MyList增加一个add方法：\n# 先定义 ListMetaclass，按照默认习惯，元类的类名总是以Metaclass结尾，便于辨别 class ListMetaclass(type): # metaclass是类的模板，所以必须从`type`类型派生 # __new__方法接收的参数依次是：准备创建的类的对象；类的名字；类继承的基类集合，类的方法集合 def __new__(cls, name, bases, attrs): attrs[\u0026#39;add\u0026#39;] = lambda self, value: self.append(value) return type.__new__(cls, name, bases, attrs) # 有了 ListMetaclass，在定义类的时候还要指示使用ListMetaclass来定制类，传入关键字参数metaclass # 当传入关键字参数metaclass时，魔术就生效了，它指示在创建MyList时通过ListMetaclass.__new__()来创建 class MyList(list, metaclass = ListMetaclass): pass L = MyList() L.add(1) # add方法，普通的list没有add方法 L # 输出 [1] [1] 正常情况下没有人会用上面这么复杂的方法，直接在MyList定义中写上add方法显然更简单。但总会遇到需要通过元类修改类定义的，ORM就是一个典型的例子。\nORM(Object Relational Mapping 对象关系映射)，就是指将关系型数据库的一行映射为一个对象即一个类对应一个表，这种方式可可大大简化代码编写。\n要编写一个ORM框架，所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类。例子：编写一个ORM框架：\n# User接口的基类Model和属性类型StringField、IntegerField由ORM框架提供，魔法方法等如save全部由基类Model自动完成。接下来实现ORM框架 # 首先定义Field类，负责保存数据库表的字段名和字段类型 class Field(object): def __init__(self, name, column_type): self.name = name self.column_type = column_type def __str__(self): return \u0026#39;\u0026lt;%s: %s\u0026gt;\u0026#39; % (self.__class__.__name__, self.name) # 在Field的基础上进一步定义各种类型的Field class StringField(Field): def __init__(self, name): super(StringField, self).__init__(name, \u0026#39;varchar(100)\u0026#39;) class IntegerField(Field): def __init__(self, name): super(IntegerField, self).__init__(name, \u0026#39;bigint\u0026#39;) # 接下来编写ModelMetaclass class ModelMetaclass(type): def __new__(cls, name, bases, attrs): if name == \u0026#39;Model\u0026#39;: return type.__new__(cls, name, bases, attrs) print(\u0026#39;Found model: %s\u0026#39; % name) mappings = dict() for k, v in attrs.items(): if isinstance(v, Field): print(\u0026#39;Found mapping: %s ==\u0026gt; %s\u0026#39; % (k, v)) mappings[k] = v for k in mappings.keys(): attrs.pop(k) # 退栈 attrs[\u0026#39;__mappings__\u0026#39;] = mappings attrs[\u0026#39;__table__\u0026#39;] = name return type.__new__(cls, name, bases, attrs) # 以及基类Model class Model(dict, metaclass=ModelMetaclass): def __init__(self, **kw): super(Model, self).__init__(**kw) def __getattr__(self, key): try: return self[key] except KeyError: raise AttributeError(r\u0026#34;\u0026#39;Model\u0026#39; object has no attribute \u0026#39;%s\u0026#39;\u0026#34; % key) def __setattr__(self, key, value): self[key] = value def save(self): fields = [] params = [] args = [] for k, v in self.__mappings__.items(): fields.append(v.name) params.append(\u0026#39;?\u0026#39;) args.append(getattr(self, k, None)) sql = \u0026#39;insert into %s (%s) values (%s)\u0026#39; % (self.__table__, \u0026#39;,\u0026#39;.join(fields), \u0026#39;,\u0026#39;.join(params)) print(\u0026#39;SQL: %s\u0026#39; % sql) print(\u0026#39;ARGS: %s\u0026#39; % str(args)) # 编写接口，定义一个User类操作对应的数据库User表 class User(Model): # 类属性到列的映射 id = IntegerField(\u0026#39;id\u0026#39;) name = StringField(\u0026#39;username\u0026#39;) email = StringField(\u0026#39;email\u0026#39;) password = StringField(\u0026#39;password\u0026#39;) u = User(id = 12345, name = \u0026#39;Jensen\u0026#39;, email = \u0026#39;jensen.acm@gmail.com\u0026#39;, password = \u0026#39;test123\u0026#39;) u.save() # 运行正常，只需真正连接到数据库上，执行SQL，就可以完成真正的功能 Found model: User Found mapping: id ==\u0026gt; \u0026lt;IntegerField: id\u0026gt; Found mapping: name ==\u0026gt; \u0026lt;StringField: username\u0026gt; Found mapping: email ==\u0026gt; \u0026lt;StringField: email\u0026gt; Found mapping: password ==\u0026gt; \u0026lt;StringField: password\u0026gt; SQL: insert into User (id,username,email,password) values (?,?,?,?) ARGS: [12345, 'Jensen', 'jensen.acm@gmail.com', 'test123'] 当定义一个class User(Model)时，Python解释器首先在当前类User的定义中查找metaclass，如果没有找到，就继续在基类Model中查找，找到后使用Model中定义的metaclass的ModelMetaclass来创建User类。\n在ModelMetaclass中，一共做了如下几件事：\n排除对Model类的修改； 在当前类User中查找定义类的所有属性，如果找到一个Field属性就把它保存在一个__mappings__的字典中，同时从类属性中删除该属性，否则容易在运行时出错； 把表名保存到__table__中，这里简化将类名作为默认表名。 在Model类中可以定义各种操作数据库的方法，如save、delete、find、update等。\n错误、调试和测试 错误处理 在程序运行的过程中，如果发生了错误可以事先约定返回一个错误代码，这样就知道是否有错以及出错的原因。\n在操作系统提供的调用中，返回错误码非常常见，比如打开文件的函数open，成功时返回文件描述符即一个整数，出错时返回-1。\n但是用错误码表示是否出错十分麻烦，函数本身应该返回的正常结果和错误码混在一起，需要调用者编写很多代码判断是否出错。一旦出错，需要一级一级上报直到某个函数可以处理该错误。\n高级语言通常都内置了一套try...except...finally...的错误处理机制，Python也不例外。\ntry 先来看一个try的例子：被除数不可以为0：\ntry: # 编写代码时认为某些代码可能会出错，可以用try来包裹这段代码 print(\u0026#39;try...\u0026#39;) r = 10 / 0 # 被除数不可以为0，此处出错后续代码不会执行，直接跳到except处即错误处理部分 print(\u0026#39;result: \u0026#39;, r) except ZeroDivisionError as e: # except捕获到ZeroDivisionError print(\u0026#39;except: \u0026#39;, e) # 打印错误，如果后面有finally语句块则执行finally语句块，没有就结束 finally: print(\u0026#39;finally...\u0026#39;) print(\u0026#39;END\u0026#39;) try... except: division by zero finally... END 若将上面block中的r = 10 / 0修改为r = 10 / 2，则执行结果如下：\ntry... result: 5 finally... END 由于ZeroDivisionError错误没有发生，因此except语句块不会执行，但是无论是否出现错误，只要存在finally语句块，finally语句块就一定会被执行。\n错误有很多种类，如ZeroDivisionError、ValueError、AttributeError等，若发生了不同的错误，应由不同的except语句块处理即可以有多个except来捕获不同类型的错误：\ntry: print(\u0026#39;try...\u0026#39;) r = 10 / int(\u0026#39;a\u0026#39;) # int函数会抛出ValueError print(\u0026#39;result: \u0026#39;, r) except ValueError as e: # except捕获ValueError print(\u0026#39;ValueError: \u0026#39;, e) except ZeroDivisionError as e: print(\u0026#39;ZeroDivisionError: \u0026#39;, e) else: # 若没有任何错误发生，则会自动执行else语句 print(\u0026#39;No ERROR!\u0026#39;) finally: print(\u0026#39;finally...\u0026#39;) print(\u0026#39;END\u0026#39;) Python中的错误也是类，所有的错误类型都继承自BaseException，所以在使用except时要注意它不仅捕获该类型的错误，同时也把它的子类都捕获了：\ntry: foo() # 会抛出UnicodeError错误 excpet ValueError as e: # 错误被该except捕获，因为UnicodeError是ValueError的子类 print(\u0026#39;ValueError: \u0026#39;, e) except UnicodeError as e: # 该except永远捕获不到UnicodeError，错误已经被上一个except捕获了 print(\u0026#39;UnicodeError: \u0026#39;, e) 使用try...except结构捕获错误还有一个巨大的优势，即可以跨越多层调用，比如main函数调用bar函数，bar函数调用foo函数，若foo函数出错了，仅需最外层的main捕获到了就可以进行处理：\ndef foo(s): return 10 / int(s) def bar(s): return foo(s) * 2 def main(): try: # 毋需在每个可能出错的地方捕获错误，只要在合适的层次捕获就好了，简化代码 bar(\u0026#39;0\u0026#39;) except Exception as e: # except会捕获到错误 division by zero print(\u0026#39;Error: \u0026#39;, e) finally: print(\u0026#39;finally...\u0026#39;) main() Error: division by zero finally... 调用栈 如果错误没有被捕获，则会一直上抛，最后被Python解释器所捕获，最后打印一个错误信息后程序退出，例如：\nTraceback (most recent call last): File \u0026#34;error.py\u0026#34;, line 11, in \u0026lt;module\u0026gt; main() File \u0026#34;error.py\u0026#34;, line 9, in main bar(\u0026#39;0\u0026#39;) File \u0026#34;error.py\u0026#34;, line 6, in bar return foo(s) * 2 File \u0026#34;error.py\u0026#34;, line 3, in foo return 10 / int(s) ZeroDivisionError: division by zero 可以根据上述错误跟踪信息依次分析，最终定位到错误的源头发生在error.py文件的第三行return 10 / int(s)，因为最后打印了ZeroDivisionError: division by zero，根据错误类型以及错误信息可以判断int(s)本身没有错，只是int(s)返回了0，在计算10 / 0时出了错。\n记录错误 若不捕获错误，Python解释器自然会打印出错误堆栈，但是程序也终止了，既然可以捕获错误，就可以把错误堆栈打印记录下来，同时让程序继续执行下去，后来再根据需要分析错误原因。Python内置的logging模块可以很好的实现这一点：\nimport logging def foo(s): return 10 / int(s) def bar(s): return foo(s) * 2 def main(): try: bar(\u0026#39;0\u0026#39;) except Exception as e: logging.exception(e) # 通过适当的配置，logging还可以把错误信息保存在日志文件里，方便日后排查 main() # 同样是出错，但程序打印完错误堆栈后会继续执行，并正常退出 print(\u0026#39;END\u0026#39;) ERROR:root:division by zero Traceback (most recent call last): File \u0026quot;/tmp/ipykernel_15563/3467350787.py\u0026quot;, line 11, in main bar('0') File \u0026quot;/tmp/ipykernel_15563/3467350787.py\u0026quot;, line 7, in bar return foo(s) * 2 File \u0026quot;/tmp/ipykernel_15563/3467350787.py\u0026quot;, line 4, in foo return 10 / int(s) ZeroDivisionError: division by zero END 抛出错误 错误是类，捕获错误就是捕获到该类的一个实例，Python内置函数会抛出很多的类型的错误，也可以自己编写函数抛出相应的错误。\n若要抛出错误，可以根据需要定义一个错误的类，选择好继承关系，最后用raise语句抛出错误实例：\nclass FooError(ValueError): # 自定义错误类，继承自ValueError pass def foo(s): n = int(s) if n == 0: raise FooError(\u0026#39;invalid value: %s\u0026#39; % s) # 抛出自定义错误 return 10 / n foo(\u0026#39;0\u0026#39;) --------------------------------------------------------------------------- FooError Traceback (most recent call last) /tmp/ipykernel_15563/3824456867.py in \u0026lt;module\u0026gt; 8 return 10 / n 9 ---\u0026gt; 10 foo('0') /tmp/ipykernel_15563/3824456867.py in foo(s) 5 n = int(s) 6 if n == 0: ----\u0026gt; 7 raise FooError('invalid value: %s' % s) # 抛出自定义错误 8 return 10 / n 9 FooError: invalid value: 0 如果可以选择Python已有的内置错误类型，尽量使用Python内置的错误类型。只有在必要的时候才自定义错误类型。\n有时候底层代码不清楚如何处理错误，可以将错误上抛，抛给高层调用者处理：\ndef foo(s): n = int(s) if n == 0: raise ValueError(\u0026#39;invalid value: %s\u0026#39; % s) # 抛出ValueError return 10 / n def bar(): try: foo(\u0026#39;0\u0026#39;) except ValueError as e: # 底层调用者捕获到ValueError print(\u0026#39;ValueError!\u0026#39;) # 打印错误只是单纯的记录一下 raise # 底层调用者不知道如何处理错误，继续上抛给高层调用者处理 bar() ValueError! --------------------------------------------------------------------------- ValueError Traceback (most recent call last) /tmp/ipykernel_15563/1057959981.py in \u0026lt;module\u0026gt; 12 raise # 底层调用者不知道如何处理错误，继续上抛给高层调用者处理 13 ---\u0026gt; 14 bar() /tmp/ipykernel_15563/1057959981.py in bar() 7 def bar(): 8 try: ----\u0026gt; 9 foo('0') 10 except ValueError as e: # 底层调用者捕获到ValueError 11 print('ValueError!') # 打印错误只是单纯的记录一下 /tmp/ipykernel_15563/1057959981.py in foo(s) 2 n = int(s) 3 if n == 0: ----\u0026gt; 4 raise ValueError('invalid value: %s' % s) # 抛出ValueError 5 return 10 / n 6 ValueError: invalid value: 0 raise语句如果不带任何参数就会把当前错误原样抛出。此外，在except中raise一个错误还可以把一种类型的错误转化为另一种类型：\ntry: 10 / 0 except ZeroDivisionError: # 捕获到一个ZeroDivisionError raise ValueError(\u0026#39;Input Error!\u0026#39;) # 将错误转换为ValueError 只要是合理的转换逻辑就可以，但是，决不应该把一个IOError转换成毫不相干的ValueError。\n","date":"2021-12-29T00:00:00Z","permalink":"https://jen-jon.github.io/posts/pythonbasic/","tags":"Python","title":"Python基础","type":"technology"},{"contents":"结构体和类作为一种通用而又灵活的结构，成为了人们构建代码的基础。可以使用定义常量、变量和函数的语法，从而为结构体和类定义属性、添加方法。\n与其他编程语言所不同的是，Swift并不要求为自定义的结构体和类的接口与实现代码分别创建文件。只需要在单一文件中定义一个结构体或类，系统将会自动生成面向其他代码的外部接口。\n注意\n通常一个类的实例被称为对象。然而相比其他语言，Swift中结构体和类的功能更加相近，本章中所讨论的大部分都可以用在结构体或者类上。因此，这里会使用实例这个更通用的术语。\n结构体和类对比 Swift中结构体和类有很多共同点，两者都可以：\n定义属性用于存储值 定义方法用于提供功能 定义下标操作用于通过下标语法访问它们的的值 定义构造器用于设置初始值 通过扩展以增加默认实现之外的功能 遵循协议以提供某种标准功能 更多信息请参见属性、方法、下标、构造过程、扩展和协议。 与结构体相比，类还有如下的附加功能：\n继承允许一个类继承另一个类的特征 类型转换允许在运行时检查和解释一个类实例的类型 析构器允许一个类实例释放任何其所被分配的资源 引用计数允许对一个类的多次引用 更多信息请参见继承、类型转换、析构过程和自动引用计数。 类支持的附加功能是以增加复杂性为代价的。作为一般准则，优先使用结构体，因为它们更容易理解，仅在适当或者必要时才使用类。实际上，这意味着大多数自定义数据类型都会是结构体和枚举。\n注意\n类和actors共享很多特性。\n类型定义语法 结构体和类有着相似的定义方式，通过struct关键字引入结构体，通过class关键字引入类，并将它们的具体定义放在一对大括号中：\nstruct SomeStructure { // 在这里定义结构体 } class SomeClass { // 在这里定义类 } 注意\n每当定义一个新的结构体或者类时，都是定义了一个新的Swift类型。请使用UpperCamelCase这种方式来命名类型（如这里的SomeClass和SomeStructure），以便复合标准Swift类型的大写命名风格（如String，Int和Bool）。请使用lowerCamelCase这种方式来命名属性和方法（如frameRate和incrementCount），以便和类型名区分。\n以下是定义结构体和定义类的示例：\nstruct Resolution { var width = 0 var height = 0 } class VideoMode { var resolution = Resolution() var interlaced = false var frameRate = 0.0 var name: String? } 在上面的示例中定义了一个名为Resolution的结构体，用来描述基于像素的分辨率。这个结构体包含了名为width和height的两个存储属性。存储属性是与结构体或者类绑定的，并存储在常量或者变量。当这两个属性被初始化为整数0的时候，它们会被推断为Int类型。\n在上面的示例还定义了一个名为VideoMode的类，用来描述视频显示器的某个特定视频模式。这个类包含了四个可变的存储属性。第一个，resolution，被初始化为一个新的Resolution结构体实例，属性类型被推断为Resolution。新VideoMode实例同时还会初始化其它三个属性，它们分别是初始值为false的interlaced（意为“非隔行视频”），初始值为0.0的frameRate，以及值为可选String的name。因为name是一个可选类型，它会被自动赋予一个默认值nil，意为“没有name值”。\n结构体和类的实例 Resolution结构体和VideoMode类的定义仅描述了什么是Resolution和VideoMode。它们并没有描述一个特定的分辨率（Resolution）或者视频模式（VideoMode）。为此，需要创建结构体或者类的一个实例。\nlet someResolution = Resolution() let someVideoMode = VideoMode() 结构体和类都使用构造器语法来创建新的实例。构造器语法的最简单形式就是在结构体或者类的类型名称后跟随一对空括号，如Resolution()或VideoMode()。通过这种方式所创建的类或者结构体实例，其属性均会被初始化为默认值。构造过程章节将会对类和结构体的初始化进行更详细的讨论。\n属性访问 可以通过点语法访问实例的属性，其语法规则是，实例后面紧跟属性名，两者以.分隔，中间不带空格。\nprint(\u0026#34;The width of someResolution is \\(someResolution.width).\u0026#34;) // 打印输出“The width of someResolution is 0.” --- output: The width of someResolution is 0. 在上面的例子中，someResolution.width引用someResolution的width属性，返回width的初始值0。\n也可以访问子属性，如someVideoMode中的resolution属性的width属性：\nprint(\u0026#34;The width of someVideoMode is \\(someVideoMode.resolution.width).\u0026#34;) // 打印输出“The width of someVideoMode is 0.” --- output: The width of someVideoMode is 0. 也可以使用点语法为可变属性赋值：\nsomeVideoMode.resolution.width = 1280 print(\u0026#34;Now, the width of someVideoMode is \\(someVideoMode.resolution.width).\u0026#34;) // 打印输出“Now, the width of someVideoMode is 1280.” --- output: Now, the width of someVideoMode is 1280. 结构体类型的成员逐一构造器 所有的结构体都有一个自动生成的成员逐一构造器，用于初始化新结构体实例中的成员属性。新实例中各个属性的初始值可以通过属性的名称传递到成员逐一构造器中：\nlet vga = Resolution(width: 640, height: 480) print(\u0026#34;The width of vga is \\(vga.width) and the height is \\(vga.height).\u0026#34;) // 打印输出“The width of vga is 640 and the height is 480.” --- output: The width of vga is 640 and the height is 480. 与结构体不同，类实例没有默认的成员逐一构造器。构造过程章节会对构造器进行更详细的讨论。\n结构体和枚举是值类型 值类型是这样一种类型，当它被赋值给了一个变量、常量或者传递给一个参数时，其值会被拷贝。\n在之前的章节中，我们已经大量使用了值类型。其实，Swift中所有的基本类型：整数（Integer）、浮点数（Floating-Point Number）、布尔值（Boolean）、字符串（String）、数组（Array）和字典（ Dictionary）都是值类型，其底层也是使用结构体实现的。\nSwift中所有的结构体和枚举都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型的属性，在代码中传递的时候都会被复制。\n注意\n标准库定义的集合，如数组、字典和字符串，都对复制进行了优化以降低性能成本，新集合不会立即复制而是跟原集合共享同一份内存，共享同样的元素。在集合的某个副本要被修改之前，才会复制它的元素。而开发者在代码中看起来就像是立即发生了复制。\n请看下面的示例，其使用了上一个示例中的Resolution结构体：\nlet hd = Resolution(width: 1920, height: 1080) var cinema = hd 在以上的示例中声明了一个名为hd的常量，其值初始化为全高清视频分辨率（1920像素宽，1080像素高）的Resolution实例。\n然后示例中又声明了一个名为cinema的变量，并将hd赋值给它。因为Resolution是一个结构体，所以会创建一个现有实例的副本，并将副本赋值给cinema。尽管hd和cinema有着相同的宽（Width）和高（Height），但是在幕后这两个是完全不同的实例。\n下面，为了满足数码影院的放映需求（2048像素宽，1080像素高），cinema的width属性被修改为稍宽一点的2K标准：\ncinema.width = 2048 查看cinema的width属性，其值确实被改为了2048:\nprint(\u0026#34;The width of cinema is \\(cinema.width).\u0026#34;) // 打印输出“The width of cinema is 2048.” --- output: The width of cinema is 2048. 然而，初始的hd的width属性值还是1920:\nprint(\u0026#34;The width of hd is still \\(hd.width).\u0026#34;) // 打印输出“The width of hd is still 1920.” --- output: The width of hd is still 1920. 将hd赋值给cinema时，hd中所存储的值会拷贝到新的cinema实例中。结果就是两个完全独立的实例包含了相同的数值。由于两者相互独立，因此将cinema的width修改为2048并不会影响hd中的width的值，如下图所示：\n枚举也遵循相同的行为准则：\nenum CompassPoint { case north, south, west, east mutating func turnNorth() { self = .north } } var currentDirection = CompassPoint.west let rememberDirection = currentDirection currentDirection.turnNorth() print(\u0026#34;The current direction is \\(currentDirection).\u0026#34;) // 打印输出“The current direction is north.” print(\u0026#34;The remember direction is \\(rememberDirection).\u0026#34;) // 打印输出“The remember direction is west.” --- output: The current direction is north. The remember direction is west. 当rememberDirection被赋予了currentDirection的值，实际上它被赋予的是一个值拷贝，赋值过程结束后再修改currentDirection的值并不rememberDirection所存储的原始值的拷贝。\n类是引用类型 与值类型不同，引用类型被赋予到一个常量、变量或者被传递到一个函数时，其值不会被拷贝。因此使用的是已存在实例的引用而不是其拷贝。\n请看下面这个示例，其使用了之前定义的VideoMode类：\nlet tenEighty = VideoMode() tenEighty.resolution = hd tenEighty.interlaced = true tenEighty.name = \u0026#34;1080i\u0026#34; tenEighty.frameRate = 25.0 在以上示例中，声明了一个名为tenEighty的常量，并让其引用一个VideoMode类的新实例。它的视频模式（Video Mode）被赋值为之前创建的HD分辨率（1920 * 1080）的一个拷贝，然后将其设置为隔行视频，名字为“”，并将帧率设置为25.0帧每秒。\n接下来，将tenEighty赋值个一个名为alsoTenEighty的新常量，并修改alsoTenEighty的帧率：\nlet alsoTenEighty = tenEighty alsoTenEighty.frameRate = 30.0 因为类是引用类型，所以alsoTenEighty和tenEighty引用的是同一个VideoMode实例。换句话说，它们是同一个实例的两种叫法，如下图所示：\n通过查看tenEighty的frameRate属性，可以看到其正确地显示了底层VideoMode实例的新帧率30.0：\nprint(\u0026#34;The frameRate property of tenEighty is now \\(tenEighty.frameRate).\u0026#34;) // 打印输出“The frameRate property of tenEighty is now 30.0.” --- output: The frameRate property of tenEighty is now 30.0. 这个例子也就显示了为何引用类型难以理解。如果tenEighty和alsoTenEighty在代码中的位置相距很远，那么就很难找到所有修改视频模式的地方。无论在哪里使用tenEighty都需要考虑alsoTenEighty的代码，反之亦然。相反，值类型就显得容易理解多了，因为源码中，同一个位置交互的代码都很近。\n需要注意的是tenEighty和alsoTenEighty被声明为常量而不是变量。然而你依然可以改变tenEighty.frameRate和alsoTenEighty.frameRate，这是因为tenEighty和alsoTenEighty这两个常量的值并未改变。它们并不“存储”这个VideoMode实例，而仅仅是对VideoMode实例的引用。所以，改变的是底层VideoMode实例的frameRate属性，而不是\u0008指向VideoMode的常量引用的值。\n恒等运算符 因为类是引用类型，所以多个常量和变量可能在幕后同时引用同一个类实例。（对于结构体和枚举来说，这并不成立。因为它们作为值类型，在被赋予给常量、变量或者传递到函数时，其值总是会拷贝。）\n判定两个常量或者变量是否引用同一个类实例时很有用。为了达到这个目的，Swift提供了两个恒等运算符：\n相同（===） 不同（!==） 使用这两个运算符检测两个常量和变量是否引用了同一个实例：\nif tenEighty === alsoTenEighty { print(\u0026#34;tenEighty and alsoTenEighty refer to the same VideoMode instance.\u0026#34;) // 打印输出“tenEighty and alsoTenEighty refer to the same VideoMode instance.” } --- output: tenEighty and alsoTenEighty refer to the same VideoMode instance. 请注意，“相同”（用三个等号表示，===）与“等于”（用两个等号表示，==）不同，“相同”表示两个类类型（class type）的常量或变量引用同一个类实例。“等于”表示两个实例的值“相等”或“等价“，判定时要遵循设计者定义的评判标准。\n当在定义自定义结构体和类时，开发者有义务来决定判定两个实例“相等”的标准。在章节高级运算符中将会详细介绍实现自定义==和!=运算符的流程。\n指针 如果有C、C++、和Objective-C语言的开发经验，那么大家也许会知道这些语言使用指针来引用内存中的地址。Swift中引用了某个引用类型实例的常量或变量，与C语言中的指针类似，不过它并不直接指向某个内存地址，也不要求使用*来表明正在创建一个引用。相反，Swift中引用的定义方式与其他常量和变量的一样。如果需要直接与指针交互，可以使用标准库提供的指针和缓冲区类型\u0026ndash;参见手动内存管理。\n","date":"2021-08-30T00:00:00Z","permalink":"https://jen-jon.github.io/posts/structclasses/","tags":"iOS; Swift; Apple","title":"Swift学习(11)-类和结构体（代码完善版）","type":"technology"},{"contents":"枚举为一组相关的值定义了一个共同的类型。使得能够在代码中以类型安全的方式来使用这些值。\n如果熟悉C语言，会知道在C语言中，枚举会为一组整型值分配相关联的名称。Swift中的枚举更加灵活，不必给每一个枚举成员提供一个值。如果给枚举成员提供一个值（称为原始值），则该值的类型可以是字符串、字符或者是一个整型值或浮点数。\n此外，枚举成员可以指定任意类型的关联值存储到枚举成员中，就像其他语言中的联合体（unions）和辩题（variants）。可以在一个枚举中定义一组相关联的枚举成员，每一个枚举成员都可以有适当类型的关联值。\n在Swift中，枚举类型是一等（First-Class）类型。它们采用了很多在传统上只被类（class）所支持的特性，如计算属性（Computed Properties），用于提供枚举值的附加信息，实例方法（Instance Methods）。用于提供和枚举值相关联的功能。枚举也可以定义构造函数（Initializers）来提供一个初始值；可以在原始实现的基础上扩展它们的功能；还可以遵循协议（Protocols）来提供标准的功能。\n枚举语法 使用enum关键词来创建枚举并且把它们的整个定义放在一对大括号内：\nenum SomeEnumeration { // 枚举定义放这里 } // 下面使用枚举表示指南针四个方向的例子： enum CompassPoint { case north case south case east case west } 枚举中定义的值（如north，south，east和west）是这个枚举的成员值（或成员）。可以使用case关键字来定义一个新的枚举成员值。\n注意\n与C和Objective-C不同，Swift的枚举成员在被创建时不会赋予一个默认的整型值。在上面的CompassPoint例子中，north，south，east和west不会被隐式的赋值为0，1，2和3。相反，这些枚举成员本身就是完备的值，这些值的类型是已经明确定义好的CompassPoint类型。 多个成员值可以出现在同一行上，用逗号隔开：\nenum Planet { case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune } 每个枚举定义了一个全新的类型。像Swift中的其他类型一样，它们的名字（例如CompassPoint和Planet）以一个大写字母开头。给枚举类型起一个单数名字而不是复数名字，以便于：\nvar directionToHead = CompassPoint.west directionToHead的类型还可以在它被CompassPoint的某个值初始化时推断出来，一旦directionToHead被声明为CompassPoint类型，可以使用更简短的点语法将其设置为另一个CompassPoint的值：\ndirectionToHead = .east 当directionToHead的类型已知时，再次为其赋值可以省略枚举类型名。在使用具有显式类型的枚举值时，这种写法让代码具有更好的可读性。\nprint(\u0026#34;directionToHead: \\(directionToHead).\u0026#34;) --- output: directionToHead: east. 使用Switch语句匹配枚举值 可以使用switch语句匹配单个枚举值：\ndirectionToHead = .south switch directionToHead { case .north: print(\u0026#34;Lots of planets have a north.\u0026#34;) case .south: print(\u0026#34;Watch out for penguins.\u0026#34;) case .east: print(\u0026#34;Where the sun rises.\u0026#34;) case .west: print(\u0026#34;Where the skies are blue.\u0026#34;) } // 打印输出“Watch out the penguins.” --- output: Watch out for penguins. 可以这样理解这段代码：\n“判断directionToHead的值。当它等于.north，打印‘Lots of planets have a north.’。当它等于.south，打印‘Watch out for penguins.’” \u0026hellip;\u0026hellip;以此类推\n正如在控制流中介绍的那样，在判断一个枚举类型的值时，switch语句必须穷举所有的情况。如果忽略了.west这种情况，上面那段代码将无法通过编译，因为其没有考虑到CompassPoint的全部成员。强制穷举确保了枚举成员不会被意外遗漏。\n当不需要匹配每个枚举成员的时候，可以提供一个default分支来涵盖所有未明确处理的枚举成员：\nlet somePlanet = Planet.earth switch somePlanet { case .earth: print(\u0026#34;Mostly harmless.\u0026#34;) default: print(\u0026#34;Not a safe place for humans.\u0026#34;) } // 打印输出“Mostly harmless.” --- output: Mostly harmless. 枚举成员的遍历 在一些情况下，可能会需要得到一个包含枚举所有成员的集合。可以通过如下代码的实现：\n令枚举遵循CaseIterable协议。Swift会生成一个allCases属性，用于表示一个包含枚举所有成员的集合。下面是一个例子：\nenum Beverage: CaseIterable { case coffee, tea, juice } let numberOfChoices = Beverage.allCases.count print(\u0026#34;\\(numberOfChoices) beverages available.\u0026#34;) --- output: 3 beverages available. 在前面的例子中，通过Beverage.allCases可以访问到包含Beverage枚举所有成员的集合。allCases的使用方法和其他一般集合一样：集合中的元素是枚举类型的实例，所以在上面的情况中，这些元素是Beverage值。在前面的例子中，统计了总共多少个枚举成员。而在下面的例子中，则使用for-in循环来遍历所有枚举成员。\nfor beverage in Beverage.allCases { print(beverage) } // coffee // tea // juice --- output: coffee tea juice 在前面的例子中，使用的语法表明这个枚举遵循CaseIterable协议。\n关联值 枚举语法那一小节的例子演示了如何定义和分类枚举成员。可以为Planet.earth设置一个常量或者变量，并在赋值之后查看这个值。然而，有时候把其他类型的值和成员值一起存储起来会很有用。这额外的信息被称为关联值，并且每次在代码中使用该枚举成员时，还可以修改这个关联值。\n可以定义Swift枚举来存储任意类型的关联值，如果需要的话，每个枚举成员的关联值类型可以各不相同。枚举的这种特性跟其他语言中的可识别联合（Discriminated Unions），标签联合（Tagged Unions），或者变体（Variants）相似。\n例如，假设一个库存跟踪系统需要利用两种不同类型的条形码来跟踪商品，有些商品商标有使用0到9的数字的UPC格式的一维条形码。每一个条形码都有一个代表数字系统的数字，该数字后接五位代表厂商代码的数字，接下来是五位代表“产品代码”的数字。最后一位数字是检查位，用来验证代码是否被正确扫描：\n其他商品上标有QR码格式的二维码，它可以使用任何ISO 8859-1字符，并且可以编码一个最多拥有2953个字符的字符串：\n这便于库存跟踪系统用包含四个整型值的元组存储UPC码，以及用任意长度的字符串储存QR码：\n在Swift中，使用如下方法定义表示两种商品条形码的枚举：\nenum BarCode { case upc(Int, Int, Int, Int) case qrCode(String) } 以上代码可以这么理解：\n“定义一个名为BarCode的枚举类型，它的一个成员值是具有(Int, Int, Int, Int)类型关联值的upc，另一个成员值是具有String类型关联值的qrCode。”\n这个定义不提供任何Int或String类型的关联值，它只是定义了，当BarCode常量和变量等于BarCode.upc或BarCode.qrCode时，可以存储的关联值的类型。\n然后可以使用任意一种条形码类型创建新的条形码。例如：\nvar productBarCode = BarCode.upc(8, 85909, 51226, 3) 上面的例子创建了一个名为productBarCode的变量，并将BarCode.upc赋值给它，关联的元组值为(8, 85909, 51226, 3)。\n同一个商品可以被分配成一个不同类型的条形码，例如：\nproductBarCode = .qrCode(\u0026#34;ABCDEFGHIJKLMNOP\u0026#34;) 这时，原始的BarCode.upc和其整数关联值被新的BarCode.qrCode和其字符串关联值所替代。BarCode类型的常量和变量可以存储一个.upc或者.qrCode（连同它们的关联值），但是在同一时间只能存持这两个值中的一个。\n可以使用一个switch语句来检查不同的条形码类型，和之前使用Switch语句来匹配枚举值的例子一样。然而，这一次，关联值可以被提取出来作为switch语句的一部分。可以在switch的case分支代码中提取每个关联值作为一个常量（用let前缀）或者一个变量（用var前缀）来使用：\nswitch productBarCode { case .upc(let numberSystem, let manuFacturer, let product, let check): print(\u0026#34;UPC: \\(numberSystem), \\(manuFacturer), \\(product), \\(check).\u0026#34;) case .qrCode(let productCode): print(\u0026#34;QR code: \\(productCode).\u0026#34;) } // 打印输出“QR code: ABCDEFGHIJKLMNOP” --- output: QR code: ABCDEFGHIJKLMNOP. 如果一个枚举成员的所有关联值都被提取为常量，或者都被提取为变量，为了简洁，可以只在成员名称前标注一个let或var：\nproductBarCode = .upc(8, 86751, 62119, 3) switch productBarCode { case let .upc(numberSystem, manuFactor, product, check): print(\u0026#34;UPC: \\(numberSystem), \\(manuFactor), \\(product), \\(check).\u0026#34;) case let .qrCode(productCode): print(\u0026#34;QR code: \\(productCode)\u0026#34;) } // 打印输出“UPC: 8, 86751, 62119, 3.” --- output: UPC: 8, 86751, 62119, 3. 原始值 在关联值小节的条形码例子中，演示了如何声明存储不同类型关联值的枚举成员。作为关联值的替代选择，枚举成员可以被默认值（称为原始值）预填充，这些原始值的类型必须相同。\n这是一个使用ASCII码作为原始值的枚举：\nenum ASCIIControlCharacter: Character { case tab = \u0026#34;\\t\u0026#34; case lineFeed = \u0026#34;\\n\u0026#34; case carriageReturn = \u0026#34;\\r\u0026#34; } 枚举类型ASCIIControlCharacter的原始值类型被定义为Character，并设置了一些比较常见的ASCII控制字符。Character的描述详见字符串和字符部分。\n原始值可以是字符串、字符，或者任意类型值或浮点型值。每个原始值在枚举声明中必须是唯一的。\n注意\n原始值和关联值是不同的。原始值是在定义枚举时被预先填充的值，像上述三个ASCII码。对于一个特定的枚举成员，它的原始值始终不变。关联值是创建一个基于枚举成员的常量或者变量时才设置的值，枚举成员的关联值可以变化。\n原始值的隐式赋值 在使用原始值为整数或者字符串的枚举时，不需要显式地为每一个枚举成员设置原始值，Swift将会自动赋值。\n例如，当使用整数作为原始值时，隐式赋值的值以此递增1。如果第一个枚举成员没有原始值，则其原始值被设置为0。\n下面的枚举是对之前Planet这个枚举的一个细化，利用整型的原始值来表示每个行星在太阳系中的顺序：\nenum Planets: Int { case mercury = 1, venus, earth case mars, jupiter, saturn, uranus, neptune } extension Planets: CaseIterable {} for planet in Planets.allCases { print(\u0026#34;\\(planet)\u0026#39;s raw value is \\(planet.rawValue).\u0026#34;) } --- output: mercury\u0026#39;s raw value is 1. venus\u0026#39;s raw value is 2. earth\u0026#39;s raw value is 3. mars\u0026#39;s raw value is 4. jupiter\u0026#39;s raw value is 5. saturn\u0026#39;s raw value is 6. uranus\u0026#39;s raw value is 7. neptune\u0026#39;s raw value is 8. 在上面的例子中，Planet.mercury的显式原始值为1，Planet.venus的隐式原始值为2，依次类推。\n当使用字符串作为枚举类型的原始值时，每个枚举成员的隐式原始成员值为该枚举成员的名称。\n下面例子是CompassPoint枚举的细化，使用字符串类型的原始值来表示各个方向的名称：\nenum CompassPoints: String { case north, south, east, west } 上面的例子中，CompassPoints.south拥有隐式原始值south，依次类推。\n使用枚举成员的rawValue属性可以访问该枚举成员的原始值：\nextension CompassPoints: CaseIterable {} for point in CompassPoints.allCases { print(\u0026#34;The point\u0026#39;s raw value is \\(point.rawValue).\u0026#34;) } --- output: The point\u0026#39;s raw value is north. The point\u0026#39;s raw value is south. The point\u0026#39;s raw value is east. The point\u0026#39;s raw value is west. 使用原始值初始值枚举实例 如果在定义枚举类型的时候使用了原始值，那么将会自动获得一个初始化方法，这个方法接收一个叫做rawValue的参数，参数类型即为原始值的类型，返回值则是枚举成员或nil。可以使用这个初始化方法来创建一个新的枚举实例。\n这个例子利用原始值7创建了枚举成员Uranus：\nlet possiblePlanet = Planets(rawValue: 7) // possiblePlanet类型为Planets？值为Planets.uranus print(\u0026#34;\\(possiblePlanet!)\u0026#39;s raw value is \\(possiblePlanet!.rawValue).\u0026#34;) --- output: uranus\u0026#39;s raw value is 7. 然而，并非所有Int值都可以找到一个匹配的行星🪐。因此，原始值构造器总是返回一个可选的枚举成员。在上面的例子中，possiblePlanet是Planets?类型，或者说“可选的Planets”。\n注意\n原始值构造器是一个可失败的构造器，因为并不是每一个原始值都有与之对应的枚举成员。\n如果试图寻找一个位置为11的行星🪐，通过原始值构造器返回的Planets值将是nil：\nlet positionToFind = 11 if let somePlanet = Planets(rawValue: positionToFind) { switch somePlanet { case .earth: print(\u0026#34;Mostly harmless.\u0026#34;) default: print(\u0026#34;Not a safe place for humans.\u0026#34;) } } else { print(\u0026#34;There isn\u0026#39;t a planet at position \\(positionToFind).\u0026#34;) } // 打印输出“There isn\u0026#39;t a planet at position 11.” --- output: There isn\u0026#39;t a planet at position 11. 这个例子使用了可选绑定（Optional Binding），试图通过原始值11来访问这个行星🪐。if let somePlanet = Planets(rawValue: 11)语句创建了一个可选Planets，如果可选Planets的值存在，就会赋值给somePlanet。这个例子中，无法检索到位置11的行星，所以else分支被执行。\n递归枚举 递归枚举是一种枚举类型，它有一个或多个枚举成员使用该枚举类型的实例作为关联值。使用递归枚举时，编译器会插入一个间接层。可以在枚举成员前加上indirect来表示该成员可递归。\n例如，下面的例子中，枚举类型存储了简单的算术表达式：\nenum ArithmeticExpression { case number(Int) indirect case addition(ArithmeticExpression, ArithmeticExpression) indirect case multiplication(ArithmeticExpression, ArithmeticExpression) } 也可以在枚举类型开头加上indirect关键字来表明它的所有成员都是可递归的：\nindirect enum ArithmeticExpressions { case number(Int) case addition(ArithmeticExpressions, ArithmeticExpressions) case multiplication(ArithmeticExpressions, ArithmeticExpressions) } 上面定义的枚举类型可以存储三种算术表达式：纯数字，两个表达式相加，两个表达式相乘。枚举成员addition和multiplication的关联值也是算术表达式\u0026ndash;这些关联值使得嵌套表达式成为可能。例如，表达式(5 + 4) * 2，乘号右边是一个数字，左边则是一个表达式。因为数据是嵌套的，因而用来存储数据的枚举类型也需要支持这种嵌套\u0026ndash;这意味着枚举类型需要支持递归。下面的代码展示了使用ArithmeticExpression这个递归枚举创建表达式(5 + 4) * 2：\nlet five = ArithmeticExpressions.number(5) let four = ArithmeticExpressions.number(4) let sum = ArithmeticExpressions.addition(five, four) let product = ArithmeticExpressions.multiplication(sum, ArithmeticExpressions.number(2)) 要操作具有递归性质的数据结构，使用递归函数是一种直截了当的方式。例如，下面是一个对算术表达式求值的函数：\nfunc evaluate(_ expression: ArithmeticExpressions) -\u0026gt; Int { switch expression { case let .number(value): return value case let .addition(left, right): return evaluate(left) + evaluate(right) case let .multiplication(left, right): return evaluate(left) * evaluate(right) } } print(evaluate(product)) // 打印输出“18” --- output: 18 ","date":"2021-08-25T00:00:00Z","permalink":"https://jen-jon.github.io/posts/enumerations/","tags":"iOS; Swift; Apple","title":"Swift学习(10)-枚举（代码完善版）","type":"technology"},{"contents":"闭包是自包含的函数代码块，可以在代码中被传递和使用。Swift中的闭包与C和Objective-C中的代码块（blocks）以及Python语言中的匿名函数（Lambdas）比较相似。\n闭包可以捕获和存储其所在上下文中任意常量和变量的引用。被称为包裹常量和变量。Swift会管理在捕获过程中涉及到的所有内存操作。\n注意\n如果不熟悉捕获这个概念（Capturing）也不必担心，在值补货章节有它更详细的介绍。】\n在函数章节中介绍的全局和嵌套函数实际上也是一种特殊的闭包，闭包采用如下三种形式之一：\n全剧函数是一个有名字但不会捕获任何值的闭包 嵌套函数是一个有名字且可以捕获其封闭函数域内值的闭包 闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包 Swift的闭包表达式拥有简洁的风格，并鼓励在常见场景中进行语法优化，主要优化如下：\n利用上下文推断出参数和返回值类型 隐式返回单表达式闭包，即单表达式闭包可以省略return关键字 参数名称缩写 尾随闭包语法 闭包表达式 嵌套函数作为复杂函数的一部分时，它自包含代码块式的定义和命名形式在使用上带来了方便。当然，编写未完整声明和没有函数名的类函数结构代码是很有用的，尤其是在编码中涉及到函数作为参数的那些方法时。\n闭包表达式是一种构建内联闭包的方式，它的语法简洁，在保证不丢失它语法清晰明了的同时，闭包表达式提供了几种优化的语法简写形式。下面通过对sorted(by:)这一案例的多次迭代改进来展示这个过程，每次迭代都使用了更加简明的方式描述了相同的功能。\n排序方法 Swift标准库提供了名为sorted(by:)的方法，它会基于开发者提供的排序闭包表达式的判断结果对数组中的值（类型确定）进行排序。一旦它完成排序过程，sorted(by:)方法会返回一个与旧数组类型大小相同的类型的新数组，该数组的元素有着正确的排序顺序。原数组不会被sorted(by:)方法修改。\n下面的闭包表达式示例使用sorted(by:)方法对一个String类型的数组进行字母逆序排序。以下是初始数组：\nlet names = [\u0026#34;Chris\u0026#34;, \u0026#34;Alex\u0026#34;, \u0026#34;Ewa\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;Jensen\u0026#34;] sorted(by:)方法接受一个闭包，该闭包函数需要传入与数组元素类型相同的两个值，并返回一个布尔类型值来表明当排序结束后传入的第一个参数排在第二个参数的前面还是后面。如果第一个参数值出现在第二个参数值的前面，排序闭包函数需要返回true，反之返回false。\n该例子对一个String类型的数组进行排序，因此排序闭包函数类型需为(String, String) -\u0026gt; Bool。\n提供排序闭包函数的一种方式是撰写一个复合其要求的普通函数，并将其作为sorted(by:)方法的参数传入：\nfunc backward(_ s1: String, _ s2: String) -\u0026gt; Bool { return s1 \u0026gt; s2 } var reversedNames = names.sorted(by: backward) // reversedNames为[\u0026#34;Jensen\u0026#34;, \u0026#34;Ewa\u0026#34;, \u0026#34;Chris\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;Alex\u0026#34;] print(\u0026#34;复杂闭包逆序：\\(reversedNames).\u0026#34;) --- output: 复杂闭包逆序：[\u0026#34;Jensen\u0026#34;, \u0026#34;Ewa\u0026#34;, \u0026#34;Chris\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;Alex\u0026#34;]. 如果第一个字符串（s1）大于第二个字符串（s2），backward(_:_:)函数会返回true，表示在新的数组中s1应该出现在s2之前。对于字符串中的字符来说，“大于”表示“按照字母顺序较晚出现”。这意味着字母“B”大于字母“A”，字符串“Tom”大于字符串“Tim”。该闭包将进行字母的逆序排序，“Jensen”将会排在“Eva”的前面。\n然而，以这种方式来编写一个实际上很简单的表达式（a \u0026gt; b），确实太过繁琐了。对于这个例子来说，利用闭包表达式语法可以更好地构造一个内联排序闭包。\n闭包表达式语法 闭包表达式语法有如下的一般形式：\n/* { (parameters) -\u0026gt; return type in statements } */ 闭包表达式参数可以是in-out参数，但不能设定默认值。如果命名了可变参数，也可以使用此可变参数，元组可以作为参数和返回值。\n下面的例子展示了之前backward(_:_:)函数对应的闭包表达式版本的代码：\nreversedNames = names.sorted(by: { (s1: String, s2: String) -\u0026gt; Bool in return s1 \u0026gt; s2 }) print(\u0026#34;内联闭包表达式逆序：\\(reversedNames).\u0026#34;) --- output: 内联闭包表达式逆序：[\u0026#34;Jensen\u0026#34;, \u0026#34;Ewa\u0026#34;, \u0026#34;Chris\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;Alex\u0026#34;]. 需要注意的是内联闭包参数和返回值类型声明与backward(_:_:)函数类型声明相同。这两种方式中，都写成了(s1: String, s2: String) -\u0026gt; Bool。然而在内联闭包表达式中，函数和返回值类型都写在大括号内，而不是大括号外。\n闭包的函数体部分由关键字in引入。该关键字表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。\n由于这个闭包的函数体部分如此短，以至于可以将其改写成一行代码：\nreversedNames = names.sorted(by: {(s1: String, s2: String) -\u0026gt; Bool in return s1 \u0026gt; s2}) print(\u0026#34;简洁内联闭包表达式逆序：\\(reversedNames).\u0026#34;) --- output: 简洁内联闭包表达式逆序：[\u0026#34;Jensen\u0026#34;, \u0026#34;Ewa\u0026#34;, \u0026#34;Chris\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;Alex\u0026#34;]. 该例中sorted(by:)方法的整体调用保持不变，一对圆括号依然包裹住了方法的整个参数。然而，参数现在变成了内联闭包。\n根据上下文推断类型 因为排序闭包函数是作为sorted(by:)方法的参数传入的，Swift可以推断其参数和返回值类型。sorted(by:)方法被一个字符串数组调用，因此其参数必须是(String, String) -\u0026gt; Bool类型的函数。这意味着(String, String)和Bool类型并不需要作为闭包表达式定义的一部分。因为所有的类型都可以被正确推断，返回箭头-\u0026gt;和围绕在参数周围的括号也可以被省略：\nreversedNames = names.sorted(by: {s1, s2 in return s1 \u0026gt; s2}) print(\u0026#34;隐式推断类型闭包表达式逆序：\\(reversedNames).\u0026#34;) --- output: 隐式推断类型闭包表达式逆序：[\u0026#34;Jensen\u0026#34;, \u0026#34;Ewa\u0026#34;, \u0026#34;Chris\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;Alex\u0026#34;]. 实际上，通过内联闭包表达式构建的闭包作为参数传递给函数或方法时，总是能够推断出闭包的参数和返回值类型。这意味着闭包作为函数或者方法的参数时，几乎不需要利用完整格式构造内联闭包。\n尽管如此，仍然可以明确写出有者完整格式的闭包。如果完整格式的闭包能够提高代码的可读性，则Swift更鼓励采用完整格式的闭包。而在sorted(by:)方法这个例子里，显然闭包的目的就是排序，因此读者能够推测出这个闭包时用于字符串处理的。\n单表达式闭包的隐式返回 单行表达式闭包可以通过省略return关键字来隐式返回单行表达式的结果，如上版本的例子可以改写为：\nreversedNames = names.sorted(by: {s1, s2 in s1 \u0026gt; s2}) print(\u0026#34;极致省略闭包逆序： \\(reversedNames).\u0026#34;) --- output: 极致省略闭包逆序： [\u0026#34;Jensen\u0026#34;, \u0026#34;Ewa\u0026#34;, \u0026#34;Chris\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;Alex\u0026#34;]. 在这个例子中，sorted(by:)方法的参数类型明确了闭包必须返回一个Bool类型值。因为闭包函数体只包含了一个单一表达式（s1 \u0026gt; s2），该表达式返回Bool类型值，因此这里没有歧义，return关键字可以省略。\n参数名称缩写 Swift自动为内联闭包提供了参数名称缩写功能，可以直接通过$0，$1和$2来顺序调用闭包的参数，以此类推。\n如果在闭包表达式中使用参数名称缩写，可以在闭包定义中省略参数列表，并且对应参数名称缩写的类型会通过函数类型进行推断。闭包接受的参数数量取决于所使用的缩写参数的最大编号。 in关键字同样可以被忽略，因为此时闭包表达式完全由闭包函数体构成：\nreversedNames = names.sorted(by: { $0 \u0026gt; $1 }) print(\u0026#34;省略参数名称闭包逆序：\\(reversedNames).\u0026#34;) --- output: 省略参数名称闭包逆序：[\u0026#34;Jensen\u0026#34;, \u0026#34;Ewa\u0026#34;, \u0026#34;Chris\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;Alex\u0026#34;]. 在这个例子中，$0和$1表示闭包中第一个和第二个String类型的参数，因为$1是编号最大的缩写参数，所以可以理解为：该闭包需要两个参数。这里的sorted(by:)函数希望得到一个参数都是字符串的闭包，因此缩写参数$0和$1的类型均为String。\n运算符方法 实际上还有一种更简短的方式来编写上面的闭包表达式。Swift的String类型定义了关于大于号\u0026gt;的字符串实现，其作为一个函数接受两个String类型的参数并返回Bool类型的值。而这正好与sorted(by:)方法的参数需要的函数类型相符合。因此，可以简单地传递一个大于号，Swift可以自动推断找到系统自带的那个字符串函数的实现：\nreversedNames = names.sorted(by: \u0026gt;) 更多关于运算符方法的内容请查看运算符方法\n尾随闭包 如果需要将一个很长的闭包表达式作为最后一个参数传递给函数，将这个闭包替换成尾随闭包的形式很有用。尾随闭包是一个书写在函数圆括号之后的闭包表达式，函数支持将其作为最后一个参数调用。在使用尾随闭包时，不用写出它的参数标签：\n/* func someFunctionThatTakesAClosure(closure: () -\u0026gt; Void) { // 函数体部分 } // 以下是不使用尾随闭包进行函数调用 someFunctionThatTakesAClosure(closure: { // 闭包主体部分 }) // 以下是使用尾随闭包进行函数调用 someFunctionThatTakesAClosure { // 闭包主体部分 } */ 在闭包表达式语法上章节的字符串排序闭包可以作为尾随闭包的形式改写在sorted(by:)方法圆括号的外面：\nreversedNames = names.sorted() { $0 \u0026gt; $1 } print(\u0026#34;尾随闭包：\\(reversedNames).\u0026#34;) --- output: 尾随闭包：[\u0026#34;Jensen\u0026#34;, \u0026#34;Ewa\u0026#34;, \u0026#34;Chris\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;Alex\u0026#34;]. 如果闭包表达式是函数或方法的唯一参数，则当使用尾随闭包时，甚至可以吧()省略掉：\nreversedNames = names.sorted { $0 \u0026gt; $1 } print(\u0026#34;尾随闭包省略（）： \\(reversedNames).\u0026#34;) --- output: 尾随闭包省略（）： [\u0026#34;Jensen\u0026#34;, \u0026#34;Ewa\u0026#34;, \u0026#34;Chris\u0026#34;, \u0026#34;Barry\u0026#34;, \u0026#34;Alex\u0026#34;]. 当闭包非常长以至于不能在一行中进行书写的时候，尾随闭包变得非常有用。举例来说，Swift的Array类型有一个map(_:)方法，这个方法获取一个闭包表达式作为其唯一参数，该闭包表达式会为数组中的每个元素调用一次，并返回该元素所映射的值。具体的映射方式和返回值的类型由闭包来指定。\n当提供给数组的闭包应用于每个数组元素后，map(_:)方法返回一个新的数组，数组中包含了与原数组中元素一一对应的映射后的值。\n下例介绍了如何在map(_:)方法中使用尾随闭包将Int类型数组[16, 58, 510]转换为包含对应String类型的值的数组[\u0026ldquo;OneSix\u0026rdquo;, \u0026ldquo;FiveEight\u0026rdquo;, \u0026ldquo;FiveOneZero\u0026rdquo;]：\nlet digitNames = [ 0: \u0026#34;Zero\u0026#34;, 1: \u0026#34;One\u0026#34;, 2: \u0026#34;Two\u0026#34;, 3: \u0026#34;Three\u0026#34;, 4: \u0026#34;Four\u0026#34;, 5: \u0026#34;Five\u0026#34;, 6: \u0026#34;Six\u0026#34;, 7: \u0026#34;Seven\u0026#34;, 8: \u0026#34;Eight\u0026#34;, 9: \u0026#34;Nine\u0026#34; ] let numbers = [16, 58, 510] 如上代码创建了一个整型数位和它们的英文版本名字相映射的字典，同时还定义了一个准备转换为字符串数组的整形数组。\n现在可以通过传递一个尾随闭包给numbers数组的map(_:)方法来创建对应的字符串版本数组：\nlet strings = numbers.map { (number) -\u0026gt; String in var number = number var output = \u0026#34;\u0026#34; repeat { output = digitNames[number % 10]! + output number /= 10 } while number \u0026gt; 0 return output } // `string`常量被推断为字符串类型数组，即[String] // 其值为[\u0026#34;OneSix\u0026#34;, \u0026#34;FiveEight\u0026#34;, \u0026#34;FiveOneZero\u0026#34;] map(_:)为数组中每一个元素调用了一次闭包表达式，不需要指定闭包的输入参数number的类型，因为可以通过要映射的数组类型进行推断。\n在该例中，局部变量number的值由闭包中的number参数获得，因此可以在闭包函数体内对其进行修改，（闭包或者函数的参数总是常量），闭包表达式指定了返回类型为String，以表明存储映射值的新数组类型为String。\n闭包表达式在每次被调用的时候创建了一个叫做output的字符串并返回。其使用求余运算符（number % 10）计算最后一位数字并利用digitNames字典获取所映射的字符串。这个闭包能够用于创建任意正整数的字符串表示。\n注意\n字典digitNames下标后跟着一个叹号（！），因为字典下标返回一个可选值（Optional Value），表明改键不存在时会查找失败，在上例中，由于可以确定number % 10总是digitNames字典的有效下标，因此叹号可以用于强制解包（Force-Unwrap）存储在下标的可选类型的返回值中的String类型值。\n从digitNames字典中获取的字符串被添加到output的前部，逆序建立了一个字符串版本的数字。（在表达式number % 10中，如果number为16，则返回6，58则返回8，510则返回0。）\nnumber变量之后除以10。因为其是整数，在计算过程中未除尽部分被忽略，因此16变成了1，58变成了5，510变成了51。\n整个或称重复进行，直到number /= 10为0，这时闭包会将字符串output返回，而map(_:)方法则会将字符串添加到映射的数组中。\n在上面的例子中，通过尾随闭包语法，优雅地在函数后封装了闭包的具体功能，而不再需要将整个闭包包裹在map(_:)方法的括号内。\n值捕获 闭包可以在其被定义的上下文中捕获常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包依然可以在闭包函数体内引用和修改这些值。\nSwift中，可以捕获值的闭包的最简单形式是嵌套函数，也就是定义在其他函数的函数体内的函数。嵌套函数可以捕获其外部函数的所有的参数以及定义的常量和变量。\n举个例子，这有个叫做makeIncrementer的函数，其包含了一个叫做incrementer的嵌套函数。嵌套函数incrementer()从上下文中捕获了两个值，runningTotal和amount。捕获这些值之后，makeIncrementer将incrementer作为闭包返回。每次调用intermenter时，其会以amount为增量增加runningTotal的值。\nfunc makeIncrementer(forIncrement amount: Int) -\u0026gt; () -\u0026gt; Int { var runningTotal = 0 func incrementer() -\u0026gt; Int { runningTotal += amount return runningTotal } return incrementer } var testIncrementer = makeIncrementer(forIncrement: 10) testIncrementer() // 此时testIncrementer()的值为10 print(testIncrementer()) // 打印输出20， 10 + 10 --- output: 20 makeIncrementer返回类型为() -\u0026gt; Int。这意味着其返回的是一个函数，而非一个简单类型的值。该函数在每次调用时不接受参数，只返回一个Int类型的值。关于函数返回其他函数的内容，请查看函数类型作为返回类型。\nmakeIncrementer(forIncrement:)函数定义了一个初始值为0的整型变量runningTotal，用来存储当前总计数值。该值为incrementer的返回值。\nmakeIncrementer(forIncrementer:)有一个Int类型的参数，其外部参数名为forIncrement，内部参数名为amount，该参数表示每次incrementer被调用时runningTotal将要增加的量。makeIncrementer函数还定义了一个嵌套函数incrementer，用来执行实际的增加操作。该函数简单地使runningTotal增加amount，并将其返回。\n如果我们单独考虑嵌套函数incrementer()，会发现它有些不同寻常：\n/* func incrementer() -\u0026gt; Int { runningTotal += amount return runningTotal } */ incrementer()函数并没有任何参数，但是在函数体内访问了runningTotal和amount变量。这是因为它从外围函数捕获了runningTotal和amount变量的引用。捕获引用保证了runningTotal和amount变量在调用完makeIncrementer后不会消失，并且保证了在下一次执行incrementer函数时，runningTotal依旧存在。\n注意\n为了优化，如果一个值不会被闭包改变，或者在闭包创建后不会改变，Swift可能会改为捕获并保存一份对值的拷贝。\nSwift也会负责被捕获变量的所有内存管理操作，包括释放不再需要的变量。\n下面是一个使用makeIncrementer的例子：\nlet incrementByTen = makeIncrementer(forIncrement: 10) 该例子定义了一个叫做incrementByTen的常量，该常量指向一个每次调用会将其runningTotal变量增加10的incrementer函数。调用这个函数多次可以得到以下结果：\nincrementByTen() // 返回的值为10 incrementByTen() // 返回的值为20 var result = incrementByTen() // 返回的值为30 print(\u0026#34;三次调用IncrementByTen()返回的结果为：\\(result)。\u0026#34;) --- output: 三次调用IncrementByTen()返回的结果为：30。 如果创建了另外一个incrementer，它会有属于自己的引用，指向一个全新、独立的runningTotal变量：\nlet incrementBySeven = makeIncrementer(forIncrement: 7) result = incrementBySeven() // 返回值为7 print(\u0026#34;Result：\\(result).\u0026#34;) --- output: Result：7. 再次调用原来的incrementByTen会继续增加它自己的runningTotal变量，该变量和incrementBySeven中捕获的变量没有任何联系：\nincrementByTen() // 返回值为40 注意\n如果将闭包赋值给一个类实例的属性，并且该闭包通过访问该实例或其成员而捕获了该实例，那将在闭包和该实例之间构建一个循环强引用。Swift使用捕获列表来打破这种循环强引用。\n闭包是引用类型 上面的例子中，incrementBySeven和incrementByTen都是常量，但是这些常量指向的闭包仍然可以增加其捕获的变量的值。这是因为函数和闭包都是引用类型。\n无论将函数或闭包赋值给一个常量还是变量，实际上都是将变量或者常量的值设置为对应函数或闭包的引用。上面的例子中，指向闭包的引用incrementByTen是一个常量，而非闭包内容本身。\n这也就意味着如果将闭包赋值给了两个不同的常量或变量，两个值都会指向同一个闭包：\nlet alsoIncrementByTen = incrementByTen print(\u0026#34;alsoIncrementByTen的值是：\\(alsoIncrementByTen()).\u0026#34;) --- output: alsoIncrementByTen的值是：50. 逃逸闭包 当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回后才被执行，我们称该闭包从函数中逃逸。当定义接受闭包作为参数的函数时，可以在参数类型前标注@escaping来指明这个闭包是允许“逃逸”出这个函数的。\n一种能使闭包“逃逸”出函数的方法是，将这个闭包保存在一个函数外部定义的变量中。举个例子，很多启动异步操作的函数接受一个闭包参数作为completion handler。这类函数会在异步操作开始之后立刻返回。但是闭包直到异步操作结束时才会被调用。在这种情况下，闭包需要“逃逸”出函数，因为闭包需要在函数返回之后被调用。例如：\nvar completionHandlers: [() -\u0026gt; Void] = [] func someFunctionWithEscapingClosure(completionHandler: @escaping () -\u0026gt; Void) { completionHandlers.append(completionHandler) } someFunctionWithEscapingClosure(_:)函数接受一个闭包作为参数，该闭包被添加到一个函数外定义的数组中。如果不将这个参数标记为@escaping，就会得到一个编译错误(Converting non-escaping parameter \u0026lsquo;completionHandler\u0026rsquo; to generic parameter \u0026lsquo;Element\u0026rsquo; may allow it to escape)。\n将一个闭包标记为@escaping意味着必须在闭包中显式地引用self。比如说，在下面的代码中，传递到someFunctionWithEscapingClosure(_:)中的闭包是一个逃逸闭包，这意味着它需要显式地引用self。相对的，传递到someFunctionWithNoneEscapingClosure(_:)中的闭包是一个非逃逸闭包，这意味着它可以隐式引用self。\nfunc someFunctionWithNoneEscapingClosure(closure: () -\u0026gt; Void) { closure() } class someClass { var x = 10 func doSometing() { someFunctionWithEscapingClosure { self.x = 100 } someFunctionWithNoneEscapingClosure { x = 200 } } } let instance = someClass() instance.doSometing() print(instance.x) // 打印输出“200” completionHandlers.first?() // someFunctionWithEscapingClosure的闭包已经逃逸到外部，函数在返回后，可以调用逃逸的闭包 // xxx.first?() 可选链式调用 print(instance.x) // 打印输出“100” --- output: 200 100 自动闭包 自动闭包是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。这种闭包不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值。这种便利语法能够省略闭包的花括号，用一个普通的表达式来替代显式的闭包。\n我们经常会调用采用自动闭包的函数，但是很少去实现这样的函数。举个例子来说，assert(condition:message:file:line:)函数接受自动闭包作为其condition参数和message参数；它的condition参数仅会在debug模式下被求值，它的message参数仅当condition参数为false时被计算求值。\n自动闭包让开发者能够延迟求值，因为直到调用这个闭包时，代码段才会被执行。延迟求值对于那些有副作用（Side Effect）和高计算成本的代码来说是很有益处的，因为它使得开发者能够控制代码执行的时机。下面的代码展示了闭包如何延时求值：\nvar customersInLine = [\u0026#34;Chris\u0026#34;, \u0026#34;Jensen\u0026#34;, \u0026#34;Ewa\u0026#34;, \u0026#34;Alex\u0026#34;, \u0026#34;Barry\u0026#34;] print(customersInLine.count) // 打印输出“5” let customerProvider = { customersInLine.remove(at: 0) } print(customersInLine.count) // 打印输出“5” print(\u0026#34;NOW SERVING \\(customerProvider())!\u0026#34;) // 打印输出“NOW SERVING Chris!” print(customersInLine.count) // 打印输出“4” --- output: 5 5 NOW SERVING Chris! 4 尽管在闭包的代码中，customersInLine的第一个元素被移除了，不过在闭包被调用之前，这个元素是不会被移除的。如果这个闭包永远不被调用，那么在闭包里面的表达式将永远不会被执行，那意味着列表中的元素永远不会被移除。请注意，customerProvider的类型不是String，而是() -\u0026gt; String，一个没有参数且返回值为String的函数。\n将闭包作为参数传递给函数时，能获得同样的延时求值行为。\n// customersInLine is [\u0026#34;Jensen\u0026#34;, \u0026#34;Ewa\u0026#34;, \u0026#34;Alex\u0026#34;, \u0026#34;Barry\u0026#34;] func server(customer customerProvider: () -\u0026gt; String) { print(\u0026#34;Now serving \\(customerProvider())!\u0026#34;) } server(customer: { customersInLine.remove(at: 0) }) // 打印出“Now serving Jensen!” --- output: Now serving Jensen! 上面的server(customer:)函数接受一个返回顾客的名字的显式的闭包。下面这个版本的server(customer:)完成了相同的操作，不过它没有接受一个显示的闭包，而是通过将参数标记为@autoclosure来接收一个自动闭包。现在可以将该函数当做接受String类型参数（而非闭包）的函数来调用。customerProvider参数将自动转化为一个闭包，因为该参数被标记了@autoclosure特性。\n// customersInLine is [\u0026#34;Ewa\u0026#34;, \u0026#34;Alex\u0026#34;, \u0026#34;Barry\u0026#34;] func server(customer customerProvider: @autoclosure () -\u0026gt; String) { print(\u0026#34;Now Serving \\(customerProvider())!\u0026#34;) } server(customer: customersInLine.remove(at: 0)) // 打印输出“Now Serving Ewa!” --- output: Now Serving Ewa! 注意\n过度使用autoclosures会让代码变得难以理解。上下文和函数名应该能够清晰地表明求值是被延迟执行的。\n如果想让一个自动闭包可以“逃逸”，则应该同时使用@autoclosure和@escaping属性。@escaping属性的讲解见上面的逃逸闭包。\n// customersInLine is [\u0026#34;Alex\u0026#34;, \u0026#34;Barry\u0026#34;] var customerProviders: [() -\u0026gt; String] = [] func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -\u0026gt; String) { customerProviders.append(customerProvider) } collectCustomerProviders(customersInLine.remove(at: 0)) collectCustomerProviders(customersInLine.remove(at: 0)) print(\u0026#34;Collected \\(customerProviders.count) closures.\u0026#34;) // 打印输出“Collected 2 closures.” 现在有两个闭包传入了外部的customerProviders数组 print(customersInLine) // customersInLine is still [\u0026#34;Alex\u0026#34;, \u0026#34;Barry\u0026#34;] for customerProvider in customerProviders { print(\u0026#34;Now serving \\(customerProvider())!\u0026#34;) } // 打印输出“Now serving Alex!” // 打印输出“Now serving Barry!” //print(customersInLine) // 此时customersInLine数组为空 --- output: Collected 2 closures. [\u0026#34;Alex\u0026#34;, \u0026#34;Barry\u0026#34;] Now serving Alex! Now serving Barry! 在上面的代码中，collectCustomerProviders(_:)函数并没有调用传入的customerProvider闭包，而是将闭包追加到了customerProviders数组中，这个数组定义在函数作用域范围外，这意味着数组内的闭包能够在函数返回之后被调用。因此，customerProvider参数必须允许“逃逸”出函数作用域。\n","date":"2021-08-23T00:00:00Z","permalink":"https://jen-jon.github.io/posts/closures/","tags":"iOS; Swift; Apple","title":"Swift学习(9)-闭包（代码完善版）","type":"technology"},{"contents":"函数是一段完成特定任务的独立代码片段。可以通过函数命名来标识某个函数的功能，这个名字可以被用来在需要的时候“调用”这个函数来玩成它的任务。\nSwift统一的函数语法非常灵活，可以用来表示任何函数，包括从最简单的没有参数名字的C风格函数，到复杂的带局部和外部参数名的Objective-C风格函数。参数可以提供默认值，以简化函数调用。参数也可以既当做传入参数也当做传出参数，也就是说，一旦函数执行结束，传入的参数值将被修改。\n在Swift中，每个函数都有一个由函数的参数值类型和返回值类型组成的类型，可以把函数类型当做任何其他普通变量类型一样处理，这样就可以更简单地把函数当做别的函数的参数，也可以从其他函数中返回函数。函数的定义可以写在其他函数定义中，这样可以在嵌套函数范围内实现功能封装。\n函数的定义与调用 当定义一个函数时，可以定义一个或多个有名字和类型的值，作为函数的输入，称为参数，也可以定义某种类型的值作为函数执行结束时的输出，称为返回类型。\n每个函数都有函数名，用来描述函数执行的任务。要使用一个函数时，用函数名来“调用”这个函数，并传给它匹配的输入值（称作实参）。函数的实参必须与函数参数表里的参数的顺序一致。\n下面例子中的函数名字是greet(person:)，之所以叫这个名字，是因为这个函数用一个人的名字当做输入，并返回向这个人问候的语句。为了完成这个任务，需要定义一个输入参数：一个叫做person的String值，和一个包含给这个人问候语的String类型返回值。\nfunc greet(person: String) -\u0026gt; String { let greeting = \u0026#34;Hello, \u0026#34; + person + \u0026#34;!\u0026#34; return greeting } 所有的这些信息汇总起来称为函数的定义，并以func作为前缀。指定函数返回类型时，用返回箭头-\u0026gt;（一个连字符后跟一个右尖括号）后跟返回类型的名称的方式来表示。\n该定义描述了函数的功能，它期望接收什么作为参数和执行结束时它返回的结果是什么类型。这样的定义使得函数可以在别的地方以一种清晰的方式被调用：\nprint(greet(person: \u0026#34;Jensen\u0026#34;)) // 打印输出\u0026#34;Hello, Jensen!\u0026#34; print(greet(person: \u0026#34;Morris\u0026#34;)) // 打印输出\u0026#34;Hello, Morris!\u0026#34; --- output: Hello, Jensen! Hello, Morris! 调用greet(person:)函数时，在圆括号中传给它一个String类型的实参，例如greet(person: \u0026quot;Anna\u0026quot;)。正如上面所示，因为这个函数返回一个String类型的值，所以greet可以被包含在print(_:separator:terminator:)的调用中，用来输出这个函数的返回值。\n注意\nprint(_:separator:terminator:)函数的第一个参数并没有设置一个标签，而其他的参数因为已经有了默认值，因此也是可选的。关于这些函数语法上的变化详见下方关于函数参数标签和参数名以及默认参数值。\n在greet(person:)的函数体中，先定义了一个新的名为greeting的String常量，同时，把对personName的问候消息赋值给了greeting。然后用return关键字把这个问候给返回出去。一旦return greeting被调用，该函数结束它的执行并返回greeting的当前值。\n为了简化这个定义，可以将问候消息的创建和返回写成一句：\nfunc greetAgain(person: String) -\u0026gt; String { return \u0026#34;Hello again, \u0026#34; + person + \u0026#34;!\u0026#34; } print(greetAgain(person: \u0026#34;Jensen\u0026#34;)) // 打印输出\u0026#34;Hello again, Jensen!\u0026#34; --- output: Hello again, Jensen! 函数参数与返回值 函数参数与返回值在Swift中非常灵活。可以定义任何类型的函数，包括从只带一个未名参数的简单函数到复杂的带有表达性参数名和不同参数选项的复杂函数。\n无参数函数 函数可以没有参数，下面这个函数就是一个无参数函数，当被调用时，它返回固定的String消息：\nfunc sayHelloWorld() -\u0026gt; String { return \u0026#34;Hello, World!\u0026#34; } print(sayHelloWorld()) // 打印输出\u0026#34;Hello, World!\u0026#34; --- output: Hello, World! 尽管这个函数没有参数，但是定义中在函数名后面还是需要一对圆括号。当被调用时，也需要在函数名后面写一对圆括号。\n多参数函数 函数可以有多种输入参数，这些参数被包含在函数的圆括号中，以逗号分隔。\n下面这个函数用一个人名和是否已经打过招呼作为输入，并返回对这个人的适当的问候语：\nfunc greet(person: String, alreadyGreeted: Bool) -\u0026gt; String { if alreadyGreeted { return greetAgain(person: person) } else { return greet(person: person) } } print(greet(person: \u0026#34;Jensen\u0026#34;, alreadyGreeted: true)) // 打印输出\u0026#34;Hello again, Jensen!\u0026#34; --- output: Hello again, Jensen! 可以通过在括号内使用逗号分隔来传递一个String参数值和一个标识为alreadyGreeted的Bool值，来调用greet(person:alreadyGreeted:)函数。注意这个函数和上面greet(person:)是不同的。虽然，它们都有着同样的名字greet，但是greet(person:alreadyGreeted:)函数需要两个参数，而greet(person:)只需要一个参数。\n无返回值函数 函数可以没有返回值。下面是greet(person:)函数的另一个版本greets，这个函数直接打印一个String值，而不是返回它：\nfunc greets(person: String) { print(\u0026#34;Hello, \\(person)!\u0026#34;) } greets(person: \u0026#34;Jensen\u0026#34;) // 打印输出\u0026#34;Hello, Jensen!\u0026#34; --- output: Hello, Jensen! 因为这个函数不需要返回值，所以这个函数的定义中没有返回箭头-\u0026gt;和返回类型。\n注意\n严格地说，即使没有明确定义返回值，该greet(person:)函数依然返回一个值。没有明确定义返回类型的函数返回一个Void类型的特殊值，该值为一个空元组，写成()。\n调用函数时，可以忽略该函数的返回值：\nfunc printAndCount(string: String) -\u0026gt; Int { print(string) return string.count } func printWithoutCounting(string: String) { let _ = printAndCount(string: string) } printAndCount(string: \u0026#34;Hello, World\u0026#34;) // 打印输出\u0026#34;Hello, World\u0026#34;，并且返回值12 printWithoutCounting(string: \u0026#34;Hello, World\u0026#34;) // 打印输出\u0026#34;Hello, World\u0026#34;，但是没有任何返回值 --- output: Hello, World Hello, World 第一个函数printAndCount(string:)，输出一个字符串并返回Int类型的字符数。第二个函数printWithoutCounting(string:)调用了第一个函数，但是却忽略了它的返回值，当第二个函数被调用时，消息依然会由第一个函数输出，但是返回值不会被用到。\n注意\n返回值可以被忽略，但是定义了又返回值的函数必须返回一个值，如果在函数定义底部没有返回任何值，将导致编译错误。\n多重返回值函数 可以使用元组（tuple）类型让多个值作为一个复合值从函数中返回。\n下例中定义了一个名为minMax(array:)的函数，作用是一个Int类型的数组中找出最小值与最大值。\nfunc minMax(array: [Int]) -\u0026gt; (min: Int, max: Int) { var currentMin = array[0] var currentMax = array[0] for value in array[1..\u0026lt;array.count] { if value \u0026lt; currentMin { currentMin = value } else if value \u0026gt; currentMax { currentMax = value } } return (currentMin, currentMax) } minMax(array:)函数返回一个包含两个Int值的元组，这些值被标记为min和max，以便查询函数的返回值可以通过名字来访问它们。\n在minMax(array:)的函数体中，在开始的时候设置两个工作变量currentMin和currentMax的值作为数组中的第一个数。然后函数会遍历数组中剩余的值并检查该值是否比currentMin和currentMax更小或更大。最后数组中的最小值和最大值作为一个包含两个Int值的元组返回。\n因为元组的成员值已经被命名，因此可以通过.语法访问检索到的最小值与最大值：\nlet bounds = minMax(array: [8, -6, 2, 109, 3, -71]) print(\u0026#34;Min is \\(bounds.min) and max is \\(bounds.max).\u0026#34;) // 打印输出\u0026#34;Min is -71 and max is 109.\u0026#34; --- output: Min is -71 and max is 109. 需要注意的是，元组的成员不需要在元组从函数中返回时命名，因为它们的名字已经在函数返回类型中指定了。\n可选元组返回类型 如果函数返回的元组类型有可能整个元组都“没有值”，可以使用可选的元组返回类型反映整个元组可以是nil的事实。可以通过在元组类型的右括号后面放置一个问号来定义一个可选元组，例如(Int, Int)?或(String, Int, Bool)?\n注意\n可选元组类型如(Int, Int)?与元组包含可选类型如(Int?, Int?)是不同的。可选的元组类型，整个元组是可选的，而不只是元组中每个元素值。\n前面的minMax(array:)函数返回了一个包含两个Int值的元组。但是函数不会对传入的数组执行任何安全检查，如果array参数是一个空数组，如上定义的minMax(array:)在试图访问array[0]时会触发一个运行时的错误。\n为了安全地处理这个“空数组”问题，将minMax(array:)函数改写为使用可选元组返回类型，并且当数组为空时返回nil:\nfunc MinMax(array: [Int]) -\u0026gt; (min: Int, max: Int)? { if array.isEmpty { return nil } var currentMin = array[0] var currentMax = array[0] for value in array[1..\u0026lt;array.count] { if value \u0026lt; currentMin { currentMin = value } else if value \u0026gt; currentMax { currentMax = value } } return (currentMin, currentMax) } 可以使用可选绑定来检查minMax(array:)函数返回的是一个存在的元组值还是nil：\nif let bounds = MinMax(array: [8, -6, 2, 109, 3, -71]) { print(\u0026#34;Min is \\(bounds.min) and max is \\(bounds.max).\u0026#34;) } // 打印\u0026#34;Min is -71 and max is 109.\u0026#34; if let bounds = MinMax(array: []) { print(\u0026#34;Min is \\(bounds.min) and max is \\(bounds.max).\u0026#34;) } else { print(\u0026#34;Array is null.\u0026#34;) } --- output: Min is -71 and max is 109. Array is null. 隐式返回的函数 如果一个函数的整个函数体是一个单行表达式，这个函数可以隐式地返回这个表达式。举个例子，以后的函数有着同样地作用：\nfunc greeting(for person: String) -\u0026gt; String { \u0026#34;Hello, \u0026#34; + person + \u0026#34;!\u0026#34; } print(greeting(for: \u0026#34;Jensen\u0026#34;)) // 打印输出\u0026#34;Hello, Jensen!\u0026#34; func anotherGreeting(for person: String) -\u0026gt; String { return \u0026#34;Hello, \u0026#34; + person + \u0026#34;!\u0026#34; } print(anotherGreeting(for: \u0026#34;Jensen\u0026#34;)) // 打印输出\u0026#34;Hello, Jensen!\u0026#34; --- output: Hello, Jensen! Hello, Jensen! greeting(for:)函数的完整定义是打招呼内容的返回，这就意味着它能使用隐式返回这样更简短的形式。anotherGreeting(for:)函数返回同样的内容，却因为return关键字显得函数更长。任何一个可以背写成一行return语句的函数都可以忽略return。\n正如将会在“简略的Getter声明”里看到的，一个属性的getter也可以使用隐式返回的形式。\n函数参数标签和参数名称 每个函数参数都有一个参数标签（Argument Label）以及一个参数名称（Parameter Name）。参数标签在调用函数的时候使用；调用的时候需要将函数的参数标签写在对应的参数前面。参数名称在函数的实现中使用，默认情况下，函数参数使用参数名称来作为它们的参数标签。\nfunc someFunction(firstParameterName: Int, secondParameterName: Int) { // 在函数体内，firstParameterName和secondParameterName代表参数中第一个和第二个参数值 } someFunction(firstParameterName: 1, secondParameterName: 2) 所有的参数都必须有一个独一无二的名字。虽然多个参数拥有同样的参数标签是有可能的，但是一个唯一的参数标签能够使得代码更具可读性。\n指定参数标签 可以在参数名称前指定它的参数标签，中间以空格分隔：\nfunc someFunction(argumentLabel parameterName: Int) { // 在函数体内，parameterName代表参数值 } 下面版本的greet(person:)函数，接收一个人的名字和它的家乡，并返回一句问候：\nfunc greet(person: String, from hometown: String) -\u0026gt; String { \u0026#34;Hello \\(person)! Glad you could visit from \\(hometown).\u0026#34; } print(greet(person: \u0026#34;Jensen\u0026#34;, from: \u0026#34;Hefei\u0026#34;)) // 打印输出\u0026#34;Hello Jensen! Glad you could visit from Hefei.\u0026#34; --- output: Hello Jensen! Glad you could visit from Hefei. 参数标签的使用能够让一个函数在调用时更具有表达力，更类似自然语言，并且仍然保持了函数内部的可读性以及清晰的意图。\n忽略参数标签 如果不希望为某个参数添加一个标签，可以使用一个下划线_来替代一个不明确的参数标签。\nfunc someFunction(_ firstParameterName: Int, secondParameterName: Int) { // 在函数体内，firstParameterName和secondParameterName代表参数中第一个和第二个参数值 } someFunction(1, secondParameterName: 2) 如果一个参数有一个标签，那么在调用的时候必须使用参数标签来标记这个参数。\n默认参数值 可以在函数体中通过给参数赋值来为任意一个参数定义默认值（Default Value），当默认值被定义后，调用这个函数时可以忽略这个参数。\nfunc someFunction(parameterWithoutDefault: Int, parameterWithDeafult: Int = 12) { // 如果在调用时候不传第二个参数，parameterWithDefault会被默认赋值为12传入到函数体中。 } someFunction(parameterWithoutDefault: 1) // parameterWithDefault的值为12 someFunction(parameterWithoutDefault: 2, parameterWithDeafult: 6) // parameterWithDefault的值为6 将不带有默认值的参数放在函数参数列表的最前，一般来说，没有默认值的参数更加的重要，将不带默认值的参数放在最前面保证在函数调用时，翡默认参数的顺序是一致的，同时也使得相同的函数在不同情况下调用时显得更为清晰。\n可变参数 一个可变参数（Variadic Parameter）可以接受零个或多个值。函数调用时，可以用可变参数来指定函数参数可以被传入不确定数量的输入值。通过在变量类型名后面加入...的方式来定义可变参数。\n可变参数的传入值在函数体中变为此类型的一个数组。例如，一个叫做numbers的Double...型可变参数，在函数体内可以当做一个numbers的[Double]型数组常量。\n下面的这个函数用来计算一组任意长度数字的算术平均数（Arithmetic Mean）：\nfunc arithmeticMean(_ numbers: Double...) -\u0026gt; Double { var total: Double = 0 for number in numbers { total += number } return total / Double(numbers.count) } print(arithmeticMean(1, 2, 3, 4, 5)) // 打印输出3.0，是这五个数的平均数 print(arithmeticMean(3, 8.25, 18.75)) // 打印输出10.0，是这三个数的平均数 --- output: 3.0 10.0 一个函数能拥有多个可变参数。可变参数后的第一个行参前必须加上实参标签。实参标签用于区分实参是传递给可变参数还是后面的行参。\n输入输出参数 函数参数默认是常量。试图在函数体中更改参数值将会导致编译错误。这意味着不能错误地更改参数值。如果想要一个函数可以修改参数的值，并且想要这些修改在函数调用结束后仍然存在，那么就需要把这个参数定义为输入输出参数（In-Out Parameters）。\n定义一个输入输出参数时，在参数定义前加上inout关键字，一个输入输出参数有传入函数的的值，这个值被函数修改，然后被传出函数，替换原来的值。想获取更多的关于输入输出参数的细节和相关的编译器优化，请查看输入输出参数一节。\n只能传递变量给输入输出参数，不能传入常量或者字面量，因为这些量是不能够被修改的。当传入的参数作为输入输出参数时，需要在参数名前加上\u0026amp;符，表示这个值可以被函数修改。\n注意\n输入输出参数不能有默认值，而且可变参数不能用inout标记。\n下例中，swapTwoInts(_:_:)函数有两个分别叫做a和b的输入输出参数：\nfunc swapTwoInts(_ a: inout Int, _ b: inout Int) { let temporaryA = a a = b b = temporaryA } swapTwoInts(_:_:)函数简单地交换a和b的值。该函数先将a的值存到一个临时常量temporaryA中，然后将b的值赋给a，最后将temporaryA赋值给b。\n可以用两个Int型变量来调用swapTwoInts(_:_:)。需要注意的是，someInt和anotherInt在传入swapTwoInts(_:_:)函数前，都加了\u0026amp;的前缀。\nvar someInt = 3 var anotherInt = 107 swapTwoInts(\u0026amp;someInt, \u0026amp;anotherInt) print(\u0026#34;SomeInt is now \\(someInt), and anotherInt is now \\(anotherInt)!\u0026#34;) // 打印输出\u0026#34;SomeInt is now 107, and anotherInt is now 3!\u0026#34; --- output: SomeInt is now 107, and anotherInt is now 3! 从上面这个例子中，可以看到someInt和anotherInt的原始值在swapTwoInts(_:_:)函数中被修改，尽管它们的定义在函数体外。\n注意\n输入输出参数和返回值是不一样的。上面的swapTwoInts函数并没有定义任何返回值，但仍然修改了someInt和anotherInt的值。输入输出参数是函数对函数体外产生影响的另一种方式。\n函数类型 每个函数都有种特定的函数类型，函数的类型由函数的参数类型和返回类型组成。例如：\nfunc addTwoInts(_ a: Int, _ b: Int) -\u0026gt; Int { a + b } func multiplyTwoInts(_ a: Int, _ b: Int) -\u0026gt; Int { a * b } 这个例子中定义了两个简单的数学函数：addTwoInts和multiplyTwoInts。这两个函数都接收两个Int值，返回一个Int值。\n这两个函数的类型是(Int, Int) -\u0026gt; Int，可以解读为：\n“这个函数类型有两个Int型的参数并返回一个Int型的值”。 下面是另一个例子，一个没有参数，也没有返回值的函数：\nfunc printHelloWorld() { print(\u0026#34;Hello, world!\u0026#34;) } 这个函数的类型是：() -\u0026gt; Void，或者叫“没有参数，并返回Void类型的函数”。\n使用函数类型 在Swift中，使用函数类型就像使用其他类型一样。例如，可以定义一个类型为函数的常量或变量，并将适当的函数赋值给它。\nvar mathFunc: (Int, Int) -\u0026gt; Int = addTwoInts 这段代码可以被解读为：\n“定义一个叫做mathFunc的变量，类型是‘一个有两个Int型的参数并返回一个Int型的值的函数’，并让这个新变量指向addTwoInts函数”。 addTwoInts和mathFunc有同样的类型，所以这个赋值过程在Swift类型检查（Type-Check）中是允许的。\n现在可以使用mathFunc来调用被赋值的函数了：\nprint(\u0026#34;Result: \\(mathFunc(2, 3)).\u0026#34;) // 打印输出\u0026#34;Result: 5.\u0026#34; --- output: Result: 5. 有相同匹配类型的不同函数可以被赋值给同一个变量，就像非函数类型的变量一样：\nmathFunc = multiplyTwoInts print(\u0026#34;Result: \\(mathFunc(2, 3)).\u0026#34;) // 打印输出\u0026#34;Result: 6.\u0026#34; --- output: Result: 6. 就像其他类型一样，当赋值一个函数给常量或者变量时，可以让Swift来推断其函数类型：\nlet anotherMathFunc = addTwoInts // anotherMathFunc被推断为(Int, Int) -\u0026gt; Int类型 函数类型作为参数类型 可以用(Int. Int) -\u0026gt; Int这样的函数类型作为另一个函数的参数类型，这样可以将函数的一部分实现留给函数的调用者来提供：\nfunc printMathResult(_ mathFunc: (Int, Int) -\u0026gt; Int, _ a: Int, _ b: Int) { print(\u0026#34;Result: \\(multiplyTwoInts(a, b)). \u0026#34;) } printMathResult(mathFunc, 8, 2) // 打印输出\u0026#34;Result: 16.\u0026#34; --- output: Result: 16. 这个例子定义了printMathResult(_:_:_:)函数，它有三个参数：第一个参数叫mathFunc，类型是(Int, Int) -\u0026gt; Int，可以传入任何这种类型的函数；第二个和第三个参数叫a和b，它们的类型都是Int，这两个值作为已给出的函数的输入值。\n当printMathResult(_:_:_:)被调用时，它被传入multiplyTwoInts函数和整数8和2.它用传入的8和2调用multiplyTwoInts，并输出结果16。\nprintMathResult(_:_:_:)函数的作用就是输出另一个适当类型的数学函数的调用结果。它不关心传入函数是如何实现的，只关心传入的函数是不是一个正确的类型，这使得printMathResult(_:_:_:)能以一种类型安全（Type—Safe）的方式将一部分功能转给调用者实现。\n函数类型作为返回类型 可以用函数类型作为另一个函数的返回类型，需要做的是在返回箭头-\u0026gt;后写一个完整的函数类型。\n下面的这个例子中定义了两个简单函数，分别是stepForward(_:)和stepBackward(_:)。stepForward(_:)函数返回一个比输入值大1的值，stepBackward(_:)返回一个比输入值小1的值，这两个函数的类型都是(Int) -\u0026gt; Int：\nfunc stepForward(_ input: Int) -\u0026gt; Int { input + 1 } func stepBackward(_ input: Int) -\u0026gt; Int { input - 1 } 如下名为chooseStepFunc(backward:)的函数，它的返回类型是(Int) -\u0026gt; Int类型的函数。chooseStepFunc(backward:)函数根据布尔值backward来返回stepForward(_:)函数或stepBackward(_:)函数：\nfunc chooseStepFunc(backward: Bool) -\u0026gt; (Int) -\u0026gt; Int { backward ? stepBackward : stepForward } 现在可以用chooseStepFunc(backward:)来获得两个函数其中的一个：\nvar currentValue = 3 let moveNearerToZero = chooseStepFunc(backward: currentValue \u0026gt; 0) 上面这个例子中计算出currentValue逐渐接近到0是需要向正数走还是向负数走。currentValue的初始值是3，这意味着currentValue \u0026gt; 0为真（True），这使得chooseStepFunc(backward:)返回stepBackward(_:)函数。一个指向返回函数的引用保存在了moveNearerToZero常量中。\n现在，moveNearerToZero指向了正确的函数，它可以被用来数到零：\nprint(\u0026#34;Counting to zero:\u0026#34;) // Counting to zero: while currentValue != 0 { print(\u0026#34;\\(currentValue)...\u0026#34;) currentValue = moveNearerToZero(currentValue) } print(\u0026#34;Zero!\u0026#34;) // 3... // 2... // 1... // Zero! --- output: Counting to zero: 3... 2... 1... Zero! 嵌套函数 到目前为止，本章中所见到的所有函数都叫全局函数（Global Functions），它们定义在全局域中。也可以吧函数定义在别的函数体中，称作嵌套函数（Nested Functions）。\n默认情况下，嵌套函数是对外界不可见的，但是可以被他们的外围函数（Enclosing Function）调用。一个外围函数也可以返回它的某一个嵌套函数，使得这个函数可以在其他域中被使用。\n可以用返回嵌套函数的方式去重写chooseStepFunc(backward:)函数（chooseStepFunction()）：\nfunc chooseStepFunction(backward: Bool) -\u0026gt; (Int) -\u0026gt; Int { func stepForward(input: Int) -\u0026gt; Int { return input + 1 } func stepBackward(input: Int) -\u0026gt; Int { return input - 1 } return backward ? stepBackward(input:) : stepForward(input:) } var CurrentValue = -4 let MoveNearerToZero = chooseStepFunction(backward: currentValue \u0026gt; 0) // moveNearerToZero now refers to the nested stepForward() function while CurrentValue != 0 { print(\u0026#34;\\(CurrentValue)...\u0026#34;) CurrentValue = MoveNearerToZero(CurrentValue) } print(\u0026#34;Zero!\u0026#34;) // -4... // -3... // -2... // -1... // Zero! --- output: -4... -3... -2... -1... Zero! ","date":"2021-08-22T00:00:00Z","permalink":"https://jen-jon.github.io/posts/function/","tags":"iOS; Swift; Apple","title":"Swift学习(8)-函数（代码完善版）","type":"technology"},{"contents":"Swift提供了多种流程控制结构，包括可以多次执行任务的while循环，基于特定条件选择执行不同代码分支的if、guard和switch语句，还有控制流程跳转到其他代码位置的break和continue语句。\nSwift还提供了for-in循环，用来更简单地遍历数组（Array），字典（Dictionary），区间（Range），字符串（String）和其他序列类型。\nSwift的switch语句比许多类C语言要更加强大。case还可以匹配很多不同的模式，包括范围匹配，元组（tuple）和特定类型匹配。switch语句的case中匹配的值可以声明为临时常量或变量，在case作用域内使用，也可以配合where来描述更复杂的恶匹配条件。\nFor-In循环 可以使用for-in循环来遍历一个集合中的所有元素，例如数组中的元素、范围内的数字或者字符串中的字符。\n以下例子使用for-in遍历一个数组中的所有元素：\nlet names = [\u0026#34;Anna\u0026#34;, \u0026#34;Alex\u0026#34;, \u0026#34;Brian\u0026#34;, \u0026#34;Jack\u0026#34;] for name in names { print(\u0026#34;Hello, \\(name)!\u0026#34;) } // Hello, Anna! // Hello, Alex! // Hello, Brian! // Hello, Jack! --- output: Hello, Anna! Hello, Alex! Hello, Brian! Hello, Jack! 也可以通过遍历一个字典来访问它的键值对。遍历字典时，字典的每项元素会以(Key, Value)元组的形式返回，可以在for-in循环中使用显式的常量名称来解读该元组。下面的例子中，字典的键会被声明为animalName常量，字典的值会被声明为legCount常量：\nlet numberOfLegs = [\u0026#34;Spider\u0026#34;: 8, \u0026#34;Ant\u0026#34;: 6 , \u0026#34;Cat\u0026#34;: 4] for (animalName, legCount) in numberOfLegs { print(\u0026#34;\\(animalName) has \\(legCount) legs!\u0026#34;) } // Cat has 4 legs! // Ant has 6 legs! // Spider has 8 legs! --- output: Ant has 6 legs! Cat has 4 legs! Spider has 8 legs! 字典的内用理论上是无序的，遍历元素时的顺序是无法确定的。将元素插入字典的顺序并不会决定它们被遍历的顺序。\nfor-in循环还可以使用数字范围。下面的例子用来输出乘法表的一部分内容。\nfor index in 1...5 { // 默认循环中的index是常量，其值不可以在循环中被更改。若使用变量可以 for var index in 1...5 {} print(\u0026#34;\\(index) times 5 is \\(index * 5)\u0026#34;) } // 1 times 5 is 5 // 2 times 5 is 10 // 3 times 5 is 15 // 4 times 5 is 20 // 5 times 5 is 25 --- output: 1 times 5 is 5 2 times 5 is 10 3 times 5 is 15 4 times 5 is 20 5 times 5 is 25 例子中用来进行遍历的元素是使用闭区间操作符...表示从1到5的数字区间。index被赋值为闭区间中的第一个数字（1），然后循环中的语句被执行一次。在本例中 ，这个循环只包含一个语句，用来输出当前index值所对应的乘5乘法表的结果。该语句执行后，index的值被更新为闭区间中第二个数字（2），之后print(_:separator:terminator:)函数会再执行一次。整个过程会进行到闭区间的结尾为止。\n上面的例子中，index是一个每次循环遍历开始时被自动赋值的常量。这种情况下，index在使用前不需要声明，只需要将其包含在循环的声明中，就可以对其进行隐式声明，而无需使用let关键字声明。\n如果不需要区间序列内的每一项值，可以使用下划线_替代变量名来忽略这个值：\nlet base = 3 let power = 10 var answer = 1 for _ in 1...power { answer *= base } print(\u0026#34;\\(base) to the power of \\(power) is \\(answer).\u0026#34;) // 输出\u0026#34;3 to the power of 10 is 59049.\u0026#34; --- output: 3 to the power of 10 is 59049. 这个例子计算base这个数的power次幂（本例中，是3的10次幂），从1（3的0次幂）开始做3的乘法，进行10次，使用1到10的闭区间循环。这个计算并不需要知道每一次循环中计数器的具体的值，只需要执行了正确的循环次数即可。下划线符号_（替代循环中的变量）能够忽略当前值，并不提供循环遍历时对值的访问。\n在某些情况下，可能不想使用包括两个端点的闭区间。想象一下，在一个手表上绘制分钟的刻度线。总共60个刻度，从0开始。可以使用半开区间运算符..\u0026lt;来表示一个左闭右开的区间。\nlet minutes = 60 for tickMark in 0..\u0026lt;minutes { // 每一分钟都渲染一个刻度线 } 一些用户可能在其UI中需要较少的刻度，他们可以使用每5分钟作为一个刻度，使用stride(from:to:by:)函数跳过不需要的标记。\nlet minuteInterval = 5 for tickMark in stride(from: 0, to: minutes, by: minuteInterval) { // 每5分钟渲染一个刻度线（0，5，10，15...50，55） } 可以在闭区间使用stride(from:through:by:)函数起到同样地作用：\nlet hours = 12 let hourInterval = 3 for tickMark in stride(from: 3, through: hours, by: hourInterval) { // 每3小时渲染一个刻度线（3，6，9，12） } 以上示例使用for-in循环来遍历范围、数组、字典和字符串。可以用它们来遍历任何集合，包括实现了Sequence协议的自定义类或者集合类型。\n使用for-in循环遍历集合Set\nlet fruitSet: Set\u0026lt;String\u0026gt; = [\u0026#34;Apple\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Peach\u0026#34;] for fruit in fruitSet.sorted() { print(\u0026#34;I love \\(fruit).\u0026#34;) } --- output: I love Apple. I love Orange. I love Peach. While循环 while循环会一直运行一段语句直到条件变成false。这类循环适合使用在第一次迭代前，迭代次数未知的情况下。Swift提供两种while循环形式：\nwhile循环，每次在循环开始时计算条件是否符合； repeat-while循环，每次在循环结束时计算条件是否符合； while while循环从计算一个条件开始，如果条件为true，会重复运行一段语句，直到条件变为false。\n下面是while循环的一般格式：\n/* while condition { statements } */ 下面的例子来玩一个叫做蛇和梯子（也叫做滑道和梯子）的小游戏：\n游戏规则如下：\n游戏盘面包括 25 个方格，游戏目标是达到或者超过第 25 个方格； 每一轮，你通过掷一个六面体骰子来确定你移动方块的步数，移动的路线由上图中横向的虚线所示； 如果在某轮结束，你移动到了梯子的底部，可以顺着梯子爬上去； 如果在某轮结束，你移动到了蛇的头部，你会顺着蛇的身体滑下去。 游戏盘面可以用一个Int数组来表达，数组的长度由一个finalSquare常量存储，用来初始化数组和检测最终胜利的条件。游戏盘面由26个Int 0值初始化，而不是25个（由0到25，一共26个）：\nlet finalSquare = 25 var board = [Int](repeating: 0, count: finalSquare + 1) // 一些方格被设置成特定的值来表示有蛇或者有梯子。梯子底部的方格是一个正值使得可以向上移动，蛇头处的方格是一个负值，会让向下移动： board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02 board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08 3号方格是梯子的底部，会让向上移动到11号方格，使用board[03]等于+08来表示11和3之间的差值。为了对齐语句，这里使用了一元正运算符+i和一元负运算符-i，并且小于10的数字都是用0补齐，这些语法的技巧并不是必要的，只是为了让代码看起来更加整洁。\n玩家由左下角空白处编号为0的方格开始游戏，玩家第一次掷骰子后才会进入到游戏盘面：\nvar square = 0 var diceRoll = 0 while square \u0026lt; finalSquare { // 掷骰子 diceRoll += 1 if diceRoll == 7 { diceRoll = 1 } // 根据点数移动 square += diceRoll if square \u0026lt; board.count { // 顺着梯子爬上去或者顺着🐍滑下来 square += board[square] } print(square, terminator: \u0026#34; \u0026#34;) } print(\u0026#34;Game Over!\u0026#34;) --- output: 1 11 4 8 13 8 18 20 23 27 Game Over! 本例中使用了最简单的方法来模拟掷骰子。diceRoll的值并不是一个随机数，而是以0为初始值，之后每一次while循环，diceRoll的值增加1，然后检测是否超出了最大值。当 diceRoll的值等于7时，就超过了骰子的最大值，会被重置为1。所以diceRoll的取值顺序会一直是1，2，3，4，5，6，1，2等。\n掷完骰子后，玩家向前移动diceRoll个方格，如果玩家移动超过了第25个方格，这个时候游戏将会结束。为了应对这种情况，代码会首先判断square的值是否小于board的count属性，只有小于才会在board[square]上增加square来向前或向后移动。\n注意\n如果没有这个检测（square \u0026lt; board.count），board[square]可能会越界访问board数组导致运行时的错误。\n当本轮while循环运行完毕，会再检测循环条件是否需要再运行一次循环。如果玩家移动到或者超过第25个方格，循环条件结果为false，此时游戏结束。while循环比较适合本例中的这种情况，因为在while循环开始时，我们并不知道游戏要跑多久，只有在达成指定条件时循环才会结束。\nRepeat-While while循环的另外一种形式是repeat-while，它和while的区别是在判断循环条件之前先执行一次循环的代码块，然后重复循环直到条件为false。\n注意\nSwift语言的repeat-while循环和其他语言中的do-while循环是类似的。\n下面是repeat-while循环的一般格式：\n/* repeat { statements } while condition */ 还是蛇和梯子的游戏，使用repeat-while循环来替代while循环，finalSquare、board、square和diceRoll的值初始化同while循环时一样：\nlet FinalSquare = 25 var boards = [Int](repeating: 0, count: FinalSquare + 1) boards[03] = +08; boards[06] = +11; boards[09] = +09; boards[10] = +02 boards[14] = -10; boards[19] = -11; boards[22] = -02; boards[24] = -08 var Square = 0 var DiceRoll = 0 repeat-while的循环版本，循环中第一步就需要去检测是否在梯子或者蛇的方块上，没有梯子会让玩家直接上到第25个方格，所以玩家不会通过梯子直接赢得游戏，这样在循环开始时先检测是否踩在梯子或者蛇上是安全的。\n游戏开始时，玩家在第 0 个方格上，board[0] 一直等于 0， 不会有什么影响：\nrepeat { // 顺着梯子爬上去或者顺着蛇滑下去 Square += boards[Square] // 掷骰子 DiceRoll += 1 if DiceRoll == 7 { DiceRoll = 1 } // 根据点数移动 Square += DiceRoll print(Square, terminator: \u0026#34; \u0026#34;) } while Square \u0026lt; FinalSquare print(\u0026#34;Game Over!\u0026#34;) --- output: 1 3 14 8 13 19 9 20 23 27 Game Over! 检测完玩家是否踩在梯子或者蛇上之后，开始掷骰子，然后玩家向前移动diceRoll个方格，本轮循环结束。\n循环条件（while Square \u0026lt; FinalSquare）和while方式相同，但是只会在循环结束后进行计算。在这个游戏中，repeat-while表现得比while循环更好。repeat-while方式会在条件判断Square没有超出后直接运行Square += boards[Square]，这种方式比起前面while循环的版本，可以省去数组越界的检查。\n条件语句 根据特定的条件执行的代码通常都是十分有用的。当错误发生时，开发者可能想运行额外的代码；或者，当值太大或太小时，向用户显示一条消息。要实现这些功能，就需要使用条件语句。\nSwift提供两种类型的条件语句：if语句和switch语句。通常，当条件为简单且可能情况很少时，使用if语句。而switch语句更适用于当条件复杂、有更多排列组合的时候。并且switch在需要用到模式匹配（Pattern-Matching）的情况下会更有用。\nIf if语句最简单的形式就是只包含一个条件，只有该条件为true时，才执行相关代码：\nvar temperatureInFahrenheit = 30 if temperatureInFahrenheit \u0026lt;= 32 { print(\u0026#34;It\u0026#39;s very cold! Consider wearing a scarf.\u0026#34;) } // 输出\u0026#34;It\u0026#39;s very cold! Consider wearing a scarf.\u0026#34; --- output: It\u0026#39;s very cold! Consider wearing a scarf. 上面的例子会判断温度是否小于等于32华氏度（水的冰点）。如果是，则打印一条消息；否则，不打印任何消息，继续执行if代码块后面的代码。\n当然，if语句允许二选一执行，叫做else从句。也就是当条件为false时，执行else语句：\ntemperatureInFahrenheit = 40 if temperatureInFahrenheit \u0026lt;= 32 { print(\u0026#34;It\u0026#39;s very cold! Consider wearing a scarf.\u0026#34;) } else { print(\u0026#34;It\u0026#39;s not that cold. Wear a t-shirt.\u0026#34;) } // 输出\u0026#34;It\u0026#39;s not that cold. Wear a t-shirt.\u0026#34; --- output: It\u0026#39;s not that cold. Wear a t-shirt. 显然，这两条分支中总有一条会被执行。由于温度已升至40华氏度，不算太冷，没必要再围围巾。因此，else分支就被触发了。\n可以把多个if语句链接在一起，来实现更多分支：\ntemperatureInFahrenheit = 90 if temperatureInFahrenheit \u0026lt;= 32 { print(\u0026#34;It\u0026#39;s very cold. Consider wearing a scarf.\u0026#34;) } else if temperatureInFahrenheit \u0026gt;= 86 { print(\u0026#34;It\u0026#39;s really warm. Don\u0026#39;t forget to wear sunscreen.\u0026#34;) } else { print(\u0026#34;It\u0026#39;s not that cold. Wear a t-shirt.\u0026#34;) } // 输出“It\u0026#39;s really warm. Don\u0026#39;t forget to wear sunscreen.” --- output: It\u0026#39;s really warm. Don\u0026#39;t forget to wear sunscreen. 在上面的例子中，额外的if语句用于判断是不是特别热。而最后的else语句被保留了下来，用于打印既不冷也不热时的消息。\n实际上，当不需要完整判断情况的时候，最后的else语句是可选的：\ntemperatureInFahrenheit = 72 if temperatureInFahrenheit \u0026lt;= 32 { print(\u0026#34;It\u0026#39;s very cold. Consider wearing a scarf.\u0026#34;) } else if temperatureInFahrenheit \u0026gt;= 86 { print(\u0026#34;It\u0026#39;s really warm. Don\u0026#39;t forget to wear sunscreen.\u0026#34;) } 在这个例子中，由于既不冷也不热，所以不会触发if或else if分支，也就不会打印任何消息。\nSwitch switch语句会尝试把某个值与若干个模式（pattern）进行匹配，根据第一个匹配成功的模式，switch语句会执行对应的代码。当有可能的情况较多时，通常用switch语句替换\u001cif语句。\nswitch语句最简单的形式就是把某个值与一个或若干个相同类型的值做比较：\n/* switch some value to consider { case value 1: respond to value 1 case value 2, value 3: respond to value 2 or 3 default: otherwise, do something else } */ switch语句由多个case构成，每个由case关键字开始，为了匹配某些更特定的值，Swift提供了几种方法来进行更复杂的模式匹配，这些模式将在本节的稍后部分提到。\n与if语句类似，每一个case都是代码执行的一条分支，switch语句会决定哪一条分支应该被执行，这个流程被称作根据给定的值切换（Switching）。\nswitch语句必须是完备的。这就是说，每一个可能的值都必须至少有一个case分支与之对应。在某些不可能涵盖所有值的情况下，可以使用默认（default）分支来涵盖其他所有没有对应的值，这个默认分支必须在switch语句的最后面。\n下面的例子使用switch语句了匹配一个名为someCharacter的小写字符：\nlet someCharacter: Character = \u0026#34;z\u0026#34; switch someCharacter { case \u0026#34;a\u0026#34;: print(\u0026#34;The 1st letter of the alphabet.\u0026#34;) case \u0026#34;z\u0026#34;: print(\u0026#34;The last letter of the alphabet.\u0026#34;) default: print(\u0026#34;Some other character.\u0026#34;) } // 输出\u0026#34;The last letter of the alphaet.\u0026#34; --- output: The last letter of the alphabet. 在这个例子中，第一个case分支用于匹配第一个英文字母a，第二个case分支用于匹配最后一个字母z。因为switch语句必须有一个case分支用于覆盖所有可能的字符，而不仅仅是所有的英文字母，所以switch语句使用default分支来匹配除了a和z外的所有值，这个分支保证了switch语句的完备性。\n不存在隐式的贯穿 与C和Objective-C中的switch语句不同，在Swift中，当匹配的case分支中的代码执行完毕后，程序会终止switch语句，而不会继续执行下一个case分支。也就是说，不需要在case分支中显式地使用break语句，这使得switch语句更安全更易用，也避免了漏写break语句导致多个case分支被执行的错误。\n注意\n虽然在Swift中break不是必须的，但是依然可以在case分支中的代码执行完毕前使用break跳出。\n每一个case分支都必须包含至少一条语句。向下面这样书写代码是无效的，因为第一个case分支是空的：\nlet anotherCharacter: Character = \u0026#34;a\u0026#34; switch anotherCharacter { //case \u0026#34;a\u0026#34;: // 无效，这个分支下面没有语句，若取消注释则报错\u0026#39;case\u0026#39; label in a \u0026#39;switch\u0026#39; should have at least one executable statement case \u0026#34;A\u0026#34;: print(\u0026#34;The letter A.\u0026#34;) default: print(\u0026#34;Not the letter A.\u0026#34;) } --- output: Not the letter A. 不像C语言里的switch语句，在Swift中，switch语句不会一起匹配“A”和“a”。避免了意外地从一个case分支贯穿到另外一个，使得代码更安全、也更直观。\n为了让单个case同时匹配a和A，可以将这两个值组合成一个复合匹配，并且用逗号分开。\nlet AnotherCharacter: Character = \u0026#34;a\u0026#34; switch AnotherCharacter { case \u0026#34;A\u0026#34;, \u0026#34;a\u0026#34;: print(\u0026#34;The letter A.\u0026#34;) default: print(\u0026#34;Not the letter A.\u0026#34;) // 输出\u0026#34;The letter A.\u0026#34; } --- output: The letter A. 为了可读性，复合匹配可以写成多行形式。\n注意\n如果想要显式贯穿case分支，请使用fallthrough语句\n区间匹配 case分支的模式也可以是一个值的区间，下面的例子展示了如何使用区间匹配来输出任意数字对应的自然语言格式：\nlet approximateCount = 62 let countedThings = \u0026#34;Moons orbiting Saturn\u0026#34; let naturalCount: String switch approximateCount { case 0: naturalCount = \u0026#34;no\u0026#34; case 1..\u0026lt;5: naturalCount = \u0026#34;a few\u0026#34; case 5..\u0026lt;12: naturalCount = \u0026#34;servel\u0026#34; case 12..\u0026lt;100: naturalCount = \u0026#34;dozens of\u0026#34; case 100..\u0026lt;1000: naturalCount = \u0026#34;hundreds of\u0026#34; default: naturalCount = \u0026#34;many\u0026#34; } print(\u0026#34;There are \\(naturalCount) \\(countedThings).\u0026#34;) // 输出\u0026#34;There are dozens of Moons orbiting Saturn.\u0026#34; --- output: There are dozens of Moons orbiting Saturn. 在上例中，approximateCount在一个switch声明中被评估。每一个case都与之进行比较。因为approximateCount落到了12和100的区间，所以naturalCount等于“dozens of”值，并且此后的执行跳出了switch语句。\n元组 可以使用元组在同一个switch语句中测试多个值，元组中的元素可以是值，也可以是区间。另外，使用下划线_来匹配所有可能的值。\n下面的例子展示了如何使用一个(Int, Int)类型的元组类分类下图中的点(x, y)：\nlet somePoint = (1, 1) switch somePoint { case (0, 0): print(\u0026#34;\\(somePoint) is at the origin.\u0026#34;) case (_, 0): print(\u0026#34;\\(somePoint) is at the x-axis.\u0026#34;) case (0, _): print(\u0026#34;\\(somePoint) is at the y-axis.\u0026#34;) case (-2...2, -2...2): print(\u0026#34;\\(somePoint) is inside the box.\u0026#34;) default: print(\u0026#34;\\(somePoint) is outside of the box.\u0026#34;) } // 输出\u0026#34;(1, 1) is inside the box.\u0026#34; --- output: (1, 1) is inside the box. 在上面的例子中，switch语句会判断某个点是否是原点(0, 0)，是否在红色的x轴上，是否在橘黄色的y轴上，是否在一个以原点为中心的4x4的蓝色矩形里，或者在这个矩形外面。\n不像C语言，Swift允许多个case匹配同一个值。实际上，在这个例子中，点(0, 0)可以匹配所有四个case。但是如果存在多个匹配，那么只会执行第一个被匹配到的case分支。考虑点(0, 0)会首先匹配case(0, 0)，因此剩下的能够匹配的分支都会被忽视掉。\n值绑定（Value Bindings） case分支允许将匹配的值声明为临时常量或变量，并且在case分支体内使用，这种行为被称为值绑定（Value Binding），因为匹配的值在case分支体内，与临时的常量或变量绑定。\n下面的例子将下图中的点(x, y)，使用(Int, Int)类型的元组表示，然后分类表示：\nlet anotherPoint = (2, 1) switch anotherPoint { case (let x, 0): print(\u0026#34;On the x-axis with an x value of \\(x).\u0026#34;) case (0, let y): print(\u0026#34;On the y-axis with a y value of \\(y).\u0026#34;) case let (x, y): print(\u0026#34;Somewhere else at (\\(x), \\(y)).\u0026#34;) } // Somewhere else at (2, 1). --- output: Somewhere else at (2, 1). 在上面的例子中，switch语句会判断某个点是否在红色的x轴上，是否在橘黄色的y轴上，或者不在坐标轴上。\n这三个case都声明了常量x和y的占位符，用于临时获取元组anotherPoint的一个或两个值，第一个case--\u0026gt;case(let x, 0)将匹配一个纵坐标为0的点，并把这个点的横坐标赋值给临时常量x。类似的，第二个case--\u0026gt;case(0, let y)将匹配一个横坐标为0的点，并把这个点的纵坐标赋值给临时常量y。\n一旦声明了这些临时常量，它们就可以在其对应的case分支里使用，在这个例子中，它们用于打印给定点的类型。\n请注意，这个switch语句不包含默认分支，这是因为最后一个case--\u0026gt;case let (x, y)声明了一个可以匹配余下所有值的元组，这使得switch语句已经完备了，因此不需要再书写默认分支。\nwhere case分支的模式可以使用where语句来判断额外的条件。\n下面的例子把下图的点(x, y)进行了分类：\nlet yetAnotherPoint = (1, -1) switch yetAnotherPoint { case let (x, y) where x == y: print(\u0026#34;(\\(x), \\(y)) is on the line x == y.\u0026#34;) case let (x, y) where x == -y: print(\u0026#34;(\\(x), \\(y)) is on the line x == -y.\u0026#34; ) case let (x, y): print(\u0026#34;(\\(x), \\(y)) is just some arbitrary point.\u0026#34;) } // 输出\u0026#34;(1, -1) is on the line x == -y.\u0026#34; --- output: (1, -1) is on the line x == -y. 在上面的例子中，switch语句会判断某个点是否在绿色的对角线x == y上，是否在紫色的对角线x == -y上，或者不在对角线上。\n这三个case都声明了常量x和y的占位符，用于临时获取元组yetAnotherPoint的两个值，这两个常量被用作where语句的一部分，从而创建一个动态的过滤器（filter）。当且仅当where语句的条件为true时，匹配到的case分支才会被执行。\n就像是值绑定中的例子，由于最后一个case分支匹配了余下所有可能的值，switch语句就已经完备了，因此不需要再书写默认分支。\n复合型Cases 当多个条件可以使用同一种方式来处理时，可以将这几种可能放在同一个case后面，并且用逗号隔开。当case后面的任意一种模式匹配的时候，这条分支就会被匹配。并且，如果匹配列表过长，还可以分行书写。\nlet SomeCharacter: Character = \u0026#34;e\u0026#34; switch SomeCharacter { case \u0026#34;a\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;u\u0026#34;: print(\u0026#34;\\(SomeCharacter) is a vowel.\u0026#34;) case \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;f\u0026#34;, \u0026#34;g\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;j\u0026#34;, \u0026#34;k\u0026#34;, \u0026#34;l\u0026#34;, \u0026#34;m\u0026#34;, \u0026#34;n\u0026#34;, \u0026#34;p\u0026#34;, \u0026#34;q\u0026#34;, \u0026#34;r\u0026#34;, \u0026#34;s\u0026#34;, \u0026#34;t\u0026#34;, \u0026#34;v\u0026#34;, \u0026#34;w\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34;z\u0026#34;: print(\u0026#34;\\(SomeCharacter) is a consonant.\u0026#34;) default: print(\u0026#34;\\(SomeCharacter) is not a vowel or a consonant.\u0026#34;) } // 打印输出\u0026#34;e is a vowel.\u0026#34; --- output: e is a vowel. 这个switch语句中的第一个case，匹配了英语中的五个小写元音字母。相似的，第二个case匹配了英语中所有的小写辅音字母。最终，default分支匹配了其它所有字符。\n复合匹配同样可以包含值绑定，复合匹配里所有的匹配模式，都必须包含相同的值绑定，并且每一个绑定都必须获取到相同类型的值。这保证了，无论复合匹配的哪个模式发生了匹配，分支体内的代码都能获取到绑定的值，并且绑定的值都有一样的类型。\nlet stillAnotherPoint = (9, 0) switch stillAnotherPoint { case (let distance, 0), (0, let distance): print(\u0026#34;On the axis, \\(distance) from the origin.\u0026#34;) default: print(\u0026#34;Not on an axis.\u0026#34;) } // 输出\u0026#34;On an axis, 9 from the origin.\u0026#34; --- output: On the axis, 9 from the origin. 上面的case有两种模式：(let distance, 0)匹配了在x轴上的值，(0, let distance)匹配了在y轴上的值。这两个模式都绑定了distance，并且distance在两种模式下，都是整型。这意味着分支体内的代码，只要case匹配，都可以获取到distance的值。\n控制转移语句 控制转移语句改变代码执行的顺序，通过它可以实现代码的跳转。Swift有五种控制转移语句：\ncontinue break fallthrough return throw 下面将会介绍continue、break和fallthrough语句。return语句将会在函数章节讨论，throw语句会在错误抛出章节讨论。\nContinue continue语句告诉一个循环体立刻停止本次循环，重新开始下次循环。就好像在说“本次循环我已经执行完了”，但是并不会离开整个循环体。\n下面的例子把一个小写字符串中的元音字母和空格字符删除，生成了一个含义模糊的短句：\nlet puzzleInput = \u0026#34;Great minds think alike\u0026#34; var puzzleOutput = \u0026#34;\u0026#34; for character in puzzleInput { switch character { case \u0026#34;a\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;u\u0026#34;, \u0026#34; \u0026#34;: continue default: puzzleOutput.append(character) } } print(puzzleOutput) // 输出\u0026#34;Grtmndsthnklk\u0026#34; --- output: Grtmndsthnklk 在上面的代码中，只要匹配到元音字母或者空格字符，就调用continue语句，使本次循环结束，重新开始下次循环。这种行为使switch`匹配到元音字母和空格字符时不做处理，而不是让每一个匹配到的字符都被打印。\nBreak break语句会立刻结束整个控制流的执行。break可以在switch或循环语句中使用，用来提前结束switch或循环语句。\n循环语句中的Break 当在一个循环体中使用break时，会立刻中断该循环体的执行，然后跳转到表示循环体结束的大括号}后的第一行代码。不会再有本次循环的代码被执行，也不会再有下次的循环产生。\nSwitch语句中的Break 当在一个switch代码块中使用break时，会立刻中断该switch代码块的执行，并且跳转到表示switch代码块结束的大括号}后的第一行代码。\n这种特性可以被用来匹配或者忽略一个或多个分支，因为Swift的switch需要包含所有的分支而且不允许有为空的分支，有时为了使意图更明显，需要特意匹配或者忽略某个分支。那么当想忽略某个分支时，可以在该分支内写上break语句，当那个分支被匹配到时，分支内的break语句立即结束switch代码块。\n注意\n当一个switch分支仅仅包含注释时，会被报编译时错误。注释不是代码语句而且也不能让switch分支达到被忽略的效果。应该使用break来忽略某个分支。\n下面的例子通过switch来判断一个Character值是否代表下面四种语言之一。为了简洁，多个值被包含在了同一个分支情况中。\nlet numberSymbol: Character = \u0026#34;三\u0026#34; // 简体中文里的数字3 var possibleIntegerValue: Int? switch numberSymbol { case \u0026#34;1\u0026#34;, \u0026#34;١\u0026#34;, \u0026#34;一\u0026#34;, \u0026#34;๑\u0026#34;: possibleIntegerValue = 1 case \u0026#34;2\u0026#34;, \u0026#34;٢\u0026#34;, \u0026#34;二\u0026#34;, \u0026#34;๒\u0026#34;: possibleIntegerValue = 2 case \u0026#34;3\u0026#34;, \u0026#34;٣\u0026#34;, \u0026#34;三\u0026#34;, \u0026#34;๓\u0026#34;: possibleIntegerValue = 3 case \u0026#34;4\u0026#34;, \u0026#34;٤\u0026#34;, \u0026#34;四\u0026#34;, \u0026#34;๔\u0026#34;: possibleIntegerValue = 4 default: break } if let integerValue = possibleIntegerValue { print(\u0026#34;The integer value of \\(numberSymbol) is \\(integerValue).\u0026#34;) // 输出\u0026#34;The integer value of 三 is 3.\u0026#34; } else { print(\u0026#34;An integer value could not be found for \\(numberSymbol).\u0026#34;) } --- output: The integer value of 三 is 3. 这个例子检查numberSymbol是否拉丁，阿拉伯，中文或者泰语中的1到4之一。如果被匹配到，该switch分支语句给Int?类型变量possibleIntegerValue设置一个整数值。\n当switch代码块执行完成后，接下来的代码通过使用可选绑定来判断possibleIntegerValue是否曾经被设置过值。因为是可选类型的缘故，possibleIntegerValue有一个隐式的初始值nil，所以仅仅当possibleIntegerValue曾被switch代码块的前四个分支中的某一个设置过一个值时，可选的绑定才会被判定为成功。\n在上面的例子中，想要把Character所有的可能性都枚举出来是不现实的，所以使用default分支来包含所有上面没有匹配到字符的情况。由于这个default分支不需要执行任何动作，所以只写了一条break语句。一旦落入到default分支中后，break语句就完成了该分支的所有代码操作，代码继续向下，开始执行if let语句。\n贯穿（Fallthrough） 在Swift里，switch语句不会从上一个case分支跳转到下一个case分支中。相反，只要第一个匹配到的case分支完成了它需要执行的语句，整个switch代码块完成了它的执行。相比之下，C语言要求显式的插入break语句到每个case分支的末尾来阻止自动落入到下一个case分支中。Swift的这种避免默认落入到下一个分支中的特性意味着它的switch功能要比C语言的更加清晰和可预测，可以避免无意识地执行多个case分支从而引发的错误。\n如果确实需要C语言风格的贯穿的特性，可以在每个需要该特性的case分支中使用fallthrough关键字，下面的例子使用fallthrough来创建一个数字的描述语句：\nlet integerToDescribe = 5 var description = \u0026#34;The number \\(integerToDescribe) is \u0026#34; switch integerToDescribe { case 2, 3, 5, 7, 11, 13, 17, 19: description += \u0026#34;a prime number, and also \u0026#34; fallthrough default: description += \u0026#34;an integer.\u0026#34; } print(description) // 打印输出\u0026#34;The number 5 is a prime number, and also an integer.\u0026#34; --- output: The number 5 is a prime number, and also an integer. 这个例子定义了一个String类型的变量description并且给它设置了一个初始值。函数使用switch逻辑来判断integerToDescribe变量的值。当integerTo Describe的值属于列表中的素数之一时，该函数在description后面添加一段文字，来表明这个数字是一个素数，然后使用fallthrough关键字来“贯穿”到default分支中。default分支在description的最后一段添加额外的文字，至此switch代码块执行完了。\n如果integerToDescribe的值不属于列表中的任何素数，那么它不会匹配到第一个switch分支，而这里没有其他特别的分支，因此integerToDescribe匹配到default分支中。\n当switch代码块执行完成后，使用print(_:separator:terminator:)函数打印该数字的描述，在这个例子中，数字5被准确地识别为了一个素数。\n注意\nfallthrough关键字不会检查它下一个将会落入执行的case中的匹配条件，fallthrough简单地使代码继续连接到下一个case代码中，这和C语言标准中的switch语句特性是一样的。\n带标签的语句 在Swift中，可以在循环体和条件语句中嵌套循环体和条件语句来创造复杂的控制流结构。并且，循环体和条件语句都可以使用break语句来提前结束整个代码块。因此，显式地指明break语句想要终止的是哪个循环体或者条件语句会很有用。类似地，如果有很多嵌套的循环体，显示指明continue语句想要影响哪一个循环体也会变得非常有用。\n为了实现这个目的，可以使用标签（Statement Label）来标记一个循环体或者条件语句，对于一个条件语句，可以使用break加标签的方式，来结束这个被标记的语句。对于一个循环语句，可以使用break或者continue加标签，来结束或者继续这条被标记语句的执行。\n声明一个带标签的语句是通过在该语句的关键词的同一行前面放置一个标签，作为这个语句的前导关键词（Introducor Keyword），并且该标签后面更衰一个冒号。下面是一个针对while循环体的标签语法，同样地规则适用于所有的循环体和条件语句。\n/* label name: while condition { statements } */ 下面的例子是前面章节中🐍和🪜的适配版本，在此版本中，将使用一个带有标签的while循环体调用break和continue语句。这次，游戏增加了一个额外的规则：\n为了获胜，必须刚好落在第25个方格中 如果某次掷骰子使得移动超出第25个方块，必须重新掷骰子，直到掷出的骰子数刚好能使得落在第25个方块中。游戏的棋盘和之前的一样。 finalSQUARE、BOARD、SQUARE和diceROLL的值被和之前一样的方式初始化：\nlet finalSQUARE = 25 var BOARD = [Int](repeating: 0, count: finalSQUARE + 1) BOARD[03] = +08; BOARD[06] = +11; BOARD[09] = +09; BOARD[10] = +02 BOARD[14] = -10; BOARD[19] = -11; BOARD[22] = -02; BOARD[24] = -08 var SQUARE = 0 var diceROLL = 0 这个版本的游戏使用while循环和switch语句来实现游戏的逻辑。while循环有一个标签名gameLoop，来表明它是游戏的主循环。\n该while循环体的条件判断语句是while SQUARE != finalSQUARE，这表明必须刚好落在方格25中。\ngameLoop: while SQUARE != finalSQUARE { diceROLL += 1 if diceROLL == 7 { diceROLL = 1 } switch SQUARE + diceROLL { case finalSQUARE: break gameLoop case let newSquare where newSquare \u0026gt; finalSQUARE: continue gameLoop default: SQUARE += diceROLL SQUARE += BOARD[SQUARE] } print(SQUARE, terminator: \u0026#34; \u0026#34;) } print(\u0026#34;Game Over!\u0026#34;) --- output: 1 11 4 8 13 8 18 20 23 16 18 21 Game Over! 每次循环迭代开始时掷骰子。与之前玩家掷完骰子就立即移动不同，这里使用了switch语句来考虑每次移动可能产生的结果，从而决定玩家本次是否能够移动。\n如果骰子数刚好使玩家移动到最终的方格里，游戏结束。break gameLoop语句跳转控制去执行while循环体后的第一行代码，意味着游戏结束。 如果骰子数将会使玩家的移动超出最后的方格，那么这种移动是不合法的，玩家需要重新掷骰子。continue gameLoop语句结束本次while循环，开始下一次循环。 在剩余的所有情况中，骰子数产生的都是合法的移动。玩家向前移动diceROLL个方格，然后游戏逻辑再处理玩家当前是否处于蛇头或者梯子的底部。接着本次循环结束，控制跳转到while循环体的条件判断语句处，再决定是否需要继续执行下次循环。 注意\n如果上述的break语句没有使用gameLoop标签，那么它将会中断switch语句而不是while循环。使用gameLoop标签清晰的表明了break想要中断的是哪个代码块。\n同时请注意，当调用continue gameLoop去跳转到下一次循环迭代时，这里使用gameLoop标签并不是严格必须的。因为在这个游戏中，只有一个循环体，所以continue语句会影响到哪个循环体是没有歧义的。然而continue语句使用gameLoop标签也是没有危害的。这样做符合标签的使用规则，同时参照旁边的break gameLoop，能够使游戏的逻辑更加清晰和易于理解。\n提前退出 像if语句一样，guard的执行取决于一个布尔表达式的布尔值。我们可以使用guard语句来要求条件必须为真时，以执行guard语句后的代码。不同于if语句，一个guard语句总是有一个else从句，如果条件不为真则执行else从句中的代码。\nfunc greet(person: [String: String]) { guard let name = person[\u0026#34;name\u0026#34;] else { return } print(\u0026#34;Hello \\(name)!\u0026#34;) guard let location = person[\u0026#34;location\u0026#34;] else { print(\u0026#34;I hope the weather is nice near you.\u0026#34;) return } print(\u0026#34;I hope the weather is nice in \\(location).\u0026#34;) } greet(person: [\u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;]) // 输出\u0026#34;Hello John!\u0026#34; // 输出\u0026#34;I hope the weather is nice near you.\u0026#34; greet(person: [\u0026#34;name\u0026#34;: \u0026#34;Jensen\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;Hefei\u0026#34;]) --- output: Hello John! I hope the weather is nice near you. 如果guard语句的条件被满足，则继续执行guard语句大括号后的代码。将变量或者常量的可选绑定作为guard语句的条件，都可以保护guard语句后面的代码。\n如果条件不被满足，在else分支上的代码就会被执行。这个分支必须转移控制以退出guard语句出现的代码段。它可以用控制转移语句如return、break、continue或者throw做这件事，或者调用一个不返回的方法或者函数，例如fatalError()。\n相比于可以实现同样功能的if语句，按需要使用guard语句会提升代码的可读性。它可以使代码连贯执行而不需要将它们包含在else块中，它可以使你在紧邻条件判断的地方，处理违规的情况。\n检测API可用性 Swift内置支持检查API可用性，这可以确保不会在当前部署机器上，不小心地使用了不可用的API。\n编译器使用SDK中的可用信息来验证代码中使用的所有API项目在指定的部署目标上是否可用。如果尝试使用一个不可用的API，Swift会在编译的时候报错。\n在if或者guard语句中使用可用性条件（Availability Condition）去有条件的执行一段代码，来在运行时判断调用的API是否可用。编译器使用从可用性条件语句中获取的信息去验证，在这个代码块中调用的API是否可用。\nif #available(iOS 10, macOS 10.12, *) { // 在iOS使用iOS 10的API，在macOS使用macOS 10.12的API } else { // 使用先前版本的iOS和macOS的API } 以上可用性条件的指定，if语句的代码块仅仅在iOS 10或macOS 10.12以及更高版本才能运行，最后一个参数*是必须的，用于指定在所有其他平台中，如果版本号高于你的设备指定的最低版本，if语句的代码块将会执行。\n在它一般的形式中，可用性条件使用了一个平台名字和版本的列表。平台名字可以是iOS，macOS，watchOS和tvOS，除了指定像iOS 8或macOS 10.10的大版本号，也可以指定像iOS 11.2.6以及macOS 10.13.3的小版本号。\n/* if #available(平台名称 版本号, ..., *) { APIs 可用，语句将执行 } else { APIs 不可用，语句将不执行 } */ ","date":"2021-08-21T00:00:00Z","permalink":"https://jen-jon.github.io/posts/controlflow/","tags":"iOS; Swift; Apple","title":"Swift学习(7)-控制流（代码完善版）","type":"technology"},{"contents":"Swift语言提供数组（Array）、集合（Set）和字典（Dictionary）三种基本的集合类型来存储集合数据。数组是有序数据的集。集合是无序无重复数据的集。字典是无序的键值对的集。\nSwift中的数组、集合和字典必须明确其中保存的键和值类型，这样就可以避免插入一个错误数据类型的值。同理，对于获取到的值也可以放心，其数据类型是确定的。\n注意\nSwift数组、集合和字典类型被实现为泛型集合。\n集合的可变性 如果创建一个数组、集合或字典并且把它分配成一个变量，这个集合将会是可变的。这意味着可以在创建之后添加、修改或者删除数据项。如果把数组、集合或者字典分配成常量，那么其就是不可变的，它的大小和内容都不能被改变。\n注意\n在不需要改变集合的时候创建不可变集合是很好的实践。这样做便于开发者理解自己的代码，也能让Swift编译器优化集合的性能。\n数组（Arrays） 数组使用有序列表存储同一类型的多个值。相同的值可以多次出现在一个数组的不同位置中。\n注意\nSwift的Array类型被桥接Foundation中NSArray类。\n数组的简单语法 Swift中数组的完整写法Array\u0026lt;Element\u0026gt;，其中Element是这个数组中唯一允许存在的数据类型。也可以使用像[Element]这样简单的语法。尽管两种形式在功能上是一样的，但是推荐较短的那种，而且在文本中都会使用这种形式来创建数组。\nvar initArray: Array\u0026lt;String\u0026gt; = Array\u0026lt;String\u0026gt;() initArray.append(\u0026#34;hello\u0026#34;) print(\u0026#34;类型Array\u0026lt;String\u0026gt;的数组为：\\(initArray)\u0026#34;) --- output: 类型Array\u0026lt;String\u0026gt;的数组为：[\u0026#34;hello\u0026#34;] 创建一个空数组 可以使用构造语法来创建一个由特定数据类型构成的空数组。\nvar someInts: [Int] = [] print(\u0026#34;someInts is of type [Int] with \\(someInts.count) items.\u0026#34;) // 打印“someInts is of type [Int] with 0 items.” --- output: someInts is of type [Int] with 0 items. 注意，通过构造函数的类型，someInts的值类型被推断为[Int]。\n或者，如果代码上下文中已经提供了类型信息，例如一个函数参数或者一个已经定义好类型的常量或者变量，可以使用空数组语句创建一个空数组，它的写法很简单：[]（一对空方括号）：\nsomeInts.append(3) print(\u0026#34;现在的someInts是：\\(someInts)。\u0026#34;) someInts = [] print(\u0026#34;someInts现在是\\(someInts)，但是依然是[Int]类型的。\u0026#34;) --- output: 现在的someInts是：[3]。 someInts现在是[]，但是依然是[Int]类型的。 创建一个带有默认值的数组 Swift中的Array类型还提供一个可以创建特定大小且所有数据都被默认的构造方法。可以把准备加入新数组的数据项数量（count）和适当类型的初始值（repeating）传入数组构造函数。\nvar threeDoubles = Array(repeating: 0.0, count: 3) // threeDoubles是一种[Double]数组，等价于[0.0, 0.0, 0.0] print(\u0026#34;threeDoubles is \\(threeDoubles)\u0026#34;) --- output: threeDoubles is [0.0, 0.0, 0.0] 通过两个数组相加创建一个数组 可以使用加法操作符+来组合两个已存在的相同类型的数组。新数组的数据类型会从两个数组的数据类型中推断出来。\nvar anotherThreeDoubles = Array(repeating: 2.5, count: 3) // anotherThreeDoubles被推断为[Double]，等价于[2.5, 2.5, 2.5] var sixDoubles = threeDoubles + anotherThreeDoubles // sixDoubles被推断为[Double]，等价于[0.0, 0.0, 0.0, 2.5, 2.5, 2.5] print(\u0026#34;sixDoubles的值为：\\(sixDoubles)\u0026#34;) --- output: sixDoubles的值为：[0.0, 0.0, 0.0, 2.5, 2.5, 2.5] 从数组字面量构造数组 可以使用数组字面量来进行数组构造，这是一种用一个或多个数值构造数组的简单方法。数组字面量是一系列以逗号分割并由方括号包含的数组：\n[value 1, value 2, value 3] 下面这个例子创建了一个叫做shoppingList并且存储String的数组：\nvar shoppingList: [String] = [\u0026#34;Eggs\u0026#34;, \u0026#34;Milk\u0026#34;] // shoppingList已经被构造且拥有两个初始项 print(\u0026#34;shoppingList is \\(shoppingList)\u0026#34;) --- output: shoppingList is [\u0026#34;Eggs\u0026#34;, \u0026#34;Milk\u0026#34;] shoppingList变量被声明为“字符串值类型的数组”，记作[String]。因为这个数组被规定只有String一种数据结构，所以只有String类型可以在其中被存取。在这里，shoppingList数组由两个String值（“Eggs”和“Milk”）构造，并由数组字面量定义。\n注意\nshoppingList数组被声明为变量（var关键字创建）而不是常量（let创建）是因为之后会有更多的数据项被插入其中。\n在上述例子中，字面量仅仅包含两个String值。匹配了该数组的声明（只能包含String数组），所以可以将这个字面量的赋值过程看作用两个初始项来构造shoppingList的一种方式。\n由于Swift的类型推断机制，当使用字面量构造拥有相同类型值数组的时候，不必把数组的类型定义清楚，shoppingList的构造也可以这样写：\nvar shoppingLists = [\u0026#34;Eggs\u0026#34;, \u0026#34;Milk\u0026#34;] 因为所有的数组字面量中的值都是相同类型的，Swift可以推断出[String]是shoppingList中变量的正确类型。\n访问和修改数组 可以通过数组的方法和属性来访问和修改数组，或者使用下标语法。\n可以使用数组的只读属性count来获取数组中的数据项数量：\nprint(\u0026#34;The shopping list contains \\(shoppingLists.count) items.\u0026#34;) --- output: The shopping list contains 2 items. 使用布尔属性isEmpty作为一个缩写形式去检查count属性是否为0：\nif shoppingList.isEmpty { print(\u0026#34;The shopping list is empty.\u0026#34;) } else { print(\u0026#34;The shopping list is not empty.\u0026#34;) } // 打印“The shopping list is not empty.”（shoppinglist不是空的） --- output: The shopping list is not empty. 也可以使用append(_:)方法在数组后面添加新的数据项：\nshoppingList.append(\u0026#34;Flour\u0026#34;) // shoppingList现在有3个数据项，似乎有人在摊煎饼 print(\u0026#34;添加‘Flour’选项后的shoppingList值为：\\(shoppingList)。\u0026#34;) --- output: 添加‘Flour’选项后的shoppingList值为：[\u0026#34;Eggs\u0026#34;, \u0026#34;Milk\u0026#34;, \u0026#34;Flour\u0026#34;]。 除此之外，也可以使用加法赋值运算符+=直接将另一个相同类型数组中的数据添加到数组后面。\nshoppingList += [\u0026#34;Baking Powder\u0026#34;] // shoppingList现在有四项了 shoppingList += [\u0026#34;Chocolate Spread\u0026#34;, \u0026#34;Chinese\u0026#34;, \u0026#34;Butter\u0026#34;] // shoppingList现在有七项了 可以直接使用下标语法来获取数组中的数据项，把所需要的数据项的索引值直接放在数组名称之后的方括号中：\nvar firstItem = shoppingList[0] print(\u0026#34;shoppingList的第一项是：\\(firstItem)。\u0026#34;) --- output: shoppingList的第一项是：Eggs。 注意\n第一项在数组中的索引值是0而不是1。Swift中的数组索引总是从零开始。\n也可以用下标来改变某个有效索引值对应的数据值：\nshoppingList[0] = \u0026#34;Six Eggs\u0026#34; // 现在shoppingList的第一项是“Six Eggs”而不是“Eggs” print(\u0026#34;修改后的shoppingList值为：\\(shoppingList)\u0026#34;) --- output: 修改后的shoppingList值为：[\u0026#34;Six Eggs\u0026#34;, \u0026#34;Milk\u0026#34;, \u0026#34;Flour\u0026#34;, \u0026#34;Baking Powder\u0026#34;, \u0026#34;Chocolate Spread\u0026#34;, \u0026#34;Chinese\u0026#34;, \u0026#34;Butter\u0026#34;] 当使用下标语法，所使用的下标必须是有效的。例如，试图通过shoppingList[shoppingList.count] = \u0026quot;Salt\u0026quot;在数组的最后添加一项，将产生一个运行时的错误。\n还可以利用下标来一次改变一系列数据值，即使新数据和原有数据的数量是不一样的的。下面的例子把“Chocolate Spread”、“Chese”和“Butter”替换为“Bananas”和“Apples”。\nshoppingList[4...6] = [\u0026#34;Bananas\u0026#34;, \u0026#34;Apples\u0026#34;] // shoppingList现在有6项 print(\u0026#34;shoppingList现在是：\\(shoppingList)\u0026#34;) // 通过调用数组的`insert(_:at:)`方法在某个指定索引值前面添加数据项： shoppingList.insert(\u0026#34;Maple Syrup\u0026#34;, at: 0) // shoppingList现在有7项 // 现在是这个列表中的第一项是“Maple Syrup” print(\u0026#34;shopingList现在的第一项是：\\(shoppingList[0])\u0026#34;) // 这次`insert(_:at:)`方法调用把值为\u0026#34;Maple Syrup\u0026#34;的新数据项插入列表的最开始位置，并且使用`0`作为索引值。 --- output: shoppingList现在是：[\u0026#34;Six Eggs\u0026#34;, \u0026#34;Milk\u0026#34;, \u0026#34;Flour\u0026#34;, \u0026#34;Baking Powder\u0026#34;, \u0026#34;Bananas\u0026#34;, \u0026#34;Apples\u0026#34;] shopingList现在的第一项是：Maple Syrup 类似的可以使用remove(at:)方法来移除数组的某一项。这个方法吧数组在特定索引值中存储的数据项移除并且返回这个被移除的数据项（不需要时就可以无视它）。\nlet mapleSyrup = shoppingList.remove(at: 0) // 现在shoppingList只有6项，不包括“Maple Syrup”，常量mapleSyrup等于“Maple Syrup” print(\u0026#34;mapleSyrup的值等于：\\(mapleSyrup)，shoppingList等于：\\(shoppingList).\u0026#34;) --- output: mapleSyrup的值等于：Maple Syrup，shoppingList等于：[\u0026#34;Six Eggs\u0026#34;, \u0026#34;Milk\u0026#34;, \u0026#34;Flour\u0026#34;, \u0026#34;Baking Powder\u0026#34;, \u0026#34;Bananas\u0026#34;, \u0026#34;Apples\u0026#34;]. 注意\n如果试图通过越界索引来执行访问或者修改数据的操作，会引发一个运行时的错误。此时可以使用索引值和数组的count属性进行比较来在使用该索引之前检验其是否有效。除了当count等于0时（说明这是个空数组），最大的索引一直是count - 1，因为数组都是零起索引。\n数据项被移除后数组中的空出项会被自动填补，所以现在的索引值为0的数据项的值再次等于“Six eggs”。\nfirstItem = shoppingList[0] // firstItem现在等于\u0026#34;Six eggs\u0026#34; print(\u0026#34;此时shoppingList首位是：\\(firstItem)\u0026#34;) // 如果只想把数组中的最后一项移除，可以使用`removeList()`方法而不是`remove(at:)`方法来避免需要获取数组的`count`属性。就像后者一样，前者也会返回被移除的数据项。 let apples = shoppingList.removeLast() // 数组的最后一项被移除了，shoppingList现在只有5项，不包括“Apples”，常量apples现在等于字符串“Apples” print(\u0026#34;常量apples现在的值：\\(apples)，shoppingList等于：\\(shoppingList).\u0026#34;) // 同样地还有`removeFirst()`方法，直接移除数组的第一项。 let sixEggs = shoppingList.removeFirst() --- output: 此时shoppingList首位是：Six Eggs 常量apples现在的值：Apples，shoppingList等于：[\u0026#34;Six Eggs\u0026#34;, \u0026#34;Milk\u0026#34;, \u0026#34;Flour\u0026#34;, \u0026#34;Baking Powder\u0026#34;, \u0026#34;Bananas\u0026#34;]. 数组的遍历 可以使用for-in循环来遍历数组中所有的数据项：\nfor item in shoppingList { print(item) // Six eggs; Milk; Flour; Baking Powder; Bananas } --- output: Milk Flour Baking Powder Bananas 如果同时需要每个数据项的值和索引值，可以使用“enumerated()”方法来进行数组遍历。enumerated()返回一个有索引值和数据值组成的元组数据。索引值从零开始，并且每次增加一；如果枚举一整个数组，索引值将会和数据值一一匹配。可以把这个元组分解成临时变量或者变量来进行遍历：\nfor (index, value) in shoppingList.enumerated() { print(\u0026#34;Item \\(String(index + 1)): \\(value)\u0026#34;) // Item 1: Milk; Item 2: Flour; Item 3: Baking Powder; Item 4: Bananas } --- output: Item 1: Milk Item 2: Flour Item 3: Baking Powder Item 4: Bananas 集合（Sets） 集合用来存储相同类型ß但是没有确定顺序的值。当集合元素的顺序不重要时或者希望确保每个元素只出现一次时可以使用集合而不是数组。\n注意\nSwift中的Set类型被桥接到Foundation中的NSSet类。\n集合类型的哈希值 一个类型为了存储在集合中，该类型必须是可哈希化的，也就是说，该类型必须提供一个方法来计算其哈希值。一个哈希值时Int类型的，相等的对象哈希值必须相同，比如a == b，因此必须a.hashValue == b.hashValue。\nSwift的所有基本类型（比如String、Int、Double和Bool）默认都是可哈希化的，可以作为集合值的类型或者字典键的类型。没有关联值的枚举成员值默认也是可以哈希化的。\n注意\n可以使用自定义的类型作为集合值的类型或者是字典键的类型，但需要使自定义的类型遵循Swift标准库中的Hashable协议。遵循Hashable协议的类型需要提供一个类型为Int的可读属性hashValue。由类型的hashValue属性返回的值不需要在同一程序的不同执行周期或者不同程序间保持相同。\n因为Hashable遵循Equatable协议，所以遵循该协议的类型也必须提供一个“是否相等”运算符（==）的实现。这个Equatable协议要求任何遵循 == 实现的实例间都是一种相等的关系。也就是说，对于a，b，c三个值来说，==的实现必须满足下面三种情况：\na == a（自反性） a == b 意味着 b == a（对称性） a == b \u0026amp;\u0026amp; b == c 意味着 a == c（传递性） 集合类型语法 Swift中的集合类型被写为Set\u0026lt;Element\u0026gt;，这里的Element表示集合中允许存储的类型。和数组不同的是，集合没有等价的简化形式。\n创造和构建一个空的集合 可以通过构造器语法创建一个特定类型的空集合\nvar letters = Set\u0026lt;Character\u0026gt;() print(\u0026#34;Letters is of type Set\u0026lt;Character\u0026gt; with \\(letters.count) items.\u0026#34;) // 打印输出“Letters is of type Set\u0026lt;Character\u0026gt; with 0 items.” --- output: Letters is of type Set\u0026lt;Character\u0026gt; with 0 items. 注意\n通过构造器，这里的letters变量的类型被推断为Set。\n此外，如果上下文提供了类型信息，比如作为函数的参数或者已知类型的变量或常量，可以通过一个空的数组字面量创建一个空的集合。\nletters.insert(\u0026#34;A\u0026#34;) // letters现在含有1个Character类型的值 print(\u0026#34;现在Letters值为：\\(letters)\u0026#34;) letters = [] // letters现在是一个空的Set，但是它依然是Set\u0026lt;Character\u0026gt;类型 print(\u0026#34;此时Letters值为：\\(letters)\u0026#34;) --- output: 现在Letters值为：[\u0026#34;A\u0026#34;] 此时Letters值为：[] 用数组字面量创建集合 可以使用数组字面量来构造集合，相当于一种简化的形式将一个或多个值作为集合元素。\n下面的例子创建一个称之为favoriteGenres的集合来存储String类型的值。\nvar favoriteGenres: Set\u0026lt;String\u0026gt; = [\u0026#34;Rock\u0026#34;, \u0026#34;Classical\u0026#34;, \u0026#34;Hip hop\u0026#34;] // favoriteGenres被构造成含有三个初始值的集合 这个favoriteGenres变量被声明为“一个String值的集合”，写为Set\u0026lt;String\u0026gt;。由于这个特定集合指定了值为String类型，所以它只允许存储String类型的值。这里的favoriteGenres变量有三个String类型的初始值（“Rock”，“Classical”，“Hip hop”），以数组字面量形式书写。\n注意\nfavoriteGenres被声明为一个变量（拥有var标识符）而不是一个常量（拥有let标识符），因为它里面的元素将会在之后的例子中被增加或者移除。\n一个集合类型不能从数组字面量中被直接推断出来，因此Set类型必须显式声明。然而，由于Swift的类型推断功能，如果想使用一个数组字面量构造一个集合并且与该数组字面量中的所有元素类型相同，那么无须写出结合的具体类型。FavoriteGenres的构造形式可以采用简化的方式代替。\nvar FavoriteGenres: Set = [\u0026#34;Rock\u0026#34;, \u0026#34;Classical\u0026#34;, \u0026#34;Hip hop\u0026#34;] 由于数组字面量中的所有元素类型相同均为“String”，Swift可以推断出Set\u0026lt;String\u0026gt;作为favoriteGenres变量的正确类型。\n访问和修改一个集合 可以通过集合的属性和方法来对其进行访问和修改\n为了获取一个集合中元素的数量，可以使用其只读属性count：\nprint(\u0026#34;I have \\(FavoriteGenres.count) favorite music genres.\u0026#34;) // 打印“I have 3 favorite music genres.” --- output: I have 3 favorite music genres. 使用布尔属性isEmpty作为一个缩写形式去检查count属性是否为0：\nif FavoriteGenres.isEmpty { print(\u0026#34;As far as music goes, I\u0026#39;m not picky.\u0026#34;) } else { print(\u0026#34;I have particular music preferences.\u0026#34;) } // 打印“I have particular music preferences.” --- output: I have particular music preferences. 可以通过调用集合的insert(_:)方法来添加一个新元素：\nFavoriteGenres.insert(\u0026#34;Jazz\u0026#34;) // FavoriteGenres现在包含4个元素。 print(\u0026#34;FavoriteGenres现在包含\\(FavoriteGenres.count)个元素，其值为：\\(FavoriteGenres)\u0026#34;) --- output: FavoriteGenres现在包含4个元素，其值为：[\u0026#34;Classical\u0026#34;, \u0026#34;Jazz\u0026#34;, \u0026#34;Hip hop\u0026#34;, \u0026#34;Rock\u0026#34;] 可以通过调用集合的remove(_:)方法去删除一个元素，如果它是该集合的一个元素则删除它并且返回它的值，若该集合不包含它，则返回nil。另外，集合可以通过removeAll()方法删除所有元素。\nif let removeGenre = FavoriteGenres.remove(\u0026#34;Rock\u0026#34;) { print(\u0026#34;\\(removeGenre)? I\u0026#39;m over it!\u0026#34;) } else { print(\u0026#34;I never much cared of that!\u0026#34;) } // 打印“Rock? I\u0026#39;m over it!” --- output: Rock? I\u0026#39;m over it! 使用contains(_:)方法去检查集合中是否包含一个特定的值：\nif FavoriteGenres.contains(\u0026#34;Funk\u0026#34;) { print(\u0026#34;I get up on the good foot.\u0026#34;) } else { print(\u0026#34;It\u0026#39;s too funky in here.\u0026#34;) } // 打印\u0026#34;It\u0026#39;s too funky in here.\u0026#34; --- output: It\u0026#39;s too funky in here. 遍历一个集合 可以在一个for-in循环中遍历一个集合中的所有值。\nfor genre in FavoriteGenres { print(\u0026#34;\\(genre)\u0026#34;) } // Hip hop; // Classical; // Jazz 无序排列 --- output: Classical Jazz Hip hop Swift的Set类型没有确定的顺序，为了按照特定顺序来遍历一个集合中的值可以使用sorted()方法，它将返回一个有序数组，这个数组的元素排列顺序由操作符\u0026lt;对元素进行比较的结果来确定。\nfor genre in FavoriteGenres.sorted() { print(\u0026#34;\\(genre)\u0026#34;) } // Classical; // Hip hop; // Jazz 有序排列 --- output: Classical Hip hop Jazz 集合操作 可以高效地完成集合的一些基本操作，比如把两个集合组合到一起，判断两个集合的共有元素，或者判断两个集合是否全包含，部分包含或者不相交。\n基本集合操作 使用intersection(_:)方法根据两个集合的交集创建一个新的集合。 使用symmetricDifference(_:)方法根据两个集合不相交的值创建一个新的集合。 使用union(_:)方法根据两个集合的所有值创建一个新的集合 使用subtracting(_:)方法根据不在另一个集合中的值创建一个新的集合。 let oddDigits: Set = [1, 3, 5, 7, 9] let evenDigits: Set = [0, 2, 4, 6, 8] let singleDigitPrimeNumbers: Set = [2, 3, 5, 7] print(\u0026#34;Union: \\(oddDigits.union(evenDigits).sorted())\u0026#34;) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] print(\u0026#34;InterSection: \\(oddDigits.intersection(evenDigits).sorted())\u0026#34;) // [] print(\u0026#34;SubTracting: \\(oddDigits.subtracting(singleDigitPrimeNumbers).sorted())\u0026#34;) // [1, 9] print(\u0026#34;SymmetricDifference: \\(oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted())\u0026#34;) // [1, 2, 9] --- output: Union: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] InterSection: [] SubTracting: [1, 9] SymmetricDifference: [1, 2, 9] 集合成员关系和相等 使用“是否相等”运算符==来判断两个集合包含的值是否相同。 使用isSubset(of:)方法来判断一个集合中的所有值是否也被包含在另外一个集合中。 使用isSpuerset(of:)方法来判断一个集合是否包含另一个集合中的所有值。 使用isScrictSubset(of:)或者isScrictSuperset(of:)方法来判断一个集合是否是另外一个集合的子集或者父集合并且两个集合不相等。 使用isDisjoint(with:)方法来判断两个集合是否不含有相同的值（是否没有交集）。 let houseAnimals: Set = [\u0026#34;🐶\u0026#34;, \u0026#34;🐱\u0026#34;] let farmAnimals: Set = [\u0026#34;🐮\u0026#34;, \u0026#34;🐔\u0026#34;, \u0026#34;🐑\u0026#34;, \u0026#34;🐶\u0026#34;, \u0026#34;🐱\u0026#34;] let cityAnimals: Set = [\u0026#34;🐦\u0026#34;, \u0026#34;🐭\u0026#34;] print(\u0026#34;IsSubset? \\(houseAnimals.isSubset(of: farmAnimals))\u0026#34;) // 打印输出\u0026#34;IsSubset? true\u0026#34; print(\u0026#34;IsSuperset? \\(farmAnimals.isSuperset(of: houseAnimals))\u0026#34;) // 打印输出\u0026#34;IsSuperset? true\u0026#34; print(\u0026#34;IsDisjoint? \\(farmAnimals.isDisjoint(with: cityAnimals))\u0026#34;) // 打印输出\u0026#34;IsDisjoint? true\u0026#34; --- output: IsSubset? true IsSuperset? true IsDisjoint? true 字典 字典是一种无序的集合，它存储的是键值对之间的关系，其所有的值需要是相同的类型，所有值的类型也需要相同。每个值（value）都关联唯一的键（key），键作为字典中这个值数据的标识符。和数组中的数据项不同，字典中的数据项并没有具体的顺序。在需要通过标识符（键）访问数据的时候使用字典，这种方法很大程度上和现实世界中使用字典查字义的方法一样。\n注意\nSwift的Dictionary类型被桥接到Foundation的NSDictionary类。\n字典类型简化语法 Swift的字典使用Dictionary\u0026lt;Key, Value\u0026gt;定义，其中Key是一种可以在字典中被用作键的类型，Value是字典中对应于这些键所存储值的数据类型。\n注意\n一个字典的Key类型必须遵循Hashable协议，就像Set的值类型。\n也可以使用[Key: Value]这样简化的形式去表示字典类型。虽然这两种形式功能上相同，但是后者是首选，并且本教程中涉及到字典类型时通篇采用后者。\n创建一个空字典 可以像数组一样使用构造语法创建一个拥有确定类型的空字典：\nvar namesOfInteger: Dictionary\u0026lt;Int, String\u0026gt; = Dictionary\u0026lt;Int, String\u0026gt;() // 使用Dictionary\u0026lt;Key, Value\u0026gt;定义字典 print(\u0026#34;使用Dictionary\u0026lt;Key, Value\u0026gt;定义字典：\\(namesOfInteger)\u0026#34;) var namesOfIntegers: [Int: String] = [:] // 简化语法，首选！ print(\u0026#34;简化语法，首选：\\(namesOfIntegers)\u0026#34;) --- output: 使用Dictionary\u0026lt;Key, Value\u0026gt;定义字典：[:] 简化语法，首选：[:] 这个例子创建了一个[Int: String]类型的空字典来存储整数的英语命名。它的键是Int型，值是String型。\n如果上下文已经提供了类型信息，可以使用空字典字面量来创建一个空字典，记作[:]（一对方括号中放一个冒号）：\nnamesOfIntegers[16] = \u0026#34;sixteen\u0026#34; // namesOfIntegers现在包含一个键值对 namesOfIntegers = [:] // namesOfIntegers又成为了一个[Int: String]类型的空字典 用字典字面量创建字典 可以使用字典字面量来构造字典，这和刚才介绍过的数组字面量拥有相似的语法。字典字面量是一种将一个或多个键值对写作Dictionary集合的快捷途径。\n一个键值对是一个键和一个值的结合体，在字典字面量中，每一个键值对的键和值都由冒号分割。这些键值对构成一个列表，其中这些键值对由逗号分割、并整体被包裹在一对方括号中：\n// [key 1: value 1, key 2: value 2, key 3: value 3] 下面的例子创建了一个存储国际机场名称的字典。在这个字典中键是三个字母的国际航空运输相关代码，值是机场名称：\nvar airposts: [String: String] = [\u0026#34;HFE\u0026#34;: \u0026#34;Hefei Xinqiao\u0026#34;, \u0026#34;NKG\u0026#34;: \u0026#34;Nanjing Lukou\u0026#34;, \u0026#34;PKX\u0026#34;:\u0026#34;Beijing Daxing\u0026#34;, \u0026#34;SHA\u0026#34;:\u0026#34;Shanghao Hongqiao\u0026#34;] print(\u0026#34;China Main Airpots: \\(airposts)\u0026#34;) --- output: China Main Airpots: [\u0026#34;HFE\u0026#34;: \u0026#34;Hefei Xinqiao\u0026#34;, \u0026#34;NKG\u0026#34;: \u0026#34;Nanjing Lukou\u0026#34;, \u0026#34;PKX\u0026#34;: \u0026#34;Beijing Daxing\u0026#34;, \u0026#34;SHA\u0026#34;: \u0026#34;Shanghao Hongqiao\u0026#34;] airports字典被声明为一种[String: String]类型，这意味着这个字典的键和值都是String类型。\n注意\nairports字典被声明为变量（用var关键字）而不是常量（用let关键字）因为后面会有更多的机场被添加到这个字典中。\nairports字典使用字典字面量初始化，包含四个键值对。它们对应airports变量声明的类型（一个只有String键和String值的字典），所以这个字典字面量的赋值是一种方式用来构造拥有四个初始数据项的airports字典。\n和数组一样，在用字典字面量构造字典时，如果其键和值都有各自一致的类型，那就不必写出字典的类型，airports字典也可以用这种简短的方式定义：\nvar chinaAirports = [\u0026#34;HFE\u0026#34;: \u0026#34;Hefei Luogang\u0026#34;, \u0026#34;NKG\u0026#34;: \u0026#34;Nanjing Lukou\u0026#34;, \u0026#34;PKX\u0026#34;:\u0026#34;Beijing Daxing\u0026#34;, \u0026#34;SHA\u0026#34;:\u0026#34;Shanghao Hongqiao\u0026#34;] 因为这个语句中所有的键值都各自拥有相同的数据类型，Swift可以推断出[String: String]是airports字典的正确类型。\n访问和修改字典 可以通过字典的方法和属性来访问和修改字典，或者通过使用下标语法。\n和数组一样，可以通过Dictionary的只读属性count来获取字典的数据项数量：\nprint(\u0026#34;The dictionary of chinaAirports contains \\(chinaAirports.count) items.\u0026#34;) // 打印\u0026#34;The dictionary of chinaAirports contains 4 items.\u0026#34; --- output: The dictionary of chinaAirports contains 4 items. 使用布尔属性isEmpty作为一个缩写去检查count属性是否为0：\nif chinaAirports.isEmpty { print(\u0026#34;The chinaAirports dictionary is empty.\u0026#34;) } else { print(\u0026#34;The chinaAirports dictionary is not empty.\u0026#34;) } // 打印\u0026#34;The chinaAirports dictionary is not empty.\u0026#34; --- output: The chinaAirports dictionary is not empty. 可以通过下标语法来个字典添加新的数据项，可以使用一个恰当类型的键作为下标索引，并且分配恰当类型的新值：\nairposts[\u0026#34;XIY\u0026#34;] = \u0026#34;Xi\u0026#39;an\u0026#34; // airports字典现在有五个数据项 print(airposts) --- output: [\u0026#34;HFE\u0026#34;: \u0026#34;Hefei Xinqiao\u0026#34;, \u0026#34;NKG\u0026#34;: \u0026#34;Nanjing Lukou\u0026#34;, \u0026#34;PKX\u0026#34;: \u0026#34;Beijing Daxing\u0026#34;, \u0026#34;XIY\u0026#34;: \u0026#34;Xi\\\u0026#39;an\u0026#34;, \u0026#34;SHA\u0026#34;: \u0026#34;Shanghao Hongqiao\u0026#34;] 也可以使用下标语法来改变特定键对应的值：\nairposts[\u0026#34;XIY\u0026#34;] = \u0026#34;Xi\u0026#39;an Xianyang\u0026#34; // \u0026#34;XIY\u0026#34;对应的值被修改为\u0026#34;Xi\u0026#39;an Xianyang\u0026#34; print(airposts) --- output: [\u0026#34;HFE\u0026#34;: \u0026#34;Hefei Xinqiao\u0026#34;, \u0026#34;NKG\u0026#34;: \u0026#34;Nanjing Lukou\u0026#34;, \u0026#34;PKX\u0026#34;: \u0026#34;Beijing Daxing\u0026#34;, \u0026#34;XIY\u0026#34;: \u0026#34;Xi\\\u0026#39;an Xianyang\u0026#34;, \u0026#34;SHA\u0026#34;: \u0026#34;Shanghao Hongqiao\u0026#34;] 作为一种替代下标语法的方式，字典的updateValue(_:forKey:)方法可以设置或者更新特定键对应的值。就像上面所示的下标示例，updateValue(_:forKey:)方法在这个键不存在对应值的时候会设置新值或者在存在时更新已存在的值。和下标的方式不同，updateValue(_:forKey:)这个方法返回更新值之前的原值。这样使得可以检查更新是否成功。\nupdateValue(_:forKey:)方法会返回对应值类型的可选类型。举例来说：对于存储String值的字典，这个函数会返回一个String?或者可选String类型的值。如果有值存在于更新前，则这个可选值包含了旧值，否则它将会是nil：\nif let oldValue = airposts.updateValue(\u0026#34;Hefei Xinqiao\u0026#34;, forKey: \u0026#34;HFE\u0026#34;) { print(\u0026#34;The old value for HFE was \\(oldValue).\u0026#34;) } // 打印输出\u0026#34;The old value for HFE was Hefei Xinqiao.\u0026#34; --- output: The old value for HFE was Hefei Xinqiao. 也可以使用下标语法来在字典中检索特定键对应的值。因为有可能请求的键没有对应的值存在，字典的下标访问会返回对应值的可选类型。如果这个字典包含请求键所对应的值，下标会返回一个包含这个存在值的可选类型，否则将返回nil:\nif let airportName = airposts[\u0026#34;HFE\u0026#34;] { print(\u0026#34;The name of the airport is \\(airportName).\u0026#34;) } else { print(\u0026#34;That airport is not in the airports dictionary.\u0026#34;) } // 打印\u0026#34;The name of the airport is Hefei Xinqiao.\u0026#34; --- output: The name of the airport is Hefei Xinqiao. 还可以使用下标语法通过将某个键的对应值赋值为nil来从字典中移除一个键值对：\nairposts[\u0026#34;CAN\u0026#34;] = \u0026#34;Guangzhou Baoan\u0026#34; // Baoan机场是深圳的，所以删除它 print(airposts) airposts[\u0026#34;CAN\u0026#34;] = nil // CAN现在被移除了 print(airposts) --- output: [\u0026#34;HFE\u0026#34;: \u0026#34;Hefei Xinqiao\u0026#34;, \u0026#34;NKG\u0026#34;: \u0026#34;Nanjing Lukou\u0026#34;, \u0026#34;PKX\u0026#34;: \u0026#34;Beijing Daxing\u0026#34;, \u0026#34;XIY\u0026#34;: \u0026#34;Xi\\\u0026#39;an Xianyang\u0026#34;, \u0026#34;CAN\u0026#34;: \u0026#34;Guangzhou Baoan\u0026#34;, \u0026#34;SHA\u0026#34;: \u0026#34;Shanghao Hongqiao\u0026#34;] [\u0026#34;HFE\u0026#34;: \u0026#34;Hefei Xinqiao\u0026#34;, \u0026#34;NKG\u0026#34;: \u0026#34;Nanjing Lukou\u0026#34;, \u0026#34;PKX\u0026#34;: \u0026#34;Beijing Daxing\u0026#34;, \u0026#34;XIY\u0026#34;: \u0026#34;Xi\\\u0026#39;an Xianyang\u0026#34;, \u0026#34;SHA\u0026#34;: \u0026#34;Shanghao Hongqiao\u0026#34;] 此外，removeValue(forKey:)方法也可以用来在字典中移除键值对。这个方法在键值对存在的情况下会移除该键值对并且返回被移除的值或者在没有对应值的情况下返回nil：\nif let removeValue = airposts.removeValue(forKey: \u0026#34;NKG\u0026#34;) { print(\u0026#34;The removed airport\u0026#39;s name is \\(removeValue).\u0026#34;) } else { print(\u0026#34;The airports dictionary does not contain a value for NKG.\u0026#34;) } // 打印\u0026#34;The removed airport\u0026#39;s name is Nanjing Lukou.\u0026#34; --- output: The removed airport\u0026#39;s name is Nanjing Lukou. 字典遍历 可以使用for-in循环来遍历某个字典中的键值对。每一个字典中的数据项都以(Key, Value)元组形式返回，并且可以使用临时常量或者变量来分解这些元组。\nfor (airportCode, airportName) in airposts { print(\u0026#34;\\(airportCode): \\(airportName)\u0026#34;) } // HFE: Hefei Xinqiao; // PKX: Beijing Daxing; //SHA: Shanghao Hongqiao; // XIY: Xi\u0026#39;an Xianyang --- output: HFE: Hefei Xinqiao PKX: Beijing Daxing XIY: Xi\u0026#39;an Xianyang SHA: Shanghao Hongqiao 通过访问keys或者values属性，可以遍历字典的键或值：\nfor airportCode in airposts.keys { print(\u0026#34;Airport code: \\(airportCode)\u0026#34;) } for airportName in airposts.values { print(\u0026#34;Airport name: \\(airportName)\u0026#34;) } --- output: Airport code: HFE Airport code: PKX Airport code: XIY Airport code: SHA Airport name: Hefei Xinqiao Airport name: Beijing Daxing Airport name: Xi\u0026#39;an Xianyang Airport name: Shanghao Hongqiao 如果需要使用某个字典的键集合或者值集合来作为某个接受Array实例的API的参数，可以直接使用keys或者values属性来构造一个新数组。\nlet airportCodes = [String](airposts.keys) // airportCodes是[\u0026#34;HFE\u0026#34;, \u0026#34;PKX\u0026#34;, \u0026#34;SHA\u0026#34;, \u0026#34;XIY\u0026#34;] print(airportCodes) let airportNames = [String](airposts.values) // airportNames是[\u0026#34;Hefei Xinqiao\u0026#34;, \u0026#34;Beijing Daxing\u0026#34;, \u0026#34;Shanghai Hongqiao\u0026#34;, \u0026#34;Xi\u0026#39;an Xianyang\u0026#34;] print(airportNames) --- output: [\u0026#34;HFE\u0026#34;, \u0026#34;PKX\u0026#34;, \u0026#34;XIY\u0026#34;, \u0026#34;SHA\u0026#34;] [\u0026#34;Hefei Xinqiao\u0026#34;, \u0026#34;Beijing Daxing\u0026#34;, \u0026#34;Xi\\\u0026#39;an Xianyang\u0026#34;, \u0026#34;Shanghao Hongqiao\u0026#34;] Swift的Dictionary是无序集合类型。为了以特定顺序遍历字典的键或值，可以对字典的keys或values属性使用sorted()方法。\n","date":"2021-08-20T00:00:00Z","permalink":"https://jen-jon.github.io/posts/collectiontype/","tags":"iOS; Swift; Apple","title":"Swift学习(6)-集合类型（代码完善版）","type":"technology"},{"contents":"Multi-label peach RGB-D dataset (Including RGB images, depth images, infrared images)\nAuthors: Rao Yuan / Luo Qing / Huo Peilin / Li Yipu / Zhang Jingyao The ML Peach RGB-D Dataset is composed by 2050 multi-modal images of peach on tree filelds captured using Microsoft Azure Kinect DK. Each images contains 3 different modalities, including RGB images, Depth images and Infrared images.\nAll images were aligned with the RGB image and manually labelled in 4 classes: unobstructed, obscured by foliage, obscured by branches and obscured by fruit.\nFind annotations in “.txt” format inside “annotation_yolo” folder. The camera parameters for each image taken are saved in “.txt” format inside “calib” folder.\nGet more details from here.\nREADME ML_Peach_RGB-D_Dataset_README.pdf\nDemo ML Peach RGB-D Demo Dataset.7z (226.7 MB)\nFull Dataset ML Peach RGB-D Dataset.7z (4.51 GB)\nUnpacking Key The key will be provided soon. Please be patient. You can download the Demo first.\n","date":"2021-08-17T00:00:00Z","permalink":"https://jen-jon.github.io/posts/20210817/","tags":"Dataset; RGB-D","title":"ML Peach RGB-D Dataset","type":"technology"},{"contents":"字符串是一系列字符的集合，例如“Hello, world”，“albatross”。Swift的字符串通过String类型来表示。而String内容的访问方式有多种，例如以Character值的集合。\nSwift的String和Character类型提供了一种快速且兼容Unicode的方式来处理代码中的文本内容。创建和操作字符串的语法与C语言中字符串操作相似，轻量并且易读。通过+符号就可以非常简单的实现两个字符串的拼接操作。与Swift中其他值一样，能否更改字符串的值，取决于其被定义为常量还是变量。\n开发者可以在已有字符串中插入常量、变量、字面量和表达式从而形成更长的字符串，这一过程也被称为字符串差值。尤其是在为显示、存储和打印创建自定义字符串值时，字符串插值操作尤其有用。\n尽管语法简易，但Swift中的String类型的实现却很快速和现代化。每一个字符串都是由编码无关的Unicode字符组成，并支持访问字符的多种Unicode表现形式。\n注意\nSwift的String类型与Foundation NSString类进行了无缝桥接。Foundation还对String进行扩展使其可以访问NSString类型中定义的方法。这意味着调用那些NSString的方法无需进行任何类型转换。\n字符串字面量 开发者可以在代码里使用一段预定义的字符串值作为字符串字面量。字符串字面量是由一对双引号包裹着的具有固定顺序的字符集。\n字符串字面量可以用于为常量和变量提供初始值。\nlet someString = \u0026#34;Some string literal value\u0026#34; // 字符串字面量初始化String类型常量 注意，Swift之所以推断someString常量为字符串类型，是因为它使用了字面量方式进行初始化。\n多行字符字面量 如果需要一个字符串是跨越多行的，那就使用多行字符串字面量：由一对三个双引号包裹着的具有固定顺序的文字字符集。\nlet quotation = \u0026#34;\u0026#34;\u0026#34; The White Rabbit put on his spectacles. \u0026#34;Where shall I begin, please your Majesty?\u0026#34; he asked. \u0026#34;Begin at the beginning\u0026#34; the King said gravely, \u0026#34;and go on til you come to the end; then stop.\u0026#34; \u0026#34;\u0026#34;\u0026#34; print(quotation) --- output: The White Rabbit put on his spectacles. \u0026#34;Where shall I begin, please your Majesty?\u0026#34; he asked. \u0026#34;Begin at the beginning\u0026#34; the King said gravely, \u0026#34;and go on til you come to the end; then stop.\u0026#34; 一个多行字符串字面量包含了所有的在开启和关闭引号\u0026quot;\u0026quot;\u0026quot;中的行。这个字符从开启引号\u0026quot;\u0026quot;\u0026quot;之后的第一行开始，到关闭引号\u0026quot;\u0026quot;\u0026quot;之前为止。这就意味着字符串开启引号之后或者结束引号之前都没有换行符号。\n下例中两个字符串其实是一样的，虽然第二个使用了多行字符串的形式。\nlet singleLineString = \u0026#34;These are the same.\u0026#34; let multiLineString = \u0026#34;\u0026#34;\u0026#34; These are the same. \u0026#34;\u0026#34;\u0026#34; print(\u0026#34;单行字符串：\\(singleLineString)\u0026#34;) print(\u0026#34;多行字符串：\\(multiLineString)\u0026#34;) --- output: 单行字符串：These are the same. 多行字符串：These are the same. 如果代码中多行字符串字面量包含换行符的话，则多行字符串字面量中也会包含换行符。如果想要换行以便加强代码的可读性，但是又不想在多行字符字面量中出现换行符的话，可以用在行尾写一个反斜杠\\作为续行符。\nlet softWrappedQuotation = \u0026#34;\u0026#34;\u0026#34; The White Rabbit put on his spectacles. \u0026#34;Where shall I begin, \\ please your Majesty?\u0026#34; he asked. \u0026#34;Begin at the beginning,\u0026#34; the King said gravely, \u0026#34;and go on \\ till you come to the end; then stop.\u0026#34; \u0026#34;\u0026#34;\u0026#34; print(\u0026#34;使用了换行符的quotation：\\(softWrappedQuotation)\u0026#34;) --- output: 使用了换行符的quotation：The White Rabbit put on his spectacles. \u0026#34;Where shall I begin, please your Majesty?\u0026#34; he asked. \u0026#34;Begin at the beginning,\u0026#34; the King said gravely, \u0026#34;and go on till you come to the end; then stop.\u0026#34; 为了让一个多行字符串字面量开始和结束于换行符，请将换行写在第一行和最后一行，例如：\nlet lineBreaks = \u0026#34;\u0026#34;\u0026#34; This string starts with a line break. It also ends with a line break. \u0026#34;\u0026#34;\u0026#34; print(lineBreaks) --- output: This string starts with a line break. It also ends with a line break. 一个多行字符串字面量能够缩进来匹配周围的代码。关闭引号\u0026quot;\u0026quot;\u0026quot;之前的空白字符串告诉Swift编译器其他各行多少空白字符串需要忽略。然而，如果在某行的前面写的空白字符串超出了关闭引号之前的空白字符串，则超出部分将被包含在多行字符串字面量中。\nlet linesWithIndentation = \u0026#34;\u0026#34;\u0026#34; This line doesn\u0026#39;t begin with whitespace. This line begins with four spaces. This line doesn\u0026#39;t begin with whitespace. \u0026#34;\u0026#34;\u0026#34; // 关闭引号前的空白字符串有4个空格 print(linesWithIndentation) --- output: This line doesn\u0026#39;t begin with whitespace. This line begins with four spaces. This line doesn\u0026#39;t begin with whitespace. 上面的例子中，尽管整个多行字符串字面量都是缩进的（源代码缩进），第一行和最后一行没有以空白字符串开始（实际的变量值）。中间一行的缩进用的空白字符串（源代码缩进）比关闭引号之前的空白字符串还要多，所以行首有4个空格。\n字符串字面量的特殊字符 字符串字面量可以包含以下特殊字符：\n转义字符\\0（空字符）、\\\\（反斜线）、\\t（制表符）、\\n（换行符）、\\r（回车符）、\\\u0026quot;（双引号）、\\'（单引号） Unicode标量，写成\\u{n}（u为小写），其中n为任意一到八位十六进制数且可用的Unicode位码 下面的代码为各种特殊字符的使用示例。\nlet wiseWords = \u0026#34;\\\u0026#34;Imagination is more important than knowledge.\\\u0026#34; - Einstein\u0026#34; let dollarSign = \u0026#34;\\u{24}\u0026#34; // $，Unicode标量 U+0024 let blackHeart = \u0026#34;\\u{2665}\u0026#34; // ♥，Unicode标量 U+2665 let sparklingHeart = \u0026#34;\\u{1F496}\u0026#34; // 💖，Unicode标量 U+1F496 print(wiseWords) print(dollarSign, terminator: \u0026#34; \u0026#34;) print(blackHeart, terminator: \u0026#34; \u0026#34;) print(sparklingHeart) --- output: \u0026#34;Imagination is more important than knowledge.\u0026#34; - Einstein $ ♥ 💖 由于多行字符串字面量使用了三个双引号而不是一个，所以可以在多行字符串字面量里直接使用双引号\u0026quot;而不必加上转义符\\。要在多行字符串字面量中使用\u0026quot;\u0026quot;\u0026quot;的话，就需要使用至少一个转义符（在多行字符串字面量中可以使用\u0026quot;\u0026ldquo;\u0026ldquo;转义三个双引号，也可使用\u0026quot;\u0026quot;\u0026quot;转义）。\nlet threeDoubleQuotes = \u0026#34;\u0026#34;\u0026#34; Escaping the first quote \\\u0026#34;\u0026#34;\u0026#34; Escaping all three quotes \\\u0026#34;\\\u0026#34;\\\u0026#34; \u0026#34;\u0026#34;\u0026#34; print(threeDoubleQuotes) --- output: Escaping the first quote \u0026#34;\u0026#34;\u0026#34; Escaping all three quotes \u0026#34;\u0026#34;\u0026#34; 拓展字符串分隔符 可以将字符串文字放在扩展分隔符中，这样字符串中的特殊字符将会被直接包含而非转义后的效果。将字符串放在引号\u0026quot;中并用数字符号#括起来。例如，打印字符串文字#\u0026quot;Line 1 \\n Line2\u0026quot;#会打印换行符转义序列\\n而不是给文字换行。\n如果需要字符串文字中字符的特殊效果，请在转义字符\\后面添加于起始位置个数相匹配的#符。例如，如果字符串是#\u0026quot;Line 1 \\nLine 2\u0026quot;#并且想要实现换行效果，则可以使用#\u0026quot;Line 1 \\#nLine 2\u0026quot;#来代替。同样，###\u0026quot;Line 1 \\###nLine 2\u0026quot;###也可以实现换行效果。\n扩展分隔符创建的字符串文字也可以是多行字符串文字。可以使用扩展分隔符在多行字符串中包含文本\u0026quot;\u0026quot;\u0026quot;，覆盖原有的结束文字的默认行为。例如：\nlet threeMoreDoubleQuotationMarks = #\u0026#34;\u0026#34;\u0026#34; Here are three more double quotes: \u0026#34;\u0026#34;\u0026#34; Good! Good! \u0026#34;\u0026#34;\u0026#34;# print(threeMoreDoubleQuotationMarks) --- output: Here are three more double quotes: \u0026#34;\u0026#34;\u0026#34; Good! Good! 初始化空字符串 要创建一个空字符串作为初始值，可以将空的字符串字面量赋值给变量，也可以初始化一个新的String实例。\nvar emptyString = \u0026#34;\u0026#34; // 空字符串字面量 var anotherEmptyString = String() // 初始化方法 // 两个字符串均为空并等价 可以通过检查Bool类型的\u0026rsquo;isEmpty\u0026rsquo;属性来判断该字符串是否为空。\nif emptyString.isEmpty { print(\u0026#34;Nothing to see here.\u0026#34;) // 打印输出“Nothing to see here.” } --- output: Nothing to see here. 字符串可变性 可以通过将一个特定字符串分配给一个变量来对其进行修改，或者分配给一个常量来保证其不会被修改。\nvar variableString = \u0026#34;Horse\u0026#34; variableString += \u0026#34; and carriage\u0026#34; // variableString现在为“Horse and carriage” print(variableString) let constantString = \u0026#34;Highlander\u0026#34; //constantString += \u0026#34; and another Hignlander\u0026#34; // 若取消这行注释，编译器会报错：Left side of mutating operator isn\u0026#39;t mutable: \u0026#39;constantString\u0026#39; is a \u0026#39;let\u0026#39; constant print(constantString) --- output: Horse and carriage Highlander 注意\n在Objective-C和Cocoa中，需要通过选择两个不同的类（NSString和NSMutableString）来指定字符串是否可以被修改。\n字符串是值类型 在Swift中String类型是值类型。如果开发者创建了一个新的字符串，那么当其进行常量、变量赋值操作，或在函数/方法中传递时，会进行值拷贝。在前述任一情况下，都会对已有字符串值创建新副本，并对该副本而非原始字符串进行传递或赋值操作。\nSwift默认拷贝字符串行为保证了在函数/方法向开发者传递的字符串所属权属于自己，无论该值来自于哪里，可以确信原始字符串不会被修改，除非开发者自己去修改它。\n在实际编译时，Swift编译器会优化字符串的使用，使实际的复制只发生在绝对必要的条件下，这意味着将字符串作为值类型的同时可以获得极高的性能。\n使用字符 可以使用for-in循环来遍历字符串，获取字符串中的每一个字符的值。\nfor character in \u0026#34;Dog!🐶\u0026#34; { print(character) } // 另外，通过标明一个`Character`类型并用字符字面量进行赋值，可以建立一个独立的字符常量或变量。 let exclamationMark: Character = \u0026#34;!\u0026#34; // 字符串可以通过传递一个值类型为`Character`的数组作为自变量来初始化。 let catCharacters: [Character] = [\u0026#34;c\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;t\u0026#34;, \u0026#34;!\u0026#34;, \u0026#34;🐱\u0026#34;] let catString = String(catCharacters) print(catString) // 打印\u0026#34;cat!🐱\u0026#34; --- output: D o g ! 🐶 cat!🐱 连接字符串和字符 字符串可以通过加法运算符+相加在一起（或称“连接”）创建一个新的字符串。\nlet string1 = \u0026#34;hello\u0026#34; let string2 = \u0026#34; jensen\u0026#34; var welcome = string1 + string2 // welcome现在等于“hello jensen” print(welcome) --- output: hello jensen 当然也可通过加法赋值运算符+=将一个字符串添加到一个已经存在的字符串变量上。\nvar instruction = \u0026#34;look over\u0026#34; instruction += string2 // instruction现在等于“look over jensen” print(instruction) --- output: look over jensen 可以使用append()方法将一个字符附加到一个字符串变量的尾部。\nlet questionMark: Character = \u0026#34;?\u0026#34; welcome.append(questionMark) // welcome现在等于“hello jensen?” print(welcome) --- output: hello jensen? 注意\n不能将一个字符串或者字符添加到一个已经存在的字符变量上，因为字符变量只能包含一个字符。\n如果需要使用多行字符串字面量来拼接字符串，并且需要字符串每一行都以换行符结尾，包括最后一行。\nlet badStart = \u0026#34;\u0026#34;\u0026#34; one two \u0026#34;\u0026#34;\u0026#34; let end = \u0026#34;\u0026#34;\u0026#34; three \u0026#34;\u0026#34;\u0026#34; print(badStart + end) // 打印两行：one\\ntwothree let goodStart = \u0026#34;\u0026#34;\u0026#34; one two \u0026#34;\u0026#34;\u0026#34; print(goodStart + end) // 打印三行：one\\ntwo\\nthree --- output: one twothree one two three 上面的例子中，把badStart和end拼接起来的字符串非我们想要的结果，因为badStart最后一行没有换行符，会和end的第一行结合到一起。相反的，goodStart每一行都以换行符为结尾，所以和end拼接的字符串总共有三行。\n字符串插值 字符串插值是一种构建新字符串的方式，可以在其中包含常量、变量、字面量和表达式。字符串字面量和多行字符串字面量都可以使用字符串插值，插入的字符串字面量的每一项都在以反斜线为前缀的圆括号中。\nlet multiplier = 3 let message = \u0026#34;\\(multiplier) times 2.5 is \\(Double(multiplier) * 2.5)\u0026#34; // message是“3 times 2.5 is 7.5” print(message) --- output: 3 times 2.5 is 7.5 在上面的例子中，multiplier作为\\(multiplier)被插入到一个字符串字面量中。当创建字符串执行插值计算时，此占位符会被替换为multiplier实际的值。\nmultiplier的值也作为字符串中后面表达式的一部分。该表达式计算Double(multiplier) * 2.5的值并将结果（7.5）插入到字符串中。在这个例子中，表达式写为\\(Double(multiplier) * 2.5)并包含在字符串字面量中。\n可以使用扩展字符串分隔符创建字符串，来包含不想作为字符串插值处理的字符。\nprint(#\u0026#34;Write an interpolated string in Swift using \\(multiplier).\u0026#34;#) // 打印“Write an interpolated string in Swift using \\(multiplier).” --- output: Write an interpolated string in Swift using \\(multiplier). 如果要值使用扩展字符串分隔符的字符串中使用字符串插值，需要在反斜杠后面添加与开头和结尾数量相同的扩展字符串分隔符。\nprint(#\u0026#34;6 times 7 is \\#(6 * 7)\u0026#34;#) // 打印“6 times 7 is 42” --- output: 6 times 7 is 42 注意\n插值字符串中写在括号中的表达式不能包含非转义反斜杠\\，并且不能包含回车或者换行符。不过，插值字符串可以包含其他字面量。\nUnicode Unicode是一个用于在不同书写系统中对文本进行编码、表示和处理的国际标准。它使开发者可以用标准格式来表示来自任意语言的几乎所有的字符，并能够对文本文件或网页这样的外部资源中的字符进行读写操作。Swift的String和Character类型是完全兼容Unicode标准的。\nUnicode标量 Swift的String类型是基于Unicode标量而建立的。Unicode标量是对应字符或者修饰符的唯一的21位数字，例如U+0061表示小写的拉丁字母（LATIN SMALL LETTER A）（“a”），U+1F425表示小鸡表情（FRONT-FACING BABY CHICK）（“🐤”）。（UTF-32编码的最大长度是4字节，四字节模版：11110XXX 10XXXXXX 10XXXXXX 10XXXXXX，因此有21位数字）\n请注意，并非所有的21位Unicode标量值都分配给字符，某些标量被保留用于将来分配或用于UTF-16编码。已分配的标量值通常也有一个名称，例如上面示例中的LATIN SMALL LETTER A和FRONT-FACING BABY CHICK。\n可扩展的字形群集 每一个Swift的Character类型代表一个可扩展的字形群。而一个可扩展的字形群构成了人类可读的单个字符，它由一个或多个（当组合时）Unicode标量的序列组成。\n举个例子，字母é可以用单一的Unicode标量é（LATIN SMALL LETTER E WITH ACUTE，或者U+00E9）来表示。然而一个标准的字母e（LATIN SMALL LETTER E，或者U+0065）加上一个急促重音（COMBINING ACUTE ACCENT）的标量（U+0301），这样一对标量就表示了同样地字母é。这个急促重音的标量形象地将e转换成了é。\n在这两种情况中，字母é代表了一个单一的Swift的Character值，同时代表了一个可扩展的字形群。在第一种情况，这个字形群包含一个单一的标量；而在第二种情况，它是包含两个标量的字形群。\nlet eAcute: Character = \u0026#34;\\u{E9}\u0026#34; // é 代表一个单一的Swift的Character值，同时代表了一个可扩展的字形群，该字形群包含一个单一的标量 let combinedEAcute = \u0026#34;\\u{65}\\u{301}\u0026#34; // é 代表一个可扩展的字形群，该字形群包含两个标量 print(\u0026#34;eAcute is \\(eAcute) and combinedEAcute is \\(combinedEAcute)\u0026#34;) --- output: eAcute is é and combinedEAcute is é 可扩展的字形集是一个将许多复杂的脚本字符表示为单个字符值的灵活方式。例如，来自朝鲜字母表的韩语音节能表示为组合或分解的有序排列。在Swift都会表示位同一个单一的Character值。\nlet precomposed: Character = \u0026#34;\\u{D55C}\u0026#34; // 한 let decomposed: Character = \u0026#34;\\u{1112}\\u{1161}\\u{11AB}\u0026#34; // ᄒ, ᅡ, ᆫ print(\u0026#34;precomposed的值是\\(precomposed)，decomposed的值是\\(decomposed)\u0026#34;) --- output: precomposed的值是한，decomposed的值是한 可扩展的字符群集可以使包围记号（例如COMBINING ENCLOSING CIRCLE或者U+20DD）的标量包围其他Unicode标量，作为一个单一的Character值。\nlet enclosedEAcute: Character = \u0026#34;\\u{E9}\\u{20DD}\u0026#34; // enclosedEAcute是é⃝ print(enclosedEAcute) --- output: é⃝ 地域性指示符号的Unicode标量可以组合成一个单一的Character值，例如REGIONAL INDICATOR SYMBOL LETTER H（U+1F1ED）和REGIONAL INDICATOR SYMBOL LETTER K（U+1F1F0）。\nlet regionalIndicatorForHK: Character = \u0026#34;\\u{1F1ED}\\u{1F1F0}\u0026#34; //HK print(regionalIndicatorForHK) // regionalIndicatorForHK是🇭🇰 --- output: 🇭🇰 计算字符数量 如果想要获得一个字符串中Character值的数量，可以使用count属性。\nlet unusualMenagerie = \u0026#34;Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐫\u0026#34; print(\u0026#34;unusualMenagerie has \\(unusualMenagerie.count) characters.\u0026#34;) // 打印输出“unusualMenagerie has 40 characters.” --- output: unusualMenagerie has 40 characters. 注意在Swift中，使用可扩展的字符群集作为Character值来连接或改变字符串时，并不一定会更改字符串的字符数量。\n例如，如果用四个字符的单词cafe初始化一个新的字符串，然后添加一个COMBINING ACUTE ACCENT (U+0301)作为字符串的结尾。最终这个字符串的字符数量仍然是4，因为这四个字符现在是café，长度依然是4。\nvar word = \u0026#34;cafe\u0026#34; print(\u0026#34;The number of characters in \\(word) is \\(word.count).\u0026#34;) // 打印输出“The number of characters in cafe is 4.” word += \u0026#34;\\u{301}\u0026#34; print(\u0026#34;The number of characters in \\(word) is \\(word.count).\u0026#34;) // 打印输出”The number of characters in café is 4.“ --- output: The number of characters in cafe is 4. The number of characters in café is 4. 注意\n可扩展的字形群可以由多个Unicode标量组成。这意味着不同的字符以及相同字符的不同表示方式可能需要不同数量的内存空间来存储。所以Swift中的字符在一个字符串中并不一定占用相同的内存空间。因此在没有获取字符串的可扩展的字符群的范围时候，就不能计算出字符串的字符数量。如果正在处理一个长字符串，需要注意count属性必须遍历全部的Unicode标量，来确定字符串的字符数量。\n另外需要注意的是通过count熟悉返回的字符数量并不总是与包含相同字符的NSString的length属性相同。NSString的length属性是利用UTF-16表示的十六位代码单元数字，而不是Unicode可扩展字符群集。\n访问和修改字符串 可以通过字符串的属性和方法来访问和修改它，当然也可以用下标语法完成。\n字符串索引 每一个String值都有一个关联的索引（index）类型，String.Index，它对应着字符串中的每一个Character的位置。\n前面提到，不同的字符可能会占用不同数量的内存空间，所以要知道Character的确定位置，就必须从String开头遍历每一个Unicode标量直到结尾。因此，Swift的字符串不能用整数（integer）做索引。\n使用startIndex属性可以获取一个String的第一个Character的索引。使用endIndex属性可以获取最后一个Character的后一个位置的索引。因此，endIndex属性不能作为一个字符串的有效下标。如果String是空串，startIndex和endIndex是相等的。\n通过调用String的index(before:)或index(after:)方法，可以立即得到前面或后面的一个索引，还可以通过调用index(_:offsetBy:)方法来获取对应偏移量的索引，这种方式可以避免多次调用index(before:)或index(after:)方法。\n可以使用下标语法来访问String特定索引的Character。\nlet greeting = \u0026#34;Jensen Jon!\u0026#34; print(\u0026#34;greeting\u0026#39;s first character is \\(greeting[greeting.startIndex]).\u0026#34;) // J print(\u0026#34;The character before greeting\u0026#39;s endIndex is \\(greeting[greeting.index(before: greeting.endIndex)])\u0026#34;) // ! print(\u0026#34;The character after greeting\u0026#39;s startIndex is \\(greeting[greeting.index(after: greeting.startIndex)])\u0026#34;) // e print(\u0026#34;The character with a offset of 7 from greeting\u0026#39;s startIndex is \\(greeting[greeting.index(greeting.startIndex, offsetBy: 7)])\u0026#34;) // J --- output: greeting\u0026#39;s first character is J. The character before greeting\u0026#39;s endIndex is ! The character after greeting\u0026#39;s startIndex is e The character with a offset of 7 from greeting\u0026#39;s startIndex is J 试图获取越界索引对应的Character，将引发一个运行时的错误。\n//greeting[greeting.endIndex] // 若取消注释，运行时系统会报错：Fatal error: String index is out of bounds //greeting.index(after: greeting.endIndex) // 若取消注释，运行时系统会报错：Fatal error: String index is out of bounds 使用indices属性会创建一个包含全部索引的范围（Range），用来在一个字符串中访问单个字符。\nfor index in greeting.indices { print(\u0026#34;\\(greeting[index])\u0026#34;, terminator: \u0026#34; \u0026#34;) // 打印输出“J e n s e n J o n !” } print(\u0026#34;\u0026#34;) --- output: J e n s e n J o n ! 注意\n可以使用startIndex和endIndex属性或者index(before:)、index(after:)和index(_:offsetBy:)方法在任意一个确定的并遵循Collection协议的类型里面。除了上面所示的String，也可以使用在Array、Dictionary和Set中。\n插入和删除 调用insert(_:at:)方法可以在一个字符串的指定索引插入一个字符，调用insert(contentsOf:at:)方法可以在一个字符串的指定索引插入一段字符串。\nvar friendlyGreeting = \u0026#34;hello\u0026#34; friendlyGreeting.insert(\u0026#34;!\u0026#34;, at: friendlyGreeting.endIndex) // friendlyGreeting变量现在等于“hello!” friendlyGreeting.insert(contentsOf: \u0026#34; there\u0026#34;, at: friendlyGreeting.index(before: friendlyGreeting.endIndex)) // friendlyGreeting变量现在等于“hello there!” 调用remove(at:)方法可以在一个字符串的指定索引删除一个字符，调用removeSubrange(_:)方法可以在一个字符串的指定索引删除一个子字符串。\nfriendlyGreeting.remove(at: friendlyGreeting.index(before: friendlyGreeting.endIndex)) // friendlyGreeting变量现在等于“hello there” let range = friendlyGreeting.index(friendlyGreeting.endIndex, offsetBy: -6)..\u0026lt;friendlyGreeting.endIndex friendlyGreeting.removeSubrange(range) // friendlyGreeting变量现在等于“hello” print(friendlyGreeting) --- output: hello 注意\n可以使用insert(:at:)、insert(contentsOf:at:)、remove(at:)和removeSubrange(:)方法在任意一个确定的并遵循RangeReplaceableCollection协议的类型里面/除了上面用到的String，也可以使用在Array、Dictionary和Set中。\n子字符串 当开发者从字符串中获取一个子字符串：例如，使用下标或者prefix(_:)之类的方法就可以得到一个Substring的实例，而非另一个String。Swift里的Substring绝大部分函数都和String一样，意味着开发者可以使用同样的方式去操作Substring和String。然而，跟String不同的是，只有在短时间内需要操作字符串时，才会使用Substring。当需要长时间保存结果时，就把Substring转化为String的实例。\nlet niceGreeting = \u0026#34;Hello, Jensen!\u0026#34; let index = niceGreeting.firstIndex(of: \u0026#34;,\u0026#34;) ?? niceGreeting.endIndex let beginning = greeting[..\u0026lt;index] // beginning的值是“Hello” // 把结果转化为String以便长期存储。 let newString = String(beginning) print(\u0026#34;newString is \\(newString).\u0026#34;) --- output: newString is Jense. 就像String，每一个Substring都会在内存里保存字符集。而String和Substring的区别在于性能优化上，Substring可以重用原String的内存空间，或者另一个Substring的内存空间（String也有同样地优化，但如果两个String共享内存的话，它们就会相等）。这一优化意味着在修改String和Substring之前都不需要消耗性能去复制内存。就像前面说的那样，Substring不适合长期存储，因为其重用了原String的内存空间，原String的呢粗黁空间必须保留直到它的Substring不再被使用为止。\n上述例子中，niceGreeting是一个String，意味着它在内存里有一片空间保存字符集。而由于beginning是niceGreeting的Substring，它重用了niceGreeting的内存空间。相反，newString是一个String，其是使用Substring创建的，拥有一片自己的内存空间。\n注意\nString和Substring都遵循StringProtocol协议，这意味着操作字符串的函数使用StringProtocol会更加方便。可以传入String或Substring去调用函数。\n比较字符串 Swift提供了三种方式来比较文本值：字符串字符相等、前缀相等和后缀相等。\n字符串/字符相等 字符串/字符可以用等于操作符==和不等于操作符!=。\nlet aQuotation = \u0026#34;We\u0026#39;re a lot alike, you and I.\u0026#34; let sameQuotation = \u0026#34;We\u0026#39;re a lot alike, you and I.\u0026#34; if aQuotation == sameQuotation { print(\u0026#34;These two strings are considered equal.\u0026#34;) // 打印输出“These two strings are considered equal.” } --- output: These two strings are considered equal. 如果两个字符串（或者两个字符）的可扩展的字形群集是标准相等，那就认为它们是相等的。只要可扩展的字形群集有同样的语言意义和外观则认为它们标准相等，即使它们是由不同的Unicode标量构成。\n例如， LATIN SMALL LETTER E WITH ACUTE (U+00E9)就是标准相等于LATIN SMALL LETTER E (U+0065)后面加上COMBINING ACUTE ACCENT (U+0301)。这两个字符群集都是表示字符é的有效方式，所以它们被认为是标准相等的。\nlet eAcuteQuestion = \u0026#34;Voluez-vous un caf\\u{E9}?\u0026#34; let combinedEAcuteQuestion = \u0026#34;Voluez-vous un caf\\u{65}\\u{301}?\u0026#34; if eAcuteQuestion == combinedEAcuteQuestion { print(\u0026#34;These two strings are considered equal.\u0026#34;) // 打印输出“These two strings are considered equal.” } --- output: These two strings are considered equal. 相反，英语中的LATIN CAPITAL LETTER A (U+0041)不等于俄语中的CYRILLIC CAPITIAL LETTER A (U+0410)。两个字符看着是一样的，但却有不同的语言意义。\nlet latinCapitialLetterA: Character = \u0026#34;\\u{41}\u0026#34; let cyrillicCapitalLetterA: Character = \u0026#34;\\u{410}\u0026#34; if latinCapitialLetterA != cyrillicCapitalLetterA { print(\u0026#34;These two characters are not equivalent.\u0026#34;) // 打印输出“These two characters are not equivalent.” } --- output: These two characters are not equivalent. 注意\n在Swift中，字符串和字符并不区分地域（not locale-sensitive）。\n前缀/后缀相等 通过调用字符串的hasPrefix(_:)/hasSuffix(_:)方法来检查字符串是否拥有特定前缀/后缀，两个方法均接收一个String类型的参数，并返回一个布尔值。\n下面的例子以一个字符串数组表示莎士比亚话剧《罗米欧与朱丽叶》中前两场的场景位置。\nlet romeoAndJuliet = [ \u0026#34;Act 1 Scene 1: Verona, A public place\u0026#34;, \u0026#34;Act 1 Scene 2: Capulet\u0026#39;s mansion\u0026#34;, \u0026#34;Act 1 Scene 3: A room in Capulet\u0026#39;s mansion\u0026#34;, \u0026#34;Act 1 Scene 4: A street outside Capulet\u0026#39;s mansion\u0026#34;, \u0026#34;Act 1 Scene 5: The Great Hall in Capulet\u0026#39;s mansion\u0026#34;, \u0026#34;Act 2 Scene 1: Outside Capulet\u0026#39;s mansion\u0026#34;, \u0026#34;Act 2 Scene 2: Capulet\u0026#39;s orchard\u0026#34;, \u0026#34;Act 2 Scene 3: Outside Friar Lawrence\u0026#39;s cell\u0026#34;, \u0026#34;Act 2 Scene 4: A street in Verona\u0026#34;, \u0026#34;Act 2 Scene 5: Capulet\u0026#39;s mansion\u0026#34;, \u0026#34;Act 2 Scene 6: Friar Lawrence\u0026#39;s cell\u0026#34; ] 此时可以调用hasPrefix(_:)方法来计算话剧中第一幕的场景数：\nvar act1SceneCount = 0 for scene in romeoAndJuliet { if scene.hasPrefix(\u0026#34;Act 1 \u0026#34;) { act1SceneCount += 1 } } print(\u0026#34;There are \\(act1SceneCount) scenes in Act 1.\u0026#34;) --- output: There are 5 scenes in Act 1. 相似地，可以用hasSuffix(_:)方法来计算发生在不同地方的场景数。\nvar mansionCount = 0 var cellCount = 0 for scene in romeoAndJuliet { if scene.hasSuffix(\u0026#34;Capulet\u0026#39;s mansion\u0026#34;) { mansionCount += 1 } else if scene.hasSuffix(\u0026#34;Friar Lawrence\u0026#39;s cell\u0026#34;) { cellCount += 1 } } print(\u0026#34;\\(mansionCount) mansion scenes; \\(cellCount) cell scenes\u0026#34;) --- output: 6 mansion scenes; 2 cell scenes 注意\nhasPrefix(:)和hasSuffix(:)方法都是在每个字符串中逐字符比较其可扩展的字符群集是否标准相等。\n字符串的Unicode表示形式 当一个Unicode字符串被写进文本文件或者其他存储时，字符串中的Unicode标量会用Unicode定义的几种编码格式（encoding forms）编码。每个字符串中的小块编码都被称为代码单元（code units）。这些包括UTF-8编码格式（编码字符串为8位的代码单元），UTF-16编码格式（编码字符串为16位的编码单元），以及UTF-32编码格式（编码字符串为32位的编码单元）。\nSwift提供了几种不同的方式来访问字符串的Unicode表示形式。可以利用for-in来对字符串进行遍历，从而以Unicode可扩展的字符群集的方式访问每一个Character值。\n另外，能够以其他三种Unicode兼容的方式访问字符串的值：\nUTF-8代码单元集合（利用字符串的utf8属性进行访问） UTF-16代码单元集合（利用字符串的utf16属性进行访问） 21位的Unicode标量值集合，也就是字符串的UTF-32编码格式（利用字符串的unicodeScalars属性进行访问） 下面由D，o，g，!!（DOUBLE EXCLAMATION MARK， Unicode标量 U+203C）和🐶（DOG FACE，Unicode标量 U+1F436）组成的字符串中的每一个字符代表着一种不同的表示。\nlet dogString = \u0026#34;Dog‼🐶\u0026#34; UTF-8表示 可以通过遍历String的utf8属性来访问它的UTF-8表示。其为String.UTF8View类型的属性，UTF8View是无符号8位（UInt8）值的集合，每一个UInt8值都是一个字符的UTF-8表示：\nCharacter D\nU+0044 o\nU+006F g\nU+0067 ‼\nU+203C 🐶\nU+1F436 UTF-8\nCode Unit 68 111 103 226 128 188 240 159 144 182 Position 0 1 2 3 4 5 6 7 8 9 for codeUnit in dogString.utf8 { print(\u0026#34;\\(codeUnit) \u0026#34;, terminator: \u0026#34;\u0026#34;) } print(\u0026#34;\u0026#34;) --- output: 68 111 103 226 128 188 240 159 144 182 上面的例子中，前三个十进制codeUnit值（68、111、103）代表了字符D、o和g，它们的UTF-8表示与ASCII表示相同。接下来的三个十进制codeUnit值（226、128、188）是DOUBLE EXCLAMATION MARK的3字节UTF-8表示。最后的四个codeUnit值（240、159、144、182）是DOG FACE的4字节UTF-8表示。\nUTF-16表示 可以通过遍历String的utf16属性来访问它的UTF-16表示。其为String.UTF16View类型属性，UTF16View是无符号16位（UInt16）值的集合，每一个UInt16都是一个字符的UTF-16表示：\nCharacter D\nU+0044 o\nU+006F g\nU+0067 ‼\nU+203C 🐶\nU+1F436 UTF-16\nCode Unit 68 111 103 8252 55357 56374 Position 0 1 2 3 4 5 for codeUnit in dogString.utf16 { print(\u0026#34;\\(codeUnit) \u0026#34;, terminator: \u0026#34;\u0026#34;) } print(\u0026#34;\u0026#34;) --- output: 68 111 103 8252 55357 56374 同样，前三个codeUnit值（68、111、103）代表了字符D、o和g，它们的UTF-16代码单元和UTF-8完全相同（因为这些Unicode标量表示ASCII字符）。\n第四个codeUnit值（8252）是一个等于十六进制203C的十进制值。这个代表了DOUBLE EXCLAMATION MARK字符的Unicode标量值U+203C。这个字符在UTF-16中可以用一个代码单元表示。\n第五和第六个codeUnit值（55357和56374）是DOG FACE字符的UTF-16表示。第一个值为U+D83D（十进制值为55357），第二个值为U+DC36（十进制值为 56374）。\nUnicode标量表示 可以通过遍历String值的unicodeScalars属性来访问它的Unicode标量表示。其为UnicodeScalarView类型的属性，UnicodeScalarView是UnicodeScalar类型的值的集合。\n每一个unicodeScalar拥有一个value属性，可以返回对应的21位数值，用UInt32来表示：\nCharacter D\nU+0044 o\nU+006F g\nU+0067 ‼\nU+203C 🐶\nU+1F436 Unicode Scalar\nCode Unit 68 111 103 8252 128054 Position 0 1 2 3 4 for scalar in dogString.unicodeScalars { print(\u0026#34;\\(scalar.value) \u0026#34;, terminator: \u0026#34;\u0026#34;) } print(\u0026#34;\u0026#34;) --- output: 68 111 103 8252 128054 前三个UnicodeScalar值（68、111、103）的value属性仍然代表字符D、o和g。\n第四个codeUnit值（8252）仍然是一个等于十六进制203C的十进制值。这个代表了DOUBLE EXCLAMATION MARK字符的Unicode标量U+203C。\n第五个UnicodeScalar值的value属性，128054，是一个十六进制1F436的十进制表示。其等同于DOG FACE的Unicode标量U+1F436。\n作为查询它们的value属性的一种替代方法，每个UnicodeScalar值也可以用来构建一个新的String值，比如在字符串插值中使用：\nfor scalar in dogString.unicodeScalars { print(\u0026#34;\\(scalar) \u0026#34;) } --- output: D o g ‼ 🐶 ","date":"2021-08-13T00:00:00Z","permalink":"https://jen-jon.github.io/posts/stringschars/","tags":"iOS; Swift; Apple","title":"Swift学习(5)-字符串和字符（代码完善版）","type":"technology"},{"contents":"除了之前介绍过的基本运算符，Swift还提供了数种可以对数值进行复杂运算的高级运算符。它们包含了在C和Objective-C中已经被大家所熟知的位运算符和移位运算符。\n自定义结构体、类和枚举时，如果也为它们提供标准Swift运算符的实现，将会非常有用。在Swift中为这些运算符提供自定义的实现非常简单，运算符也会针对不同类型使用对应实现。\n开发者不用被预定义的运算符所限制。在Swift中可以自由地定义中缀、前缀、后缀和赋值运算符，它们具有自定义的优先级和关联值。这些运算符在代码中可以像预定义运算符一样使用，开发者甚至可以拓展已有的类型以支持自定义运算符。\n位运算符 位运算符可以操作数据结构中每个独立的比特位。它们通常被用在底层开发中，比如图形编程和创建设备驱动。位运算符在处理外部资源的原始数据时也十分有用，比如对自定义通信协议传输的数据进行编码和解码。\nSwift支持C语言中的全部位运算符，接下来会一一介绍。\nBitwise NOT Operator（按位取反运算符） 按位取反运算符~对一个数值的全部比特位进行取反。\n按位取反运算符是一个前缀运算符，直接放在运算数之前，并且运算符与运算数之间不能添加任何空格。\nlet initialBits: UInt8 = 0b00001111 let invertedBits = ~initialBits // 等于0b11110000 print(\u0026#34;对值\\(initialBits)按位取反后的结果是：\\(invertedBits)\u0026#34;) --- output: 对值15按位取反后的结果是：240 UInt8类型的整数有8个比特位，可以存储0～255之间的任意整数。这个例子初始化了一个UInt8类型的整数，并赋值位二进制的00001111，它的前4位为0，后4位为1。这个值等价于十进制的15。\n接着使用按位取反运算符创建了一个名为invertedBits的常量，这个常量的值域全部位取反后的initialBits相等。即所有的0都变成了1，同时所有的1都变成0。invertedBits的二进制值位11110000，等价于无符号的十进制数240。\nBitwise AND Operator（按位与运算符） 按位与运算符\u0026amp;对两个数的比特位进行合并。它返回一个新的数，只有当两个数的对应位都为1的时候，新数的对应位才为1。\n在下面的示例中，firstSixBits和lastSixBits中间4个位的值都为1。使用按位与运算符之后，得到二进制数值00111100，等价与无符号十进制数的60。\nlet firstSixBits: UInt8 = 0b11111100 let lastSixBits: UInt8 = 0b00111111 let middleFourBits = firstSixBits \u0026amp; lastSixBits // 等于0b00111100 print(\u0026#34;值\\(firstSixBits)和值\\(lastSixBits)按位与后的结果为：\\(middleFourBits)\u0026#34;) --- output: 值252和值63按位与后的结果为：60 Bitwise OR Operator（按位或运算符） 按位或运算符/可以对两个数的比特位进行比较。它返回一个新的数，只要两个数的对应位中有任意一个为1时，新数的对应位就为1。\n在下面的示例中，someBits和moreBits存在不同的位被设置为1。使用按位或运算符之后，得到二进制数值11111110，等价于无符号十进制的254。\nlet someBits: UInt8 = 0b10110010 let moreBits: UInt8 = 0b01011110 let combinedBits = someBits | moreBits print(\u0026#34;值\\(someBits)和值\\(moreBits)按位或后的结果为：\\(combinedBits)\u0026#34;) --- output: 值178和值94按位或后的结果为：254 Bitwise XOR Operator（按位异或运算符） 按位异或运算符，或称“排外的或运算符”^，可以对两个数的比特位进行比较。它返回一个新的数，当两个数的对应位不相同时，新数的对应位就为1，并且对应位相同时则为0。\n在下面的示例当中，firstBits和otherBits都有一个自己为1而对方为0的位。按位异或运算符将新数的这两个位设置为1。在其余的位上firstBits和otherBits是相同的，所以设置为0。\nlet firstBits: UInt8 = 0b00010100 let otherBits: UInt8 = 0b00000101 let outputBits = firstBits ^ otherBits print(\u0026#34;值\\(firstBits)和值\\(otherBits)按位异或后的结果为：\\(outputBits)\u0026#34;) --- output: 值20和值5按位异或后的结果为：17 Bitwise Left and Right Shift Operators（按位左移、右移运算符） 按位左移运算符\u0026lt;\u0026lt;和按位右移运算符\u0026gt;\u0026gt;可以对一个数的所有位进行指定位数的左移和右移，但是需要遵守下面定义的规则。\n对一个数进行按位左移或者按位右移，相当于对这个数进行乘以2或者除以2的运算。将一个整数左移一位，等价于将这个数乘以2，同样地，将一个整数右移一位，等价于将这个数除以2。\n无符号整数的的移位运算 对无符号整数进行移位的规则如下：\n1. 已存在的位按指定的位数进行左移和右移\n2. 任何因移动而超出整型存储范围的位都会被丢弃\n3. 用0来填充移位后产生的空白位\n上述方法被称为逻辑移位。\n下面的代码演示了Swift中的移位运算。\nlet shiftBits: UInt8 = 0b00000100 print(\u0026#34;\\(shiftBits)向左移1位：\\(shiftBits \u0026lt;\u0026lt; 1)\u0026#34;) // 0b00001000 print(\u0026#34;\\(shiftBits)向左移2位：\\(shiftBits \u0026lt;\u0026lt; 2)\u0026#34;) // 0b00010000 print(\u0026#34;\\(shiftBits)向左移5位：\\(shiftBits \u0026lt;\u0026lt; 5)\u0026#34;) // 0b10000000 print(\u0026#34;\\(shiftBits)向左移6位：\\(shiftBits \u0026lt;\u0026lt; 6)\u0026#34;) // 0b00000000 print(\u0026#34;\\(shiftBits)向右移2位：\\(shiftBits \u0026gt;\u0026gt; 2)\u0026#34;) // 0b00000001 --- output: 4向左移1位：8 4向左移2位：16 4向左移5位：128 4向左移6位：0 4向右移2位：1 可以使用移位运算对其他的数据类型进行编码和解码。\nlet pink: UInt32 = 0xCC6699; print(pink) let redComponent = (pink \u0026amp; 0xFF0000) \u0026gt;\u0026gt; 16 // redComponent是0xCC，即204 let greenComponent = (pink \u0026amp; 0x00FF00) \u0026gt;\u0026gt; 8 // greenComponent是0x66，即102 let blueComponent = (pink \u0026amp; 0x0000FF) // blueComponent是0x99，即153 print(\u0026#34;pink中红色分量为：\\(redComponent)\u0026#34;) print(\u0026#34;pink中绿色分量为：\\(greenComponent)\u0026#34;) print(\u0026#34;pink中蓝色分量为：\\(blueComponent)\u0026#34;) --- output: 13395609 pink中红色分量为：204 pink中绿色分量为：102 pink中蓝色分量为：153 在上述示例中，使用了一个命名为pink的UInt32型常量来存储Cascading Style Sheets (CSS)中粉色的颜色值。该CSS的颜色值#CC6699，在Swift中表示为十六进制的0xCC6699。然后利用按位与运算符\u0026amp;和按位右移运算符\u0026gt;\u0026gt;从这个颜色中分解出红（CC）、绿（66）蓝（99）三个部分。\n红色部分（redComponent）是通过对0xCC6699和0xFF0000进行按位与运算后得到的。0xFF0000中的0部分“掩盖”了0xCC6699中的第二第三个字节，只留下0xCC0000。然后将这个数向右移16位后就变成0x0000CC，也就是十进制数值的204。\n有符号整数的移位运算 对比无符号整数，有符号整数的移位运算相对复杂得多，这种复杂性源于有符号整数的二进制表现形式。（为了简单起见，以下的示例都是基于8比特的有符号整数，但是其中的原理对于任何位数的有符号整数都是通用的。）\n有符号整数使用第一个比特位（通常被称为符号位）来表示这个数的正负。符号位为0代表正数，符号位为1代表负数。\n其余的比特位（通常被称为数值位）存储了实际的值。有符号正整数和无符号数的存储方式都是一样的，都是从0开始算起。这是值为 4 的 Int8 型整数的二进制位表现形式：\n符号位为0（代表这是一个“正数”），另外7位则代表了十进制数值4的二进制表示。\n负数的存储方式略有不同，它存储2的n次方减去实际值的绝对值，这里的n是数值位的位数。一个8比特位的数有七个比特位是数值位，所以是2的7次方，即128。这是值为 -4 的 Int8 型整数的二进制表现形式：\n这次的符号位为1，说明这是一个负数，另外7个位则代表了数值124（即2^7 - |-4| = 124）的二进制表示。\n负数的表示通常被称为二进制补码。用这种方式来表示负数乍一看有点奇怪，但是它却有几个优点。\n首先，如果想对-1和-4进行加法运算，只需要对这两个数的全部8个比特位执行标准的二进制相加（包括符号位），并且将计算结果中超出8位的数值丢弃。\n其次，使用二进制补码可以使负数的按位左移和右移运算得到跟正数同样地效果。即每向左移一位就可以将自身的数值乘以2，每向右移一位就可以将自身的数值除以2。要达到此目的，对有符号整数的右移有一个额外的规则：当对有符号整数进行按位右移运算时，遵循无符号整数相同的规则，但是对于移位产生的空白位使用符号位进行填充，而不是用0。\n这个行为可以确保有符号整数的符号位不会因为右移运算而改变，这通常被称为算术移位。\n溢出运算符 当像一个整数类型的常量或者变量赋予超过它容量的值时，Swift默认会报错，而不是允许生成一个无效的数。这个行为为开发者在运算过大或者过小的数时提供了额外的安全性。\n例如，Int16型整数能够容纳的有符号整数的范围是-32768～32767。当为一个Int16类型的变量或常量赋予超过这个范围的值时，系统就会报错。\nvar potentialOverFlow = Int16.max //potentialOverFlow += 1 // 若取消这行注释，运行后会报错：Swift runtime failure: arithmetic overflow 在赋值时为过大或过小的情况提供错误处理，能让开发者在处理边界值时更加灵活。\n然而，当开发者希望的时候也可以选择让系统在数值溢出的时候采取截断处理，而非报错。Swift提供的三个溢出运算符来让系统支持整数溢出运算。这些运算符都是以\u0026amp;开头的：\n溢出加法\u0026amp;+ 溢出减法\u0026amp;- 溢出乘法\u0026amp;* 数值溢出 数值有可能出现上溢或者下溢。\n下面的例子演示了当对一个无符号整数使用溢出加法进行上溢运算时会发生什么。\nvar unsignedOverFlow = UInt8.max // unsignedOverFlow等于UInt8所能容纳的最大整数255 unsignedOverFlow = unsignedOverFlow \u0026amp;+ 1 // 此时unsignedOverFlow等于0 print(\u0026#34;UInt8上溢后的值：\\(unsignedOverFlow)\u0026#34;) --- output: UInt8上溢后的值：0 unsignedOverFlow被初始化为UInt8所能容纳的最大整数（255，以二进制表示即11111111），然后使用溢出加法运算符\u0026amp;+对其进行加1运算。使得它的二进制表示正好超出UInt8所能容纳的位数，也就导致了数值的溢出。数值溢出后，仍然留在UInt8边界内的值是00000000，也就是十进制数值0。\n当允许对一个无符号整数进行下溢运算时也会产生类似的情况。这里有一个使用溢出减法运算符\u0026amp;-的例子。\nunsignedOverFlow = UInt8.min // unsignedOverFlow等于UInt8所能容纳的最小整数0 unsignedOverFlow = unsignedOverFlow \u0026amp;- 1 // 此时unsignedOverFlow等于255 print(\u0026#34;UInt8下溢后的值：\\(unsignedOverFlow)\u0026#34;) --- output: UInt8下溢后的值：255 UInt8型整数能够容纳的最小值是0，以二进制表示即为00000000。当使用溢出减法运算符对其进行减1运算时，数值会产生下溢并被截断为11111111，也就是十进制数值的255。\n溢出也会发生在有符号整型上。针对有符号整型的所有溢出加法或者减法运算都是按位运算的方式执行的。符号位也要参与计算，正如按位左移、右移运算符所描述的那样。\nvar signedOverFlow = Int8.min // signedOverFlow等于Int8所能容纳的最小整数-128 signedOverFlow = signedOverFlow \u0026amp;- 1 // 此时signedOverFlow等于127 print(\u0026#34;Int8下溢后的值：\\(signedOverFlow)\u0026#34;) --- output: Int8下溢后的值：127 Int8型整数能容纳的最小值是-128，以二进制形式表示即10000000。当使用溢出减法运算符对其进行减1运算时，符号位被翻转，得到二进制数值01111111，也就是十进制数值的127，这个值也是Int8型整数所能容纳的最大值。\n对于无符号和有符号整型数值来说，当出现上溢时，它们会从数值所能容纳的最大数变成最小数。同样地，当发生下溢时，它们会从数值的最小数变成数值的最大数。\n优先级和结合性 运算符的优先级使得一些运算符优先于其他运算符，也就意味着优先级更高的运算符会先被执行。\n结合性定义了相同优先级的运算符是如何结合的，也就是说，是与左边的结合为一组还是与右边的结合为一组。\n当考虑一个复合表达式的计算顺序时，运算符的优先级和结合性是非常重要的。举例来说，运算符优先级解释了为什么下面这个表达式的运算结果会是17。\nvar result = 2 + 3 % 4 * 5 // result的值是17 print(\u0026#34;2 + 3 % 4 * 5的值是：\\(result)\u0026#34;) --- output: 2 + 3 % 4 * 5的值是：17 如果直接从左到右进行运算，可能会认为计算的过程是这样的：\n2 + 3 = 5 5 % 4 = 1 1 * 5 = 5 但是正确答案是17而不是5。优先级高的运算符要先于优先级低的运算符进行计算。与C语言类似，在Swift中，乘法运算符*与取余运算符%的优先级要高于加法运算符+。因此，它们的计算顺序也要先于加法运算。\n而乘法运算与取余运算的优先级相同，这时为了得到正确的运算顺序，还需要考虑结合性。乘法运算与取余运算都是左结合的。可以将这考虑成，从它们的左边开始为这两部分表达式都隐式地加上括号。即 2 + 3 % 4 * 5 ==\u0026gt; 2 + ((3 % 4) * 5) ==\u0026gt; 2 + (3 * 5) ==\u0026gt; 2 + 15 ==\u0026gt; 17。因此计算结果为17。\n运算符函数 类与结构体可以为现有的运算符提供自定义的实现。这通常被称为运算符的重载。\n下面的例子展示了如何让自定义的结构体支持加法运算符+。算术加法运算符是一个二元运算符，因其是对两个值进行运算，同时它还可以被称为中缀运算符，因为它出现在两个值中间。\n例子中定义了一个名为Vector2D的结构体用来表示二维坐标向量(x, y)，紧接着定义了一个可以将两个Vector2D结构体实例进行相加的运算符函数。\nstruct Vector2D { var x = 0.0, y = 0.0 } extension Vector2D { static func + (left: Vector2D, right: Vector2D) -\u0026gt; Vector2D { return Vector2D(x: left.x + right.x, y: left.y + right.y) } } 该运算符函数被定义为Vector2D上的一个类方法，并且函数的名字与它要进行重载的+名字一致。因为加法运算并不是一个向量必须的功能，所以这个类方法被定义在Vector2D的一个扩展中，而不是Vector2D结构体声明内。而算术加法运算符是二元运算符，所以这个运算符函数接收两个类型为Vector2D的参数，同时有一个Vector2D类型的返回值。\n在这个实现中，输入参数分别被命名为left和right，代表在+运算符左边和右边的两个Vector2D实例，这个实例的x和y分别等于作为参数的两个实例的x和y的值之和。\n这个类方法可以在任意两个Vector2D实例中间作为中缀运算符来使用。\nlet vector = Vector2D(x: 3.0, y: 1.0) let anotherVector = Vector2D(x: 2.0, y: 4.0) let combinedVector = vector + anotherVector // combinedVector是一个新的Vector2D实例，值为(5.0， 5.0) print(\u0026#34;两个Vector2D类型的向量相加后的值为：\\(combinedVector)\u0026#34;) --- output: 两个Vector2D类型的向量相加后的值为：Vector2D(x: 5.0, y: 5.0) 前缀和后缀运算符 上个例子演示了一个二元中缀运算符的自定义实现，类与结构体也能提供标准的一元运算符的实现。一元运算符只运算一个值。当运算符出现在值之前时，它就是前缀的（例如-a），而当它出现在值之后时，它就是后缀的（例如b!）。\n要实现前缀或者后缀运算符，需要在声明运算符函数的时候在func关键字之前指定prefix或者postfix修饰符。\nextension Vector2D { static prefix func - (vector: Vector2D) -\u0026gt; Vector2D { return Vector2D(x: -vector.x, y: -vector.y) } } 上述代码为Vector2D类型实现了一元运算符（-a）。由于该运算符是前缀运算符，所以这个函数需要加上prefix修饰符。\n对于简单数值，一元负号运算符可以对其正负性进行改变。对于Vector2D来说，该运算将其x和y属性的正负性都进行了改变。\nlet positive = Vector2D(x: 3.0, y: 4.0) let negative = -positive // negative是一个值为(-3.0, -4.0)的Vector2D实例 let alsoPositive = -negative // alsoPositive是一个值为(3.0, 4.0)的Vector2D实例 print(\u0026#34;-positive的值为：\\(negative)\u0026#34;) print(\u0026#34;-negative的值为：\\(alsoPositive)\u0026#34;) --- output: -positive的值为：Vector2D(x: -3.0, y: -4.0) -negative的值为：Vector2D(x: 3.0, y: 4.0) 复合赋值运算符 复合赋值运算符将赋值运算符=与其它运算符进行结合。例如，将加法与赋值结合成加法赋值运算符+=。在实现的时候，需要把运算符的左参数设置成inout类型，因为这个参数的值会在运算符函数内直接被修改。\n下面的例子中，对Vector2D实例实现了一个加法赋值运算符函数。\nextension Vector2D { static func += (left: inout Vector2D, right: Vector2D) { left = left + right // 因为Vector2D的加法运算在之前已经定义过了，所以在这里无需再次定义，直接利用现有的加法运算符函数 } } var original = Vector2D(x: 1.0, y: 2.0) let vectorToAdd = Vector2D(x: 3.0, y: 4.0) original += vectorToAdd // original的值现在是(4.0, 6.0) print(\u0026#34;Vector2D类型的加法赋值运算之后的值为：\\(original)\u0026#34;) --- output: Vector2D类型的加法赋值运算之后的值为：Vector2D(x: 4.0, y: 6.0) 注意\n不能对默认的赋值运算符=进行重载。只有复合赋值运算可以被重载。同样地，也无法对三元条件运算符（a ? b : c）进行重载。\n等价运算符 通常情况下，自定义的类和结构体没有对等价运算符进行默认实现，等价运算符通常被称为相等运算符==和不等运算符!=。\n为了使用等价运算符对自定义的类型进行判等运算，需要为“相等”运算符提供自定义实现，实现的方法与其他中缀运算符一样，并且增加对标准库Equatable协议的遵循。\nextension Vector2D: Equatable { // 遵循Equatable协议便可以包含对“相等”运算符（==）和“不等”运算符（!=）的实现 static func == (left: Vector2D, right: Vector2D) -\u0026gt; Bool { return (left.x == right.x) \u0026amp;\u0026amp; (left.y == right.y) } } 上述代码实现了“相等”运算符（==）来判断两个Vector2D实例是否相等。对于Vector2D来说，“相等”意味着“两个实例的x和y都相等”，这也是代码中用来进行判等的逻辑。如果已经实现了“相等”运算符，通常情况下不需要再去实现“不等”运算符（!=）。标准库对于“不等”运算符提供了默认的实现，它简单地讲“相等”运算符的结果进行取反后返回。\nlet twoThree = Vector2D(x: 2.0, y: 3.0) let anotherTwoThree = Vector2D(x: 2.0, y: 3.0) if twoThree == anotherTwoThree { print(\u0026#34;These two vectors are equivalent!\u0026#34;) } let threeTwo = Vector2D(x: 3.0, y: 2.0) if twoThree != threeTwo { // 已经实现了“相等”运算符，故不需要再去实现“不等”运算符 print(\u0026#34;These two vectors are not equivalent!\u0026#34;) } --- output: These two vectors are equivalent! These two vectors are not equivalent! 多数简单情况下，可以让Swift合成等价运算符的实现（遵循Equatable协议等）。\n自定义运算符 除了实现标准运算符，在Swift中还可以声明和实现自定义运算符。\n新的运算符要使用operator关键字在全局作用域内进行定义，，同时还要指定prefix（前缀）、infix（中缀）或者postfix（后缀）修饰符。\nprefix operator +++ // 定义了一个新的名为`+++`的前缀运算符 上面的代码定义了一个新的名为+++的前缀运算符。对于这个运算符，在Swift中并没有已知的意义，因此在针对Vector2D实例的特定上下文中，给予了它自定义的意义。对于这个示例来讲，+++被实现为“前缀自双增”运算符。它使用了前面定义的复合加法运算符来让矩阵与自身进行相加，从而让Vector2D示例的x属性和y属性值都翻倍。可以像下面这样通过对\u0026rsquo;Vector2D\u0026rsquo;添加一个+++类方法来实现。\nextension Vector2D { static prefix func +++ (vector: inout Vector2D) -\u0026gt; Vector2D { vector += vector return vector } } var toBeDoubled = Vector2D(x: 1.0, y: 4.0) let afterDoubling = +++toBeDoubled // toBeDoubled和afterDoubling现在的值均为(2.0, 8.0) print(\u0026#34;toBeDoubled的值为：\\(toBeDoubled)\u0026#34;) print(\u0026#34;afterDoubling的值为：\\(afterDoubling)\u0026#34;) --- output: toBeDoubled的值为：Vector2D(x: 2.0, y: 8.0) afterDoubling的值为：Vector2D(x: 2.0, y: 8.0) 自定义中缀运算符的优先级 每个自定义中缀运算符都属于某个优先级组。优先级组指定了这个运算符相对于其他中缀运算符的优先级和结合性。\n而没有明确放入某个优先级组的自定义中缀运算符将会被放到一个默认的优先级组内，其优先级高于三元运算符。\n以下例子定义了一个新的自定义中缀运算符+-，此运算符属于AdditionPrecedence优先组。\ninfix operator +-: AdditionPrecedence extension Vector2D { static func +- (left: Vector2D, right: Vector2D) -\u0026gt; Vector2D { return Vector2D(x: left.x + right.x, y: left.y - right.y) } } let firstVector = Vector2D(x: 1.0, y: 2.0) let secondVector = Vector2D(x: 3.0, y: 4.0) let plusMinusVector = firstVector +- secondVector // plusMinusVector是一个Vector2D实例，并且它的值为(4.0, -2.0) print(\u0026#34;plusMinusVector的值为：\\(plusMinusVector)\u0026#34;) --- output: plusMinusVector的值为：Vector2D(x: 4.0, y: -2.0) 这个运算符把两个向量的x值相加，同时从第一个向量的y值中减去第二个向量的y。因为它本质上是属于“相加型”运算符，所以将它放置在+和-等默认中缀“相加型”运算符相同的优先级组（AdditionPrecedence)中。\n注意\n当定义前缀和后缀运算符的时候，并没有指定优先级。然而，如果对一个值同时使用前缀和后缀运算符，则后缀运算符会先参与运算。\n结果构造器 结果构造器是一种自定义类型，支持添加自然的声明式语法来创建类似列表或者树这样的嵌套数据。使用结果构造器代码可以包含普通的Swift语法，例如用来处理判断条件的if，或者处理重复数据的for。\n下面的代码定义了一些类型用于绘制星星线段和文字线段。\nprotocol Drawable { func draw() -\u0026gt; String } struct Line: Drawable { var elements: [Drawable] func draw() -\u0026gt; String { return elements.map { $0.draw() }.joined(separator: \u0026#34;\u0026#34;) // 绘制Line时，调用了线段中每个元素的draw()，然后将所有结果字符串连城单个字符串 } } struct Text: Drawable { var content: String init(_ content: String) { self.content = content } func draw() -\u0026gt; String { return content } } struct Space: Drawable { func draw() -\u0026gt; String { return \u0026#34; \u0026#34; } } struct Stars: Drawable { var length: Int func draw() -\u0026gt; String { return String(repeating: \u0026#34;*\u0026#34;, count: length) } } struct AllCaps: Drawable { var content: Drawable func draw() -\u0026gt; String { return content.draw().uppercased() } } Drawable协议定制了绘制所需要遵循的方法，例如线条或者形状都需要实现draw()方法。Line结构体用来表示单行线段绘制，给大多数可绘制的元素提供了顶层容器。绘制Line时，调用了线段中每个元素的draw()，然后将所有结果字符串连城单个字符串。Text结构体包装了一个字符串作为绘制的一部分。AllCaps结构体包装另一个可绘制元素，并将元素中所有文本转换成大写。\n可以组合这些类型的构造器来创建一个可绘制元素。\nlet name: String? = \u0026#34;Jensen Jon\u0026#34; let manualDrawing = Line(elements: [Stars(length: 3), Text(\u0026#34;Hello\u0026#34;), Space(), AllCaps(content: Text((name ?? \u0026#34;World\u0026#34;) + \u0026#34;!\u0026#34;)), Stars(length: 2)]) print(manualDrawing.draw()) // 打印“***Hello JENSEN JON!**” --- output: ***Hello JENSEN JON!** 代码没问题，但是不够优雅。AllCaps后面的括号嵌套太深，可读性不佳。name为nil时使用“World”的兜底逻辑必须要依赖??操作符，这在逻辑复杂的时候会更加难以阅读。如果还需要switch或者for循环来构建绘制的一部分，就更难以编写了。使用结果构造器可以将这样的代码重构得更像普通的Swift代码。\n在类型的定义上加上@resultBuilder特性来定义一个结果构造器。比如下面的代码定义了允许使用声明式语法来描述绘制的结果构造器DrawingBuilder。\n@resultBuilder struct DrawingBuilder { static func buildBlock(_ components: Drawable...) -\u0026gt; Drawable { return Line(elements: components) } static func buildEither(first component: Drawable) -\u0026gt; Drawable { return component } static func buildEither(second component: Drawable) -\u0026gt; Drawable { return component } } DrawingBuilder结构体定义了三个方法来实现部分结果构造器语法。\nbuildBlock(_:)方法添加了在方法块中写多行代码的支持。它将方法块中的多个元素组合成Line。buildEither(first:)方法和buildEither(second:)方法添加了对if-else的支持。\n可以在函数形参上应用@DrawingBuilder特性，它会将传递给函数的闭包转换为用结果构造器创建的值。\nfunc draw(@DrawingBuilder content: () -\u0026gt; Drawable) -\u0026gt; Drawable { return content() } func caps(@DrawingBuilder content: () -\u0026gt; Drawable) -\u0026gt; Drawable { return AllCaps(content: content()) } func makeGreeting(for name: String? = nil) -\u0026gt; Drawable { let greeting = draw { Stars(length: 3) Text(\u0026#34;Hello\u0026#34;) Space() caps { if let name = name { Text(name + \u0026#34;!\u0026#34;) } else { Text(\u0026#34;World!\u0026#34;) } } Stars(length: 2) } return greeting } let genericGreeting = makeGreeting() print(genericGreeting.draw()) // 打印“***Hello WORLD!**” let personalGreeting = makeGreeting(for: \u0026#34;Jensen Jon\u0026#34;) print(personalGreeting.draw()) // 打印“***Hello JENSEN JON!**” --- output: ***Hello WORLD!** ***Hello JENSEN JON!** makeGreeting(for:)函数将传入的name形参用于绘制个性化问候。\ndraw(_:)和caps(_:)函数都传入应用@DrawingBuilder特性的单一闭包实参。当调用这些函数时，要使用DrawingBuilder定义的特殊语法。Swift将绘制的声明式描述转换成一系列DrawingBuilder方法调用，构造成最终传递进函数的实参值。例如，Swift将例子中的caps(_:)的调用转换为下面的代码。\nlet capsDrawing = caps { let partialDrawing: Drawable if let name = name { let text = Text(name + \u0026#34;!\u0026#34;) partialDrawing = DrawingBuilder.buildEither(first: text) } else { let text = Text(\u0026#34;World!\u0026#34;) partialDrawing = DrawingBuilder.buildEither(second: text) } return partialDrawing } Swift将if-else方法块转换成调用buildEither(first:)和buildEither(second:)方法，虽然不会在自己的代码中调用这些方法，但是转换后的结果可以更清晰的理解在使用DrawingBuilder语法时Swift是如何进行转换的。\n为了支持for循环来满足某些特殊的绘制语法，需要添加buildArray(:_)方法。\nextension DrawingBuilder { static func buildArray(_ components: [Drawable]) -\u0026gt; Drawable { return Line(elements: components) } } func makeStars() -\u0026gt; Drawable { let manyStars = draw { Text(\u0026#34;Stars:\u0026#34;) for length in 1...3 { Space() Stars(length: length) // for循环中自动调用buildArray(_:)方法 } } return manyStars } let generateStars = makeStars() print(generateStars.draw()) --- output: Stars: * ** *** 上面的代码中，使用for循环创建了一个绘制数组，buildArray(_:)方法将该数组构建成Line。\n","date":"2021-08-12T00:00:00Z","permalink":"https://jen-jon.github.io/posts/advancedop/","tags":"iOS; Swift; Apple","title":"Swift学习(4)-高级运算符（代码完善版）","type":"technology"},{"contents":"运算符是检查、改变、合并值的特殊符号或短语。例如，加号+将两个数组相加（如let i = 1 + 2）。更复杂的运算例子包括逻辑与运算符\u0026amp;\u0026amp;（如if enteredDoorCode \u0026amp;\u0026amp; passedRetinaScan）。\nSwift所支持的运算符大家都可能在别的语言比如C语言中认识了，同时为了减少常见编码错误对它们做了部分改进。如：赋值符=不再有返回值，这样就消除了手误将判等运算符==写成赋值运算符导致代码出现错误的缺陷。\n算术运算符（+、-、*、/、%等）的结果会被检测并禁止溢出，以此来避免保存变量时由于变量大于或小于其类型所能承载的范围时到值的异常结果。当然允许使用Swift的溢出运算符来实现溢出。\nSwift还提供了C语言没有的区间运算符，例如a..\u0026lt;b或a...b，这方便我们表达一个区间内的数值。\n术语 运算符分为一元、二元和三元运算符：\n一元运算符对单一操作对象操作（如 -a）。一元运算符分前置运算符和后置运算符，前置运算符需要紧跟在操作对象之前（如 !b），后置运算符需紧跟在操作对象之后（如 c!） 二元运算符操作两个操作对象（2 + 3），是中置的，因为它们出现在两个操作对象之间 三元运算符操作三个操作对象，和C语言一样，Swift只有一个三元运算符，就是三目运算符（a ? b : c） 受运算符影响的值叫操作数，在表达式1 + 2中，加号 + 是二元运算符，它的两个操作数是值1和2。\n赋值运算符 赋值运算符（a = b），表示用b的值来初始化或更新a的值。\nlet b = 10 var a = 5 a = b // a现在就等于b的值，10 print(\u0026#34;将b的值赋给a，现在a的值为：\\(a)\u0026#34;) --- output: 将b的值赋给a，现在a的值为：10 如果赋值的右边是一个多元组，它的元素可以马上被分解成多个常量或变量。\nvar (x, y) = (2, 5) // 现在x等于2，y等于5 print(\u0026#34;元组(2, 5)被分解后，现在x等于：\\(x)，y等于：\\(y)\u0026#34;) --- output: 元组(2, 5)被分解后，现在x等于：2，y等于：5 和C语言和Ojective-C语言不同，Swift的赋值操作并不返回任何值，所以下面的语句是无效的：\n// if x = y { // 此结构错误，因为x = y并不返回任何值，报错Use of \u0026#39;=\u0026#39; in a boolean context, did you mean \u0026#39;==\u0026#39;? // } if x == y { // 此结构正常不报错 } 通过if x = y标记为无效语句，Swift能帮开发值避免把==错写成=这类错误的出现。\n算术运算符 Swift中所有的数值类型都支持了基本的四则算术运算符:\n加法（+） 减法（-） 乘法（*） 除法（/） print(\u0026#34;1 + 2等于：\u0026#34;, 1 + 2) // 等于3 print(\u0026#34;5 - 3等于：\u0026#34;, 5 - 3) // 等于2 print(\u0026#34;2 * 3等于：\u0026#34;, 2 * 3) // 等于6 print(\u0026#34;10.0 / 2.5等于：\u0026#34;, 10.0 / 2.5) // 等于4.0 --- output: 1 + 2等于： 3 5 - 3等于： 2 2 * 3等于： 6 10.0 / 2.5等于： 4.0 与C语言和Objective-C语言不同的是，Swift默认情况下不允许在数值运算中出现溢出情况。但是可以使用Swift的溢出运算符来实现溢出运算（如a \u0026amp;+ b）。\n加法运算符也可用于String的拼接。\nprint(\u0026#34;Hello \u0026#34; + \u0026#34;World!\u0026#34;) // 等于“Hello World!” --- output: Hello World! 求余运算符 求余运算符（a % b）是计算b的多少倍刚好可以容入a，返回多出来的那部分（余数）。\n注意\n求余运算符（%）在其他语言中也叫取模运算符。但是严格来说，通过观察该运算符对负数的操作结果，“求余”比“取模”更合适些。\n来看看取余操作究竟是怎么一回事，计算9 % 4，先计算4的多少倍会刚好可以容入9中：\n可以在9中放入两个4，那余数是1。\n在Swift中可以表达为。\nprint(\u0026#34;9 % 4的结果是：\\(9 % 4)\u0026#34;) // 等于1 --- output: 9 % 4的结果是：1 同样的方法来计算 -9 % 4：\nprint(\u0026#34;-9 % 4的结果是：\\(-9 % 4)\u0026#34;) // 等于-1 --- output: -9 % 4的结果是：-1 在对负数b取余时，b的符号会被忽略。这意味着a % b和a % -b的结果是相同的。\nprint(\u0026#34;9 % -4的结果是：\\(9 % -4)，与9 % 4的结果相同。\u0026#34;) --- output: 9 % -4的结果是：1，与9 % 4的结果相同。 一元负号运算符 数值的正负号可以使用前缀-（即一元负号运算符）来切换。\nlet three = 3 let minusThree = -three // minusThree等于-3 let plusThree = -minusThree // plusThree等于3，即“负负得正” print(\u0026#34;负负得正的结果是：\\(plusThree)\u0026#34;) --- output: 负负得正的结果是：3 一元正号运算符 一元正号运算符+不做任何改变地返回操作数的值。\nlet minusSix = -6 let alsoMinusSix = +minusSix print(\u0026#34;正号运算符啥都不会改变，所以alsoMinusSix的值为：\\(alsoMinusSix)\u0026#34;) --- output: 正号运算符啥都不会改变，所以alsoMinusSix的值为：-6 虽然一元正好运算符啥都不会改变，但是当使用一元负号运算符来表达负数时，可以同时使用一元正号运算符来表达整数，这样会保持代码的对称美。\n组合赋值运算符 如同C语言，Swift也提供把其他运算符和赋值运算符=组合的组合赋值运算符，组合加运算+=是其中一个例子。\nvar c = 2 c += 2 print(\u0026#34;c经过组合加运算后的值是：\\(c)\u0026#34;) // c现在是3 --- output: c经过组合加运算后的值是：4 表达式a += 2是a = a + 2的简写，一个组合加运算就是把加法运算和赋值运算组合成进一个运算符里，同时完成两个运算任务。\n注意\n复合赋值运算没有返回值。let b = a += 2这类代码是错误的，这不同于上面提到的自增和自减运算符。\n比较运算符（Comparison Operators） Swift支持以下的比较运算符：\n等于（a == b） 不等于（a != b） 大于（a \u0026gt; b） 小于（a \u0026lt; b） 大于等于（a \u0026gt;= b） 小于等于（a \u0026lt;= b） 注意\nSwift也提供恒等（===）和不恒等（!==）这两个比较符来判断两个对象是否引用同一个对象实例。\n每个比较运算符都返回了一个标识表达式。\nprint(\u0026#34;1等于1：\\(1 == 1)\u0026#34;) // true print(\u0026#34;2不等于1：\\(2 != 1)\u0026#34;) // true print(\u0026#34;2大于1：\\(2 \u0026gt; 1)\u0026#34;) // true print(\u0026#34;1小于2：\\(1 \u0026lt; 2)\u0026#34;) // true print(\u0026#34;1大于等于1：\\(1 \u0026gt;= 1)\u0026#34;) // true print(\u0026#34;2小于等于1：\\(2 \u0026lt;= 1)\u0026#34;) // false --- output: 1等于1：true 2不等于1：true 2大于1：true 1小于2：true 1大于等于1：true 2小于等于1：false 比较运算多用于条件语句，如if条件。\nlet name = \u0026#34;Jensen\u0026#34; if name == \u0026#34;world\u0026#34; { print(\u0026#34;Hello, World!\u0026#34;) } else { print(\u0026#34;I\u0026#39;m sorry \\(name), but I don\u0026#39;t recognize you.\u0026#34;) } --- output: I\u0026#39;m sorry Jensen, but I don\u0026#39;t recognize you. 如果两个元组的元素类型相同且长度相同，元组就可以比较。比较元组大小会按照从左到右，逐值比对的方式，直到发现有两个值不等时停止。如果所有的值都相等，那么这一对元组就被称为相等的。\nprint(\u0026#34;元组比较1：\\((1, \u0026#34;zebra\u0026#34;) \u0026lt; (2, \u0026#34;apple\u0026#34;))\u0026#34;) // true 因为1小于2，所以(1, \u0026#34;zebra\u0026#34;) \u0026lt; (2, \u0026#34;apple\u0026#34;)，虽然\u0026#34;zebra\u0026#34; \u0026gt; \u0026#34;apple\u0026#34;，但对最后的结果没有影响 print(\u0026#34;元组比较2：\\((3, \u0026#34;apple\u0026#34;) \u0026lt; (3, \u0026#34;bird\u0026#34;))\u0026#34;) // true 当第一个元素相同时，元组的第二个元素会进行比较 print(\u0026#34;元组比较3：\\((4, \u0026#34;dog\u0026#34;) == (4, \u0026#34;dog\u0026#34;))\u0026#34;) // true --- output: 元组比较1：true 元组比较2：true 元组比较3：true 因此，当元组中的元素都可以被比较时，可以使用这些运算符来比较它们的大小。例如，可以比较两个类型为(String, Int)的元组，因为Int和String类型的值都是可以比较的。相反Bool不能被比较，也意味着存有布尔类型的元组不能被比较。\nprint(\u0026#34;String和Int类型元素是可以被比较的：\\((\u0026#34;blue\u0026#34;, -1) \u0026lt; (\u0026#34;purple\u0026#34;, 1))\u0026#34;) // 正常，比较的结果为true //(\u0026#34;blue\u0026#34;, false) \u0026lt; (\u0026#34;purple\u0026#34;, true) // 错误，因为 \u0026lt; 不能比较布尔类型值，若取消注释，则报错Binary operator \u0026#39;\u0026lt;\u0026#39; cannot be applied to two \u0026#39;(String, Bool)\u0026#39; operands --- output: String和Int类型元素是可以被比较的：true 注意\nSwift标准库只能比较七个以内元素的元组的比较，如果元组中的元素个数超过六个，则需要自己实现比较运算符。\n三元运算符 三元运算符的特殊主要在于它是有三个操作数的运算符，它的形式是问题 ? 答案1 : 答案2。它简洁地表述问题成立与否作出二选一的操作。如果问题成立，返回答案1的结果，反之返回答案2的结果。\n三元运算符试一下代码的缩写形式。\nlet question = 3 \u0026gt; 2 let answer1 = 3, answer2 = 2 print(\u0026#34;三元运算符的结果：\\(question ? answer1 : answer2)\u0026#34;) // 三元运算符 if question { print(\u0026#34;answer1的结果是：\\(answer1)\u0026#34;) } else { print(\u0026#34;answer2的结果是：\\(answer2)\u0026#34;) } --- output: 三元运算符的结果：3 answer1的结果是：3 这里有个计算表格里行高的例子，如果有表头，那行高应该比内容高度要高出50点；如果没有表头，只需要高出20点。\nlet contentHeight = 40 let hasHeader = true let rowHeight = contentHeight + (hasHeader ? 50 : 20) // rowHeight现在是90 print(\u0026#34;rowHeight现在的值是：\\(rowHeight)\u0026#34;) --- output: rowHeight现在的值是：90 上面的写法比下面的代码更加简洁。\nlet contentHeights = 40 let hasHeaders = true var rowHeights = contentHeights if hasHeaders { rowHeights += 50 print(\u0026#34;hasHeaders = True, rowHeights: \\(rowHeights)\u0026#34;) } else { rowHeights += 20 print(\u0026#34;hasHeaders = False, rowHeights: \\(rowHeights)\u0026#34;) } --- output: hasHeaders = True, rowHeights: 90 第一段代码例子使用了三元运算，所以一行代码就能让我们得到正确答案。这比第二段代码简洁得多，无需将rowHeight定义成变量，因为它的值无需在if语句中改变。\n三元运算为二选一场景提供了一个非常便捷的表达形式。不过需要注意的是，为了提高代码的可读性，应当避免在一个复合语句中使用多个三元运算符。\n空合运算符（Nil Coalescing Operator） 空合运算符a ?? b将对可选类型a进行空判断，如果a包含一个值就进行解包，否则就返回一个默认值b。表达式a必须是Optional类型。默认值b的类型必须要和a存储值的类型保持一致。\n空合运算符是对一下代码的简短表达方法。\nvar d: Int? = 3 let e: Int? = nil print(\u0026#34;空合运算符的原始表达的结果：\\((d != nil ? d! : e)!)\u0026#34;) // d != nil ? d! : e --- output: 空合运算符的原始表达的结果：3 上述代码使用了三元运算符。当可选类型a的值不为空时，进行强制解包a!，访问a中的值；反之返回默认值b。无疑空合运算符??提供了一种更为优雅的方式去封装条件判断合解包两种行为，显得简洁且以及更具有可读性。\n注意\n如果a为非空值（Non-nill），那么值b将不会被计算，这就是所谓的短路求值。\n下文例子采用空合运算符，实现了在默认颜色名和可选自定义颜色名之间的抉择。\nlet defaultColorName = \u0026#34;red\u0026#34; var userDefinedColorName: String? var colorNameToUse = userDefinedColorName ?? defaultColorName // userDefinedColorName的值为Nil，所以colorNameToUse的值为“red” print(\u0026#34;colorNameToUse的颜色是：\\(colorNameToUse)\u0026#34;) --- output: colorNameToUse的颜色是：red 由于userDefinedColorName值为空，因此表达式userDefinedColorName ?? defaultColorName返回defaultColorName的值，即red。\n如果分配一个非空值（non-nil）给userDefinedColorName，再次执行空合运算，运算结果为封包在userDefinedColorName中的值。而非默认值。\nuserDefinedColorName = \u0026#34;green\u0026#34; colorNameToUse = userDefinedColorName ?? defaultColorName print(\u0026#34;colorNameToUse的颜色是：\\(colorNameToUse)\u0026#34;) // userDefinedColorName非空，因此colorNameToUse的值为“green” --- output: colorNameToUse的颜色是：green 区间运算符（Range Operators） Swift提供了集中方便表达一个区间的值的区间运算符。\n闭区间运算符 闭区间运算符a...b定义一个包含从a到b（包括a和b）的所有值的区间。a的值不能超过b。\n闭区间运算符在迭代一个区间的所有值时是非常有效的，如在for-in循环中。\nfor index in 1...5 { print(\u0026#34;\\(index) * 5 = \\(index * 5)\u0026#34;) } --- output: 1 * 5 = 5 2 * 5 = 10 3 * 5 = 15 4 * 5 = 20 5 * 5 = 25 半开区间运算符 半开区间运算符a..\u0026lt;b定义一个从a到b但不包括b的区间。之所以被称为半开区间，是因为该区间包含第一个值而不包括最后的值。\n半开区间的实用性在于当使用一个从0开始的列表（如数组）时，能够非常方便地从0数到列表的长度。\nlet names = [\u0026#34;Jensen\u0026#34;, \u0026#34;Alex\u0026#34;, \u0026#34;Davis\u0026#34;, \u0026#34;Jerry\u0026#34;] let count = names.count for i in 0..\u0026lt;count { print(\u0026#34;第\\(i + 1)个人叫\\(names[i])\u0026#34;) } --- output: 第1个人叫Jensen 第2个人叫Alex 第3个人叫Davis 第4个人叫Jerry 数组有4个元素，但0..\u0026lt;count只数到3（最后一个元素的下标），因为其是半开区间。\n单侧区间 闭区间操作符有另一个表达形式，可以表达往一侧无限延伸的区间。例如，一个包含了数组从索引2到结尾的所有值的区间。在这些情况下，可以省略掉区间操作符一侧的值，这种区间叫单侧区间。\nfor name in names[2...] { print(\u0026#34;names[2...], \u0026#34;, name) } for name in names[...2] { print(\u0026#34;names[...2], \\(name)\u0026#34;) } --- output: names[2...], Davis names[2...], Jerry names[...2], Jensen names[...2], Alex names[...2], Davis 半开区间操作符也有单侧表达式，附带上它的最终值。就像使用区间去包含一个值，最终值并不会落在区间内。\nfor name in names[..\u0026lt;2] { print(\u0026#34;names[..\u0026lt;2], \\(name)\u0026#34;) } --- output: names[..\u0026lt;2], Jensen names[..\u0026lt;2], Alex 单侧区间不止可以在下标里使用，也可以在别的情境下使用。也可以使用查看单侧区间时都包含某个特定的值。\nlet range = ...5 print(\u0026#34;range.contains(7): \\(range.contains(7))\u0026#34;) // false print(\u0026#34;range.contains(4): \\(range.contains(4))\u0026#34;) // true print(\u0026#34;range.contains(-1): \\(range.contains(-1))\u0026#34;) // true --- output: range.contains(7): false range.contains(4): true range.contains(-1): true 注意\n不能遍历省略了初始值的单侧区间，因为遍历的开端并不明显。但可以遍历一个省略最终值的单侧区间。然而由于这种区间无限延伸的特性，请保证在循环里有一个结束循环的分支。\n逻辑运算符（Logical Operators） 逻辑运算符的操作对象时逻辑布尔值，Swift支持基于C语言的三个标准逻辑运算：\n逻辑非（!a） 逻辑与（a \u0026amp;\u0026amp; b） 逻辑或（a || b） 逻辑非运算符 逻辑非运算符!a对一个布尔值取反，使得true变false，false变true。\n它是一个前置运算符，需要紧紧跟在操作数前，且不加空格。读作非a，例子如下：\nlet allowedEntry = false if !allowedEntry { // 当allowedEntry为false，即!allowedEntry为true时，运行代码块 print(\u0026#34;ACCESS DENIED\u0026#34;) // 输出“ACCESS DENIED” } --- output: ACCESS DENIED 开发过程中小心地选择布尔常量或变量有助于代码的可读性，并且避免使用双重逻辑非运算或混乱的逻辑语句。\n逻辑与运算符 逻辑与运算符a \u0026amp;\u0026amp; b表达了只有a和b的值都为true时，整个表达式的值才会是true。\n只要任意一个表达式是false，整个表达式的值就为false。事实上如果第一个表达式的值为false，那么是不去计算第二个值的，因为后面的值已经不可能影响整个表达式的结果了，这被称作段路计算（Short-Circuit Evaluation）。\nlet enteredDoorCode = true let passedRetinaScan = false if enteredDoorCode \u0026amp;\u0026amp; passedRetinaScan { // passedDoorCode的值是false，所以整个表达式的值也是false print(\u0026#34;Welcome!\u0026#34;) } else { print(\u0026#34;ACCESS DENIED\u0026#34;) // 输出\u0026#34;ACCESS DENIED\u0026#34; } --- output: ACCESS DENIED 逻辑或运算符 逻辑或运算符a || b是一个由两个连续的|组成的中置运算符。它表示了两个逻辑表达式的其中一个为true，整个表达式就为true。\n同逻辑运算符类似，逻辑或也是“短路计算”的，当左端的表达式为true时，将不计算右边的表达式了，因为其也不可能改变整个表达式的值了。\nlet hasDoorKey = false let knowsOverridePassword = true if hasDoorKey || knowsOverridePassword { // knowsOverridePassword的值是true，所以整个表达式的值是true print(\u0026#34;Welcome!\u0026#34;) // 输出“Welcome!” } else { print(\u0026#34;ACCESS DENIED\u0026#34;) } --- output: Welcome! 逻辑运算符组合计算 可以组合多个逻辑运算符来表达一个复合逻辑。\nif enteredDoorCode \u0026amp;\u0026amp; passedRetinaScan || hasDoorKey || knowsOverridePassword { print(\u0026#34;Welcome!\u0026#34;) // 输出“Welcome!” } else { print(\u0026#34;ACCESS DENIED\u0026#34;) } --- output: Welcome! 上述例子使用了含多个\u0026amp;\u0026amp;和||的复合逻辑。无论怎样，\u0026amp;\u0026amp;和||始终只能操作两个值，所以这实际上是三个简单逻辑连续操作的结果。\n注意\nSwift逻辑操作符\u0026amp;\u0026amp;和||是左结合的，这意味着拥有多元逻辑操作符的复合表达式优先计算最左边的子表达式。\n使用括号来明确优先级 为了一个复杂表达式更容易读懂，在合适的地方使用括号来明确优先级是很有效的，虽然它并非必要的。在上个例子中，给第一个部分加一个括号，使它看起来更明确。\nif (enteredDoorCode \u0026amp;\u0026amp; passedRetinaScan) || hasDoorKey || knowsOverridePassword { print(\u0026#34;Welcome!\u0026#34;) // 输出“Welcome!” } else { print(\u0026#34;ACCESS DENIED\u0026#34;) } --- output: Welcome! 这括号使得前两个值被看成整个逻辑表达中独立的一个部分，虽然有括号和没括号的输出结果是一样的，但对于读代码的人来说有括号的代码更清晰，可读性比和简洁性一样非常重要。\n","date":"2021-08-10T00:00:00Z","permalink":"https://jen-jon.github.io/posts/swiftbasicop/","tags":"iOS; Swift; Apple","title":"Swift学习(3)-基本运算符（代码完善版）","type":"technology"},{"contents":"Swift包含了C和Objective-C上所有基础数据类型，Int表示整型值；Double和Float表示浮点值；Bool是布尔型值；String是文本型数据。Swift还提供了三个基本的集合类型，Array、Set和Dictionary。\n就像C语言一样，Swift使用变量来进行存储并通过变量名来关联值。在Swift中，广泛的使用者着值不可变的变量，它们就是常量，而且比C语言中的常量更强大。在Swift中，如果要处理的值不需要改变，那使用常量可以让代码更加安全并且更清晰地表达意图。\n除了我们熟悉的类型，Swift还增加了Objective-C中没有的高阶数据类型比如元组（Tuple）。元组可以让使用者创建或者传递一组数据，比如作为函数的返回值时，可以用一个元组返回多个值。\nSwift还增加了一个可选（Optional）类型，用于处理值缺失的情况。可选便是“那儿有一个值，并且它等于x”或者“那儿没有值”。可选有点像在Objective-C中使用nil，但是它可以用在任何类型上，不仅仅是类。可选类型比Objective-C中的nil指针更加安全也更具有表现力，它是Swift许多强大特性的重要组成部分。\nSwift是一门类型安全的语言，这意味着Swift可以让使用者清楚地知道值的类型。如果代码需要一个String参数，类型安全会阻止不小心传入的一个Int参数。同样的，如果代码需要的是一个String参数，类型安全会阻止意外传入一个可选的String。类型安全可以帮助开发者在开发阶段尽早地发现并修正错误。\n常量和变量 常量和变量把一个名字（如testVal）和一个指定类型的值（如“Jensen”）关联起来。常量的值一旦设定就不能再改变，而变量的值可以随意地更改。\n声明常量和变量 常量和变量必须在使用前声明，用let来声明常量，用var来声明变量。\nlet maximumNumberOfLoginAttempts = 10 // 常量记录一共可以进行的登录尝试次数 var currentLoginAttempt = 0 // 变量记录当前登陆尝试次数 上述两行代码可以被理解为：“声明一个名字是maximumNumberOfLoginAttempts的新常量，并给它一个值10 。然后，声明一个名字是currentLoginAttempt的变量并将它的值初始化为0”。\n可以在一行中声明多个常量或者多个变量，用逗号隔开。\nvar x = 0.0, y = 0.0, z = 0.0 注意\n如果代码中有不需要改变的值，请使用let关键字将它声明为常量。只将需要改变的值声明为变量即可。\n类型注解 当声明常量或者变量的时候可以加上类型注解（Type Annotation），说明常量或者变量中要存储的值的类型。如果要添加类型注解，需要在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。\nvar welcomeMessage: String // 给welcomeMessage变量增加了类型注解，表示这个变量可以存储String类型的值 // 上述声明中的冒号代表着“是 ... 类型”，welcomeMessage变量现在可以被设置成任意字符串。 welcomeMessage = \u0026#34;Hello!\u0026#34; 甚至可以在一行中定义多个同样类型的变量，用逗号分隔，并在最后一个变量名之后添加类型注解。\nvar red, green, yellow: Double 常量和变量的命名 常量和变量名几乎可以包含所有的字符，包括Unicode字符。\nlet π = 3.141592654 let 你好 = \u0026#34;你好世界！\u0026#34; let 🐮🍺 = \u0026#34;666\u0026#34; 但是也存在例外，常量与变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。\n一旦给常量或者变量添加了类型注解，就不可以使用相同的名字再次进行声明，或者改变其存储的值的类型。同时，Swift也不允许将变量与变量进行互转。\n注意\n如果需要使用与Swift保留关键字相同的名称作为常量或者变量名，可以使用反引号(`)将关键字包围的方式将其作为名字使用。无论如何，开发者都应当避免使用保留关键字作为常量或变量名，除非别无选择。\n可以更改现有的变量值为其他同类型的值。\nvar friendlyWelcome = \u0026#34;Hello!\u0026#34; friendlyWelcome = \u0026#34;Benjour!\u0026#34; // friendlyWelcome现在是“Bonjour!” friendlyWelcome = \u0026#34;你好！\u0026#34; // friendlyWelcome现在是“欢迎！” // 与变量不同，常量的值一旦被确定就不能更改了。尝试这样做会导致变异时报错。 let languageName = \u0026#34;Swift\u0026#34; //languageName = \u0026#34;C++\u0026#34; // 取消这行注释编译器会报Cannot assign to value: \u0026#39;languageName\u0026#39; is a \u0026#39;let\u0026#39; constant错误 输出常量和变量 print(friendlyWelcome) // 输出：你好！ --- output: 你好！ separator和terminator参数具有默认值，因此调用这个函数的时候可以忽略它们。\n默认情况下，输出函数通过添加换行符来结束当前行。如果不想换行，可以传递一个空字符串给terminator参数。\nprint(\u0026#34;Line1\u0026#34;, terminator: \u0026#34;\u0026#34;) print(\u0026#34;Line2\u0026#34;) --- output: Line1Line2 Swift用字符串插值（String interpolation）的方式把常量名或者变量名当做占位符加入到长字符串中。Swift会用当前常量或者变量的值替换这些占位符。将常量或者变量名放入圆括号中，并在开括号钱使用反斜杠将其转义。\nprint(\u0026#34;The current login attempt is \\(currentLoginAttempt), you have \\(maximumNumberOfLoginAttempts) login attempts in total.\u0026#34;) --- output: The current login attempt is 0, you have 10 login attempts in total. 注释 Swift中的注释与C语言的注释十分相似，单行注释以双正斜杠//作为起始标记。\n也可以进行多行注释，其起始标记为单个正斜杠后跟随一个星号/*，终止标记为一个星号后跟单个正斜杠*/。\n/* 这是一个注释 但是是多行注释 */ 与C语言不同的是，Swift的多行注释可以嵌套在其它的多行注释之中。\n/* 这是外层注释的第一行 /* 这是内层注释 */ 这是外层注释的最后一行 */ 通过运用嵌套多行注释，能够快速方便的注释掉一大段代码，即便这段代码之中已经含有了多行注释块。\n分号 与其他大部分编程语言不同，Swift并不强制要求开发者在每条语句的结尾处使用分号;。当然，开发者也可以根据自己的习惯添加分号，但是有一种情况下必须要使用分号，即在同一行内写多条独立语句。\nlet pig = \u0026#34;🐷\u0026#34;; print(pig) --- output: 🐷 整数 整数就是没有小数部分的数字，比如43和-23。Swift提供了8、16、32和64位的有符号和无符号整数类型。这些整数类型和C语言的命名方式很像，比如8位无符号整数类型是UInt8，32位有符号整数类型是Int32。就像Swift的其他类型一样，整数类型采用大写命名法。\n整数范围 可以访问不同整数类型的min和max属性来获取对应类型的最小值和最大值。\nlet minValue = UInt8.min let maxValue = UInt8.max print(\u0026#34;UInt8类型的最小值是：\\(minValue)\\nUInt8类型的最大值是：\\(maxValue)\u0026#34;) --- output: UInt8类型的最小值是：0 UInt8类型的最大值是：255 min和max所传回值的类型正是其所对的整数类型，如上例UInt8，所传回的值的类型也是UInt8。\nInt 一般来说，不需要专门指定整数的长度。Swift提供了一个特殊的整数类型Int，长度与当前平台的原生字长相同:\n在32位平台上，Int与Int32长度相同\n在64位平台上，Int和Int64长度相同\nUInt 与Int类型一样，Swift也提供了一个特殊的无符号类型UInt，长度与当前平台的原生字长相同：\n在32位平台上，UInt和UInt32长度相同\n在64位平台上，UInt和UInt64长度相同\n注意\n尽量不要使用UInt，除非真的需要存储一个和当前平台原生字长相同的无符号整数。否则最好使用Int，统一使用Int能够提高代码的可复用性，避免不同类型数字之间的转换，并且匹配数字的类型推断。\n浮点数 浮点数就是有小数部分的数字，比如3.141592654、0.1和-98.09等等。\n浮点类型比整数类型表示的范围要大，可以存储比Int类型更大或者更小的数字。Swift提供了两种有符号浮点数类型：\nDouble表示64位浮点数，当需要存储很大或者很高精度的浮点数时，请使用此类型\nFloat表示32位浮点数，当精度要求不高的话可以使用此类型\n注意\nDouble精确度很高，至少有15位小数，而Float只有6位小数。选择哪种类型取决于你的代码需要处理的值的范围，在两种类型都匹配的情况下将优先选择Double。\n类型安全和类型推断 Swift是一个类型安全（Type Safe）的语言。类型安全的语言可以开发者你清楚地知道代码要处理的值的类型。\n由于Swift是类型安全的，所以它在编译代码时会进行类型检查（Type Checks），并把不匹配的类型标记为错误。能够让开发者尽早地发现错误。\n当要处理不同类型的值时，类型检查可以帮助避免错误。然而，这并不是说每次声明常量和变量的时候都需要显式指定类型。如果没有显式指定类型，Swift会使用类型推断（Type Inference）来选择合适的类型。有了类型推断，编译器可以在编译代码的时候自动推断出表达式的类型。原理很简单，只要检查赋的值即可。\n当声明常量或者变量并赋初值的时候类型推断非常有用。声明常量或者变量的时候赋给它们一个字面量（Literal Value或Literal）即可触发类型推断。（字面量就是在代码中直接出现的值，比如0.1和3.141592654等等）\nlet meaningOfLife = 42 // meaningOfLife会被类型推断推测为Int类型 let pi = 3.141592654 // pi会被类型推断推测为Double类型，当推断浮点数类型时，Swift总是会选择Double而不是Float 如果表达式中同时出现了整数和浮点数，总是会被推断为Double类型。\nlet anotherPi = 3 + 0.141592654 // 原始值3没有显式地声明类型，而后又出现了一个浮点字面量，所以表达式被推断为Double类型 数值型字面量 整数字面量可以被写作：\n一个十进制数，没有前缀\n一个二进制数，前缀是0b； 一个八进制数，前缀是0o；一个十六进制数，前缀是0x\n下面所有的整数字面量的十进制值都是17:\nlet decimalInteger = 17 let binaryInteger = 0b10001 // 二进制的17 let octalInteger = 0o21 // 八进制的17 let hexadecimalInteger = 0x11 // 十六进制的17 小数点两边必须至少要有一个十进制数字或者是十六进制的数字。十进制浮点数也可以有一个可选的指数（Exponent），通过大写或者小写的e来指定；十六进制浮点数必须有一个指数，通过大写或者小写的p来指定。\n十进制：1.25e2表示1.2510^2，等于125.0； 八进制：0xFp-2表示152^-2，等于3.75\n下面的这些浮点字面量都等于十进制的12.1875。\nlet decimalDouble = 12.1875 let exponentDouble = 1.21875e1 let hexadecimalDouble = 0xC.3p0 数值类字面量可以包括额外的格式来增强可读性。整数和浮点数都可以添加额外的零并且包含下划线，并不影响字面量的值。\nlet paddedDouble = 000123.456 let oneMillion = 1_000_000 let justOverOneMillion = 1_000_000.000_000_1 数值型类型转换 通常来讲，即使代码中的整数常量和变量已知非负，也请使用Int类型。只有在必要的时候才使用其他整数类型，比如要处理外部的长度明确的数据或者为了优化性能、内存占用等等。使用显式指定长度的类型可以及时发现值溢出并且可以暗示正在处理特殊数据。\n整数转换 不同整数类型的变量和常量可以存储不同范围的数字。Int8类型的常量或者变量可以存储的数字范围为-128～127；而UInt8类型的常量或者变量能够存储的数字范围是0～255。如果数字超出了常量或者变量可存储的范围，编译的时候会报错。\n// let cannotBeNegative: UInt8 = -1 // 取消该行注释后，会报错：Negative integer \u0026#39;-1\u0026#39; overflows when stored into unsigned type \u0026#39;UInt8\u0026#39; // let tooBig: Int8 = Int8.max + 1 // 取消该行注释后，会报错：Arithmetic operation \u0026#39;127 + 1\u0026#39; (on type \u0026#39;Int8\u0026#39;) results in an overflow 开发者需要根据不同情况选择使用数值型类型转换，这种选择性使用方式，可以预防隐式转换的错误并让代码中的类型转换意图变得清晰。\nlet twoThousand: UInt16 = 2_000 let one: UInt8 = 1 let twoThousandAndOne = twoThousand + UInt16(one) // 该代码中UInt16(one)来创建一个新的UInt16数字并用one的值来初始化它，然后便可以使得两个无符号16位值相加 print(\u0026#34;UInt8转换至UInt16: \u0026#34;, twoThousandAndOne) --- output: UInt8转换至UInt16: 2001 SomeType(ofInitialValue)是调用Swift构造器并传入一个初始值的默认方法。在语言内部，UInt16有一个构造器，可以接受一个UInt8类型的值，所以这个构造器可以用现有的UInt8来创建一个新的UInt16。\n整数和浮点数转换 整数和浮点数的转换必须显式指定类型。\nlet three = 3 let pointOneFourOneFiveNine = 0.14159 let simplePi = Double(three) + pointOneFourOneFiveNine // pi等于3.14159，所以被类型推断为Double类型 print(\u0026#34;整数和浮点数转换：\u0026#34;, simplePi) --- output: 整数和浮点数转换： 3.14159 在上述例子中，常量three的值被用来创建一个Double类型的值，否则加号两边的数类型不同，无法相加。\n浮点数到整数的反向转换同样行，整数类型可以用Double或者Float类型来初始化。\nlet roundPi = Int(simplePi) // roundPi等于3，所以被推断为Int类型 print(\u0026#34;浮点数转换至整数：\u0026#34;, roundPi) --- output: 浮点数转换至整数： 3 当用这种方式来初始化一个新的整数值时，浮点值会被截断，也就是说4.75会变成4，-3.9会变成-3。\n注意\n结合数字类常量和变量不同于结合数字类字面量。字面量3可以直接和字面量0.14159相加，因为数字字面量本身没有明确的类型。它们的类型只在编译器需要求值的时候被预测。\n类型别名 类型别名（Type Aliases）就是给现有类型定义另一个名字。开发者可以使用Typealias关键字来定义类型别名。\n当想要给现有类型起一个更具有意义的名字时，类型别名非常有用。\n假设现在正在处理特定长度的外部资源的数据，定义了一个类型别名后，可以在任何使用原始名的地方使用别名。\ntypealias AudioSample = UInt16 var maxAmplitudeFound = AudioSample.min // maxAmplitudeFound现在是0 print(\u0026#34;maxAmplitudeFound现在的值是：\u0026#34;, maxAmplitudeFound) --- output: maxAmplitudeFound现在的值是： 0 上述例子中，AudioSample被定义为UInt16的一个别名，因为是别名，所以AudioSample.min实际上是UInt16.min。\n布尔值 Swift有一个基本的布尔（Boolean）类型，叫做Bool。布尔值指的是逻辑上的值，因为其只能是真或者假。Swift有两个布尔值常量，true和false。\nlet orangesAreOrange = true let turnipsAreDelicious = false orangesAreOrange和turnipsAreDelicious的类型会被推断为Bool，因为它们的初值是布尔字面量。就像之前提到的Int和Double一样，如果创建常/变量的时候就赋予true或false，就不需要将常/变量声明为Bool类型。\n编写条件语句特别是if条件语句时，布尔值就非常有用。\nif turnipsAreDelicious { print(\u0026#34;Haha, turnips are decilious!\u0026#34;) } else { print(\u0026#34;Oh shit! Turnips are horrible!\u0026#34;) } --- output: Oh shit! Turnips are horrible! 如果在需要使用Bool类型的地方使用了非布尔值，Swift的安全机制会报错。\nlet test = 1 //if test {} // 如果取消该行注释，则编译器会报错：Type \u0026#39;Int\u0026#39; cannot be used as a boolean; test for \u0026#39;!= 0\u0026#39; instead 同样的，下述例子是合法的。\nlet i = 1 if i == 1 {} // i == 1的结果是Bool类型，所以可以通过Swift的类型检查 元组 元组（Tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。\n下述例子，(404, \u0026ldquo;Not Found\u0026rdquo;) 是一个描述HTTP状态码（HTTP status code）的元组。\nlet http404Error = (404, \u0026#34;Not Found\u0026#34;) // http404Error的类型是(Int, String) (404, \u0026ldquo;Not Found\u0026rdquo;)元组把一个Int值和一个String值组合起来表示HTTP状态码的两部分。这个元组可以被描述成“一个类型为(Int, String)的元组”。\n可以把任意顺序的类型组合成一个元组，这个元组可以包含所有类型。还可以将一个元组的内容分解（Decompose）成单独的常量和变量，然后就可以正常使用它们了。\nlet (statusCode, statusMessage) = http404Error print(\u0026#34;The http status code is \\(statusCode).\u0026#34;) print(\u0026#34;The http status message is \\(statusMessage).\u0026#34;) --- output: The http status code is 404. The http status message is Not Found. 如果只需要一部分元组值，分解的时候可以吧要忽略的部分用下划线(_)标记，类似于Python。\nlet (httpStatusCode, _) = http404Error print(\u0026#34;The temp http status code is \\(httpStatusCode).\u0026#34;) --- output: The temp http status code is 404. 还可以通过下标来访问元组中的单个元素，下标从零开始。\nprint(\u0026#34;通过下标访问元组中的第一个元素：\u0026#34;, http404Error.0) print(\u0026#34;通过下标访问元组中的第二个元素：\\(http404Error.1)\u0026#34;) --- output: 通过下标访问元组中的第一个元素： 404 通过下标访问元组中的第二个元素：Not Found 可以在定义元组的时候给耽搁元素命名，然后通过名字来获取这些元素的值。\nlet http500Status = (statusCode: 500, description: \u0026#34;Server Error\u0026#34;) print(\u0026#34;通过元组元素命名方式访问第一个元素：\\(http500Status.statusCode)\u0026#34;) print(\u0026#34;通过元组元素命名方式访问第二个元素：\\(http500Status.description)\u0026#34;) --- output: 通过元组元素命名方式访问第一个元素：500 通过元组元素命名方式访问第二个元素：Server Error 当函数中需要返回多个值时，元组很有用。\n可选类型 使用可选类型（Optionals）来处理值可能缺失的情况。可选类型表示有两种可能：\n或者有值，开发者可以选择可选类型访问这个值；或者可能根本没有值\n一个例子，Swift的Int类型有一种构造器，作用是将一个String值转换成一个Int值。然而，不是所有的字符串都可以转换成一个整数。字符串“123”可以被转换成数字123，但是字符串“Hello， world”不行。\nlet possibleNumber = \u0026#34;123\u0026#34; var convertedNumber = Int(possibleNumber) print(\u0026#34;convertedNumber被推测为类型“Int?”，或者类型“optional Int”：\u0026#34;, convertedNumber!) let possibleName = \u0026#34;Jensen\u0026#34; convertedNumber = Int(possibleName) print(\u0026#34;字符串\\(possibleName)转成数字后有问题：\u0026#34;, convertedNumber) --- output: convertedNumber被推测为类型“Int?”，或者类型“optional Int”： 123 字符串Jensen转成数字后有问题： nil --- warning: Expression implicitly coerced from \u0026#39;Int?\u0026#39; to \u0026#39;Any\u0026#39; 由于该构造器可能会失效，所以Int(xxx)返回的是一个可选类型（optional）的Int，而不是一个Int。可选的Int被写作Int?，问号暗示包含的值时可选类型，但不能包含其他任何值比如Bool``值或者String值，只能是Int`或者是什么都没有。\nnil 可以给可选变量赋值为nil来表示没有值。\nvar serverResponseCode: Int? = 404 // serverResponseCode包含一个可选的Int值404 serverResponseCode = nil // serverResponseCode现在不包含值 print(\u0026#34;可选值serverResponseCode：\u0026#34;, serverResponseCode) --- output: 可选值serverResponseCode： nil --- warning: Expression implicitly coerced from \u0026#39;Int?\u0026#39; to \u0026#39;Any\u0026#39; 请注意，nil不能用于非可选的常量和变量，如果代码中有常量或者变量需要处理缺失值的情况，请把它们声明成对应的可选类型。如果声明一个可选常量或者变量但是没有赋值，它们会自动被设置为nil。\nvar surveyAnswer: String? print(\u0026#34;没有赋值的可选常/变量的值为：\u0026#34;, surveyAnswer) --- output: 没有赋值的可选常/变量的值为： nil --- warning: Expression implicitly coerced from \u0026#39;String?\u0026#39; to \u0026#39;Any\u0026#39; if语句以及强制解析 可以使用if语句和nil比较来判断一个可选值是否包含值，可以使用“相等”(==)或“不等”(!=)来执行比较。\n如果可选类型有值，它将不等于nil。\nif convertedNumber != nil { print(\u0026#34;convertedNumber contains some integer value.\u0026#34;) } else { print(\u0026#34;convertedNumber is nil.\u0026#34;) } --- output: convertedNumber is nil. 当确定可选类型确实包含值之后，可以在可选的名字后面加上一个感叹号!来获取值。这个操作被称为可选值的强制解析（Forced Unwrapping）。\nlet optionalInteger: Int? = 10086 if optionalInteger != nil { print(\u0026#34;The optional integer value is \\(optionalInteger!)\u0026#34;) // 来获取一个不存在的可选值会导致运行错误，使用！来强制解析值之前，一定要确定可选包含一个非nil的值。 } else { print(\u0026#34;The optional value is Nil.\u0026#34;) } --- output: The optional integer value is 10086 可选绑定 可选绑定（Optional Binding）来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或者变量。可选绑定可以用在if和while语句中。\nif let actualNumber = Int(possibleNumber) { print(\u0026#34;\\\u0026#39;\\(possibleNumber)\\\u0026#39; has an integer value of \\(actualNumber).\u0026#34;) } else { print(\u0026#34;\\\u0026#39;\\(possibleNumber)\\\u0026#39; could not be converted to an Integer.\u0026#34;) } --- output: \u0026#39;123\u0026#39; has an integer value of 123. 上述代码可以被理解为“如果Int(possibleNumber)返回的可选Int包含一个值，创建一个叫做actualNumber的新常量并将可选Int包含的值赋给它。actualNumber已经被可选类型包含的值初始化过，所以不需要再使用！后缀来获取它的值”。\n可以包含多个可选绑定或多个布尔条件在一个if语句中，只要使用逗号分开就行。只要有一个可选绑定的值为nil或者任意一个布尔条件为false，则整个if条件判断为false。\nif let firstNumber = Int(\u0026#34;4\u0026#34;), let secondNumber = Int(\u0026#34;42\u0026#34;), firstNumber \u0026lt; secondNumber \u0026amp;\u0026amp; secondNumber \u0026lt; 100 { print(\u0026#34;\\(firstNumber) \u0026gt; \\(secondNumber) \u0026lt; 100\u0026#34;) } // 等同下面的代码 if let firstNumber = Int(\u0026#34;4\u0026#34;) { if let secondNumber = Int(\u0026#34;42\u0026#34;) { if firstNumber \u0026lt; secondNumber \u0026amp;\u0026amp; secondNumber \u0026lt; 100 { print(\u0026#34;\\(firstNumber) \u0026gt; \\(secondNumber) \u0026lt; 100\u0026#34;) } } } --- output: 4 \u0026gt; 42 \u0026lt; 100 4 \u0026gt; 42 \u0026lt; 100 注意\n在if条件语句中使用常量和变量来创建一个可选绑定，仅在if语句的句中（body）中才能获取到值。相反，在guard语句中使用常量和变量来创建一个可选绑定，仅在guard语句外且在语句后才能获取到值。\n隐式解析可选类型 有时候在程序架构中，第一次被赋值后，可以确定一个可选类型总会有值。在这种情况下， 每次进行判断和解析可选值是非常低效的。这种类型可选状态被定义为隐式解析可选类型（Implicitly Unwrappered Optionals）。把想要用作可选的类型的后面的问号String?改成感叹号String!来声明一个隐式解析可选类型。与其在使用时把感叹号放在可选类型的名称的后面，可以在定义它时，就直接把感叹号放在可选类型的后面。\n当可选类型被第一次赋值之后就可以确定之后一直有值的时候，隐式解析可选类型非常有用。隐式解析可选类型主要被用在Swift中类的构造的过程中。\n一个隐式解析可选类型其实就是一个普通的可选类型，但是可以被当成非可选类型来使用，并不需要每次都使用解析来获取可选值。\nlet possibleString: String? = \u0026#34;An optional String.\u0026#34; let forcedString = possibleString! print(\u0026#34;显式解析可选类型：\u0026#34;, forcedString) let assumedString: String! = \u0026#34;An implicitly unwrapped optional String.\u0026#34; let implicitString: String = assumedString print(\u0026#34;隐式解析可选类型：\u0026#34;, implicitString) --- output: 显式解析可选类型： An optional String. 隐式解析可选类型： An implicitly unwrapped optional String. 可以把隐式解析可选类型当做一个可以自动解析的可选类型。当使用一个隐式解析可选值时，Swift首先会把它当作普通的可选值。如果它不能被当成可选类型使用，Swift会强制解析可选值。在上述的代码中，可选值assumedString在把自己的值赋给implicitString之前会被强制解析，原因是因为implicit本身的类型就是非可选类型的String。\n下述代码optionalString并没有显示的数据类型，那么根据类型推断，其就是一个普通的可选类型。\nlet optionalString = assumedString 如果在隐式解析可选类型没有值的时候尝试取值，会触发错误。与在没有值的普通可选类型后面加一个感叹号一样。\n可以吧隐式解析可选类型当做普通可选类型来判断其是否包含值。\nif assumedString != nil { print(\u0026#34;隐式解析可选类型取值：\u0026#34;, assumedString!) } --- output: 隐式解析可选类型取值： An implicitly unwrapped optional String. 也可以在可选绑定中使用隐式解析可选类型来检查病解析其值。\nif let definiteString = assumedString { print(\u0026#34;隐式解析可选类型取值：\u0026#34;, definiteString) } --- output: 隐式解析可选类型取值： An implicitly unwrapped optional String. 注意\n如果一个变量之后可能变成nil的话请不要使用隐式解析可选类型。如果需要在变量的生命周期中判断是否是nil的话，请使用普通可选类型。\n错误处理 可以使用错误处理（Error Handling）来应对程序执行中可能会遇到的错误条件。\n相较于可选类型中运用值的存在与否来表达函数的成功与失败，错误处理可以推断失败的原因，并传播至程序的其他部分。\n当一个函数遇到错误条件，它能报错。调用函数的地方能抛出错误消息并合理处理。\nfunc canThrowAnError() throws { // 这个函数内部可能会抛出错误 } 一个函数可以通过在声明中添加throws关键词来抛出错误信息。当函数能够抛出错误消息时，应该在表达式中前置try关键词。\ndo { try canThrowAnError() // 没有错误消息抛出则执行后面代码 } catch { // 有错误消息抛出则执行后面代码 } 一个do语句创建了一个新的包含作用域，使得错误能被传播到一个或多个catch从句。下述伪代码展示了错误处理如何用来应对不同错误条件的例子。\nfunc makeASandwich() throws { // function body } enum SandwichError: Error { case outOfCleanDishes case missingIngredients(ingredients: String) } do { try makeASandwich() // eatASandwich() } catch SandwichError.outOfCleanDishes { // washDishes() } catch SandwichError.missingIngredients(let ingredients) { // 如果匹配missingIngredients的错误被抛出，buyGroceries(_:)函数会被调用，并且使用catch所捕捉到的关联值[ingredients]作为参数。 // buyGroceries(ingredients) } --- warning: Immutable value \u0026#39;ingredients\u0026#39; was never used; consider replacing with \u0026#39;_\u0026#39; or removing it 上述例子中，makeASandwich()（做一个三明治）函数会抛出一个错误消息如果没有干净的盘子或者某个原料缺失。因为makeASandwich()抛出错误，函数调用被包裹在try表达式中。将函数包裹在一个do语句中，任何被抛出的错误会被传播到提供的catch从句中。\n断言和先决条件 断言和先决条件是在运行时所做的检查。可以用它们来检查在执行后续代码之前是否一个必要的条件被满足了。如果断言或者先决条件中的布尔条件评估的结果为true（真），则代码像往常一样继续执行。如果布尔条件评估结果为假（false），程序的当前状态是无效的，则代码执行结束，应用程序中止。\n断言帮助开发者在开发阶段找到错误和不正确的假设，先决条件帮助开发者在生产环境中探测到存在的问题。与错误处理不同，断言和先决条件并不是用来处理可以恢复的或者可预期的错误。因为一个断言失败表明了程序正处于一个无效的状态，没有办法去捕获一个失败的断言。\n注意\n使用断言和先决条件不是一个能够避免出现程序出现无效状态的编码方法。然而，如果一个无效状态程序产生了，断言和先决条件可以强制检查数据和程序状态，使得程序可预测的中止（不是系统强制的，被动的中止），并帮助使这个问题更容易调试。一旦探测到无效的状态，执行则被中止，防止无效的状态导致的进一步对于系统的伤害。\n断言和先决条件的不同点是，它们什么时候进行状态检测：断言仅在调试环境运行，而先决条件则在调试环境和生产环境中运行。在生产环境中，断言的条件将不会进行评估。这个意味着可以使用很多断言在程序的开发阶段，但是这些断言在生产环境中不会产生任何影响。\n使用断言进行调试 可以调用Swift标准库的assert(_:_:file:line:)函数来写一个断言。向这个函数传入一个结果为true或者false的表达式以及一条信息，当表达式的结果为false的时候这条信息会被显示。\nlet age = -3 assert(age \u0026gt;= 0, \u0026#34;A person\u0026#39;s age cannot be less than zero.\u0026#34;) // 因为age \u0026lt; 0，所以断言会被触发 上述代码中，如果age的值是负数，就像代码中那样，age \u0026gt;= 0为false，断言被触发，终止应用。\n如果不需要断言信息，可以就想下述这样忽略掉。\nassert(age \u0026gt;= 0) 如果代码已经检查了条件，可以使用assertionFailure(_:file:line:)函数来表明断言失败了。\nif age \u0026gt; 10 { print(\u0026#34;You can ride the roller-coaster or the ferris wheel.\u0026#34;) } else if age \u0026gt; 0 { print(\u0026#34;You can ride the ferris wheel.\u0026#34;) } else { assertionFailure(\u0026#34;A person\u0026#39;s age can\u0026#39;t be less than zero.\u0026#34;) } 强制执行先决条件 当一个条件可能为假，但是继续执行代码要求条件必须为真的时候，需要使用先决条件。例如使用先决条件来检查是否下标越界，或者来检查是否将一个正确的参数传给函数。\n可以使用全局precondition(_:_:file:line:)函数来写一个先决条件。向这个函数传入一个结果为true或者false的表达式以及一条信息，当表达式的结果为false的时候这条信息会被显示。\nvar index = 0 precondition(index \u0026gt; 0, \u0026#34;Index must be greater than zero.\u0026#34;) // 索引需要从1开始 可以调用preconditionFailure(_:file:line:)方法来表明出现了一个错误，例如，switch进入了default分支，但是所有的有效值应该被任意一个其他分支（非default分支）处理。\n注意\n如果使用unchecked模式编译代码，先决条件将不会进行检查。编译器假设所有的先决条件总是为true（真），它将优化编写的代码。然而fatalError(_:file:line)函数总是中断执行，无论您怎么进行优化设定。\n可以在设计原型和早期开发阶段使用fatalError(_:file:line)函数，此阶段只有方法的声明但是没有具体实现，可以在方法体中写上fatalError(\u0026ldquo;Unimplemented\u0026rdquo;)作为具体实现。因为fatalError不会像断言和先决条件那样被优化掉，可以确保代码执行到一个没有被实现的方法时，程序会中断。\n","date":"2021-08-07T00:00:00Z","permalink":"https://jen-jon.github.io/posts/swiftbase/","tags":"iOS; Swift; Apple","title":"Swift学习(2)-基础部分（代码完善版）","type":"technology"},{"contents":"Swift简介 Swift是美国苹果公司推出的编程语言，专门针对苹果桌面操作系统macOS和苹果移动操作系统iOS、iPadOS以及watchOS和tvOS的应用开发。Swift 在各个方面优于 Objective-C，也不会有那么多复杂的符号和表达式。同时，Swift 更加快速、便利、高效、安全。除此之外，新的 Swift 语言依旧会与 Object-C 相兼容。（更多关于Swift的信息可以访问苹果公司官方网址）\n一般来说，一行Swift代码就是一个完整的程序。\nprint(\u0026#34;Hello, World!\u0026#34;) --- output: Hello, World! 简单值 Swift中常量用let来修饰，常量值只能赋值一次，可以在多个地方使用。\nlet constValue = 20 let constInteger: Int print(constValue) --- output: 20 Swift中变量用var来修饰，与JavaScript的语法很像，变量可以多次赋值。\nvar variableValue = 20 variableValue = 30 print(variableValue) --- output: 30 常量和变量的类型必须和赋给它的值一样，然而并不用明确地声明类型。当通过一个值来声明常量和变量时，编译器会自动推断其类型。如果初始值没有提供足够的信息，或者没有初始值时，需要在变/常量后面声明类型，用冒号分割。\nlet implicitInteger = 70 print(\u0026#34;Implicit Integer:\u0026#34;, implicitInteger) let implicitDouble = 71.0 print(\u0026#34;Implicit Double:\u0026#34;, implicitDouble) let explicitDouble: Double = 72 print(\u0026#34;Explicit Double:\u0026#34;, explicitDouble) --- output: Implicit Integer: 70 Implicit Double: 71.0 Explicit Double: 72.0 小练习：\n创建一个常量，显示指定类型为Float，并指定初始值为4\n参考答案：\nlet explicitFloat: Float = 100 print(\u0026#34;Practice Result:\u0026#34;, explicitFloat) --- output: Practice Result: 100.0 值永远不会被隐式转换为其他类型，如果需要把一个值转换成其他类型，请显式转换。\nlet label = \u0026#34;The width is \u0026#34; let width = 94 let widthLabel = label + String(width) print(\u0026#34;Explicit Conversion Result:\u0026#34;, widthLabel) --- output: Explicit Conversion Result: The width is 94 小练习:\n删除上面倒数第二行中的String，错误提示是什么？\n参考答案：\nBinary operator '+' cannot be applied to operands of type 'String' and 'int'\n有一种更简单的把值转换成字符串的方法：把值写到括号中，并且在括号之前写一个反斜杠\\。\nlet apples = 3 let oranges = 5 let fruitSummary = \u0026#34;I have \\(apples) apples, and \\(oranges) oranges. So I have \\(apples + oranges) pieces of fruits totaly.\u0026#34; print(fruitSummary) --- output: I have 3 apples, and 5 oranges. So I have 8 pieces of fruits totaly. 小练习:\n使用\\()来把一个浮点计算转换成字符串，再加上某人的名字，和他打个招呼\n参考答案：\nlet constScore = 301.92 let nameSocre = \u0026#34;Jensen \\(constScore)\u0026#34; print(\u0026#34;Hello, \u0026#34;, nameSocre) --- output: Hello, Jensen 301.92 使用三个双引号\u0026quot;\u0026quot;\u0026quot;来包含多行字符串内容，每行行首的缩进会被去除，直到和结尾引号的缩进相匹配。\nlet quotation = \u0026#34;\u0026#34;\u0026#34; I said \u0026#34;I have \\(apples) apples, and \\(oranges) oranges\u0026#34; And then I said \u0026#34;I have \\(apples + oranges) pieces of fruits totaly.\u0026#34; \u0026#34;\u0026#34;\u0026#34; print(quotation) --- output: I said \u0026#34;I have 3 apples, and 5 oranges\u0026#34; And then I said \u0026#34;I have 8 pieces of fruits totaly.\u0026#34; 使用方括号[]来创建数组和字典，并使用下标或者键（Key）来访问元素，最后一个元素后面允许有个逗号。\nvar shoppingList = [\u0026#34;catfish\u0026#34;, \u0026#34;water\u0026#34;, \u0026#34;tulips\u0026#34;, \u0026#34;blue paint\u0026#34;, ] print(shoppingList[0]) shoppingList[2] = \u0026#34;Jensen\u0026#34; print(shoppingList) var occupations = [ \u0026#34;Country\u0026#34;: \u0026#34;China\u0026#34;, \u0026#34;City\u0026#34;: \u0026#34;Hefei\u0026#34; ] occupations[\u0026#34;University\u0026#34;] = \u0026#34;HFUT\u0026#34; print(occupations) --- output: catfish [\u0026#34;catfish\u0026#34;, \u0026#34;water\u0026#34;, \u0026#34;Jensen\u0026#34;, \u0026#34;blue paint\u0026#34;] [\u0026#34;University\u0026#34;: \u0026#34;HFUT\u0026#34;, \u0026#34;Country\u0026#34;: \u0026#34;China\u0026#34;, \u0026#34;City\u0026#34;: \u0026#34;Hefei\u0026#34;] 数组在添加元素时会自动变大。\nshoppingList.append(\u0026#34;apples\u0026#34;) print(\u0026#34;数组添加元素后的长度：\u0026#34;, shoppingList.count) --- output: 数组添加元素后的长度： 5 使用初始化语法来创建一个空数组或者空字典。\nlet emptyArray: [String] = [] let emptyDicitionary: [String: Float] = [:] 如果变量的类型信息可以被推断出来，可以用[]和[:]来创建空数组和空字典。\nshoppingList = [] occupations = [:] 控制流 使用if和switch来进行条件操作，使用for-in、while和repeat-while来进行循环，包裹条件和循环变量的括号可以省略。在if语句中，条件必须是一个布尔表达式，这意味着像if score { ... }这样的代码将报错，而不会隐式地与0做对比。\nlet individualScores = [75, 43, 103, 87, 12] var teamScore = 0 for score in individualScores { if score \u0026gt; 50 { teamScore += 3 } else { teamScore += 1 } } print(\u0026#34;The value of teamScore: \u0026#34;, teamScore) --- output: The value of teamScore: 11 可以一起使用if和let一起来处理值缺失的情况。这些值可由可选值来代表。一个可选的值是一个具体的值或者是nil以表示值缺失在类型后面加一个问号?来标记这个变量的值是可选的。\nvar optionalString: String? = \u0026#34;Hello\u0026#34; print(optionalString == nil) optionalString = nil print(optionalString == nil) var optionalName: String? = \u0026#34;Jensen Jon\u0026#34; var greeting = \u0026#34;Hello\u0026#34; if let name = optionalName { greeting = \u0026#34;Hello, \\(name)\u0026#34; print(greeting) } --- output: false true Hello, Jensen Jon 小练习:\n把optionalName改成nil，greeting会是什么？添加一个else语句，当optionalName是nil时，给greeting赋一个不同的值\n参考答案： 如果变量的可选值是nil，条件会判断为false，大括号中的代码会被跳过。如果不是nil，会将值解包并赋给let后面的常量，这样代码块中就可以使用这个值了\n另一种处理可选值的方法是通过使用??操作符来提供一个默认值。如果可选值缺失的话，可以使用默认值来代替。\nlet nickName: String? = nil let fullName: String = \u0026#34;Jensen Jon\u0026#34; let informalGreeting = \u0026#34;Hi \\(nickName ?? fullName)!\u0026#34; print(\u0026#34;informalGreeting: \u0026#34;, informalGreeting) --- output: informalGreeting: Hi Jensen Jon! switch支持任意类型的数据以及各种比较操作\u0026ndash;不仅仅是整数以及测试相等。\nlet vegetable = \u0026#34;red pepper\u0026#34; // Red Pepper 红胡椒 switch vegetable { case \u0026#34;celery\u0026#34;: print(\u0026#34;Add some raisins and make ants on a log.\u0026#34;) // Swift中运行switch中匹配的case语句后，程序会自动退出switch语句，不需要break语句 case \u0026#34;cucumber\u0026#34;, \u0026#34;watercress\u0026#34;: print(\u0026#34;That would make a good tea sandwich.\u0026#34;) case let x where x.hasSuffix(\u0026#34;pepper\u0026#34;): // Warning: let在上述例子中将匹配等时的值赋给常量x print(\u0026#34;Is it a spicy \\(x)?\u0026#34;) default: print(\u0026#34;Everything testes good in soup.\u0026#34;) } --- output: Is it a spicy red pepper? 小练习:\n删除default语句，看看会有什么错误？\n参考答案： Switch must be exhaustive\n可以使用for-in来遍历字典，需要一对变量来表示每个键值对，字典是一个无序集合，所以它们的键和值以任意顺序迭代结束。\nlet interestingNumbers = [ \u0026#34;Prime\u0026#34;: [2, 3, 5, 7, 11, 13], \u0026#34;Fibonacci\u0026#34;: [1, 1, 2, 3, 5, 8], \u0026#34;Square\u0026#34;: [1, 4, 9, 16, 25] ] var largest = 0 for (_, numbers) in interestingNumbers { for number in numbers { if number \u0026gt; largest { largest = number } } } print(\u0026#34;interestingNumbers字典中的最大值是：\u0026#34;, largest) --- output: interestingNumbers字典中的最大值是： 25 小练习:\n将_替换成变量名，以确定哪种类型的值是最大的\n参考答案：\nvar largCls = \u0026#34;\u0026#34;; largest = 0 for (varClass, numbers) in interestingNumbers { for number in numbers { if number \u0026gt; largest { largest = number largCls = varClass } } } print(\u0026#34;字典中最大值的类型是：\u0026#34;, largCls) --- output: 字典中最大值的类型是： Square 使用while来重复运行一段代码直到条件改变。循环条件也可以在结尾，保证至少能循环一次。\nvar n = 2 while n \u0026lt; 100 { n *= 2 } print(\u0026#34;n: \u0026#34;, n) var m = 2 repeat { m *= 2 } while m \u0026lt; 100 print(\u0026#34;m: \u0026#34;, m) --- output: n: 128 m: 128 你可以在循环中使用..\u0026lt;来表示下标范围。\nvar total = 0 for i in 0..\u0026lt;5 { print(i) total += i } print(\u0026#34;Total(..\u0026lt;): \u0026#34;, total) --- output: 0 1 2 3 4 Total(..\u0026lt;): 10 使用..\u0026lt;创建的范围不包含上届，如果想包含的话需要使用...。\ntotal = 0 for i in 0...5 { print(i) total += i } print(\u0026#34;Total(...): \u0026#34;, total) --- output: 0 1 2 3 4 5 Total(...): 15 函数和闭包 使用func来声明一个函数，使用名字和参数来调用参数。使用-\u0026gt;来指定函数返回值的类型。\nfunc greet(person: String, day: String) -\u0026gt; String { return \u0026#34;Hello \\(person), today is \\(day).\u0026#34; } print(greet(person: \u0026#34;Jensen\u0026#34;, day: \u0026#34;Thursday\u0026#34;)) --- output: Hello Jensen, today is Thursday. 小练习:\n删除day参数，在这个欢迎语中添加一个参数来表示今天的特价菜\n参考答案：\nfunc greet(person: String, delicacy: String) -\u0026gt; String { return \u0026#34;Hello \\(person), our special delicacy is \\(delicacy) today!\u0026#34; } print(greet(person: \u0026#34;Jensen\u0026#34;, delicacy: \u0026#34;beef\u0026#34;)) --- output: Hello Jensen, our special delicacy is beef today! 默认情况下，函数使用它们的参数名称作为它们参数的标签，在参数名称前可以自定义参数标签，或者使用_表示不使用参数标签。\nfunc greet(_ person: String, on day: String) -\u0026gt; String { return \u0026#34;Hello \\(person), today is \\(day).\u0026#34; } print(greet(\u0026#34;Jensen\u0026#34;, on: \u0026#34;Thursday\u0026#34;)) --- output: Hello Jensen, today is Thursday. 使用元组来生成复合值，比如让一个函数返回多个值，该元组的元素可以用名称或数字来获取。\nfunc calculateStatistics(scores: [Int]) -\u0026gt; (min: Int, max: Int, sum: Int) { var min = scores[0] var max = scores[0] var sum = 0 for score in scores { if score \u0026gt; max { max = score } else if score \u0026lt; min { min = score } sum += score } return (min, max, sum) } let statistics = calculateStatistics(scores: [5, 3, 100, -9, 0]) print(\u0026#34;Max value is \u0026#34;, statistics.max, \u0026#34;\\nMin value is \u0026#34;, statistics.min, \u0026#34;\\nSum value is \u0026#34;, statistics.sum) print(statistics.2) --- output: Max value is 100 Min value is -9 Sum value is 99 99 函数可以嵌套，被嵌套的函数可以访问外侧函数的变量。可以使用嵌套函数来重构一个太长或者太复杂的函数。\nfunc returnFifteen() -\u0026gt; Int { var y = 10 func add() { y += 5 } add() return y } print(\u0026#34;经过嵌套函数处理后的y值是：\u0026#34;, returnFifteen()) --- output: 经过嵌套函数处理后的y值是： 15 函数是第一等类型，这意味着函数可以作为另一个函数的返回值。\nfunc makeIncrementer() -\u0026gt; ((Int) -\u0026gt; Int) { func addOne(number: Int) -\u0026gt; Int { return 1 + number } return addOne } var increment = makeIncrementer() print(\u0026#34;Increment is \u0026#34;, increment(7)) --- output: Increment is 8 函数也可以作为一个参数传入另一个函数。\nfunc hasAnyMatches(list: [Int], condition: (Int) -\u0026gt; Bool) -\u0026gt; Bool { for item in list { if condition(item) { // if条件语句的条件必须是一个布尔表达式 return true } } return false } func lessThanTen(number: Int) -\u0026gt; Bool { return number \u0026lt; 10 } var numbers = [10, 20, 9, 2, 11] print(hasAnyMatches(list: numbers, condition: lessThanTen)) --- output: true 函数实际上是一种特殊的闭包：它是一段能之后被调取的代码。闭包中的代码能访问闭包作用域中的变量和函数，即使闭包是在一个不同的作用域被执行的，正如上面的嵌套函数。可以使用{}来创建一个匿名闭包，使用in将参数和返回值类型的声明与闭包函数体进行分离。\nvar result = numbers.map({ (number: Int) -\u0026gt; Int in let result = 3 * number return result }) print(\u0026#34;闭包值：\u0026#34;, result) --- output: 闭包值： [30, 60, 27, 6, 33] 小练习:\n重写闭包，对所有奇数返回0\n参考答案：\nresult = numbers.map({ (number: Int) -\u0026gt; Int in if number % 2 != 0 { return 0 } return number }) print(\u0026#34;闭包值：\u0026#34;, result) --- output: 闭包值： [10, 20, 0, 2, 0] 如果一个闭包的类型已知，比如作为一个代理的回调，你可以忽略参数，返回值，甚至两个都忽略。单个语句闭包会把它语句的值作为结果返回。\nlet mappedNumbers = numbers.map({number in 3 * number}) print(\u0026#34;简洁闭包：\u0026#34;, mappedNumbers) --- output: 简洁闭包： [30, 60, 27, 6, 33] 可以通过参数位置而不是参数名字来引用参数，这个方法在非常短的闭包中非常有用，当一个闭包作为最后一个参数来传递给一个函数的时候，可以直接跟在圆括号的后面。当一个闭包是传给函数的唯一参数时，可以完全忽略圆括号。\nlet sortedNumbers = numbers.sorted {$0 \u0026gt; $1} print(\u0026#34;简洁闭包（无圆括号）：\u0026#34;, sortedNumbers) --- output: 简洁闭包（无圆括号）： [20, 11, 10, 9, 2] 类和对象 使用class和类名来创建一个类。类中属性的声明和变量、常量的声明一样，不同的是类中常/变量的上下文是类。同样的，方法和函数声明也一样。\nclass Shape { var numberOfSides = 0 func simpleDescription() -\u0026gt; String { return \u0026#34;A shape with \\(numberOfSides) sides.\u0026#34; } } print(Shape().simpleDescription()) --- output: A shape with 0 sides. 小练习:\n使用let添加一个常量属性，再添加一个接收一个参数的方法\n参考答案：\nclass Shapes { let constVal = 10 var numberOfSize = 20 func setter(_ number: Int) { numberOfSize = number } func shwoInfo() -\u0026gt; String { return \u0026#34;Class Shape has a const value constVal and a variable value numberOfSize, the value of constVal is \\(constVal), the value of numberOfSize is \\(numberOfSize).\u0026#34; } } var shapes = Shapes() shapes.setter(100) print(shapes.shwoInfo()) --- output: Class Shape has a const value constVal and a variable value numberOfSize, the value of constVal is 10, the value of numberOfSize is 100. 要创建一个类的实例，在类名后面加上括号。使用点语法来访问实例的属性和方法。\nvar shape = Shape() shape.numberOfSides = 7 print(\u0026#34;shape对象已创建：\u0026#34;, shape.simpleDescription()) --- output: shape对象已创建： A shape with 7 sides. 述的Shape/Shapes类还缺少了一个非常重要的东西：一个构造函数来初始化实例。可以使用init来创建一个构造器。\nclass NamedShape { var numberOfSides: Int = 0 var name: String init(name: String) { self.name = name } func simpleDescription() -\u0026gt; String { return \u0026#34;A shape with \\(numberOfSides) sides.\u0026#34; } } 注意，类似于Python，在上述例子中self被用来区别实例变量name和构造器参数name。当需要创建实例的时候，就需要像传入函数参数一样给类的构造器传入参数。创建实例时，类的每个属性都需要赋值，无论是通过声明还是通过构造器。\n如果需要在对象释放前进行一些清理工作，需要使用deinit创建一个析构函数。\n子类的定义方法是在它们的类名后面加上父类的名字，并用冒号分割。创建类时，并不需要一个标准的根类（Root），所以可以根据需要添加或者忽略父类。子类如果需要重写父类的方法的话，就需要使用override关键字来标记，如果没有添加override就重写的话，编译器会报错。\nclass Square: NamedShape { var sideLength: Double init(sideLength: Double, name: String) { self.sideLength = sideLength super.init(name: name) numberOfSides = 4 } func area() -\u0026gt; Double { return sideLength * sideLength } override func simpleDescription() -\u0026gt; String { // 重写父类方法，并调用父类属性 return \u0026#34;A square with sides of length \\(sideLength). Producted by \\(name).\u0026#34; } } let test = Square(sideLength: 5.2, name: \u0026#34;Jensen\u0026#34;) print(\u0026#34;Square: Area\u0026#34;, test.area()) print(test.simpleDescription(), test.numberOfSides) --- output: Square: Area 27.040000000000003 A square with sides of length 5.2. Producted by Jensen. 4 小练习:\n创建NamedShape的另一个字类Circle，构造器接收两个参数，一个是半径，另一个时名称，在子类中实现area()和simpleDescription()方法\n参考答案：\nclass Circle: NamedShape { var radius: Double init(radius: Double, name: String) { self.radius = radius super.init(name: name) numberOfSides = 1 } func area() -\u0026gt; Double { return radius * radius * Double.pi } override func simpleDescription() -\u0026gt; String { return \u0026#34;A circle has \\(numberOfSides) side and with radius of \\(radius), its area is \\(area()). Producted by \\(name).\u0026#34; } } let circle = Circle(radius: 5.2, name: \u0026#34;Jensen\u0026#34;) print(circle.simpleDescription()) --- output: A circle has 1 side and with radius of 5.2, its area is 84.94866535306801. Producted by Jensen. 除了简单的存储属性，还有使用getter和setter的计算属性。\nclass EquilateralTriangle: NamedShape { var sideLength: Double init(sideLength: Double, name: String) { self.sideLength = sideLength super.init(name: name) numberOfSides = 3 } var perimeter: Double { get { return 3.0 * sideLength } set { sideLength = newValue / 3.0 } } override func simpleDescription() -\u0026gt; String { return \u0026#34;An equilateral triangle with sides of length \\(sideLength).\u0026#34; } } var triangle = EquilateralTriangle(sideLength: 3.1, name: \u0026#34;Jensen\u0026#34;) print(triangle.simpleDescription()) triangle.perimeter = 9.9 print(\u0026#34;Setter后的新值：\u0026#34;, triangle.sideLength) --- output: An equilateral triangle with sides of length 3.1. Setter后的新值： 3.3000000000000003 在perimeter的setter中，新值的名字时newValue，可以在set之后的圆括号中显式地设置一个名字。注意，EquilateralTriangle类的构造器执行了三个步骤：\n设置子类声明的属性值\n调用父类的构造器\n改变父类定义的属性值，其他的工作比如调用方法、getters 和 setters 也可以在这个阶段完成。\n如果不需要计算属性，但是仍然需要在设置一个新值之前或者之后运行代码，使用willSet和didSet。写入的代码会在属性值发生改变时调用，但不包含init中发生值改变的情况。\nclass TriangleAndSquare { var triangle: EquilateralTriangle { willSet { square.sideLength = newValue.sideLength } } var square: Square { willSet { triangle.sideLength = newValue.sideLength } } init(size: Double, name: String) { square = Square(sideLength: size, name: name) triangle = EquilateralTriangle(sideLength: size, name: name) } } var triangleAndSquare = TriangleAndSquare(size: 10, name: \u0026#34;Jensen\u0026#34;) print(\u0026#34;第一次调用 \u0026gt; Square.sideLength：\u0026#34;, triangleAndSquare.square.sideLength) print(\u0026#34;第一次调用 \u0026gt; EquilaterTriangle.sideLength：\u0026#34;, triangleAndSquare.triangle.sideLength) triangleAndSquare.square = Square(sideLength: 30, name: \u0026#34;Jensen\u0026#34;) print(\u0026#34;第二次调用 \u0026gt; EquilaterTriangle.sideLength：\u0026#34;, triangleAndSquare.triangle.sideLength) --- output: 第一次调用 \u0026gt; Square.sideLength： 10.0 第一次调用 \u0026gt; EquilaterTriangle.sideLength： 10.0 第二次调用 \u0026gt; EquilaterTriangle.sideLength： 30.0 处理变量的可选值时，可以在操作（比如方法、属性和子脚本）之前加上?，如果?之前的值是nil，?后面的东西都会被忽略，并且整个表达式返回nil。否则可选值会被解包，之后的所有代码都会按照解包后的值运行。在这两种情况下，整个表达式的值也是一个可选值。\nvar optionalSquare: Square? = Square(sideLength: 2.5, name: \u0026#34;Jensen\u0026#34;) var sideLength = optionalSquare?.sideLength print(\u0026#34;有可选值：\u0026#34;, sideLength) optionalSquare = nil sideLength = optionalSquare?.sideLength print(\u0026#34;无可选值：\u0026#34;, sideLength) --- output: 有可选值： Optional(2.5) 无可选值： nil --- warning: Expression implicitly coerced from \u0026#39;Double?\u0026#39; to \u0026#39;Any\u0026#39; 枚举和结构体 使用enum来创建一个枚举，就像类和其他所有命名类型一样，枚举可以包含方法。\nenum RankTest: Double { case ace case two, three, four, five, six, seven } print(\u0026#34;枚举测试：\u0026#34;, RankTest.two.rawValue) enum Rank: Int { case ace = 1 case two, three, four, five, six, seven, eight, nine, ten case jack, queen, king func simpleDescription() -\u0026gt; String { switch self { case .ace: return \u0026#34;ace\u0026#34; case .jack: return \u0026#34;jack\u0026#34; case .queen: return \u0026#34;queen\u0026#34; case .king: return \u0026#34;king\u0026#34; default: return String(self.rawValue) } } } let ace = Rank.ace let aceRawValue = ace.rawValue print(\u0026#34;ace: \u0026#34;, aceRawValue) print(\u0026#34;Rank.xx.simpleDescription(): \u0026#34;, Rank.king.simpleDescription()) --- output: 枚举测试： 1.0 ace: 1 Rank.xx.simpleDescription(): king 小练习:\n写一个函数，通过比较它们的原始值来比较两个Rank值\n参考答案：\nenum Rank1: Int { case ace = 10 case two, three } enum Rank2: Int { case ace = 7 case next } func compareRanks(rankVal1: Int, rankVal2: Int) -\u0026gt; String { if rankVal1 \u0026lt; rankVal2 { return \u0026#34;Rank1\u0026#34; } else if rankVal2 \u0026lt; rankVal1 { return \u0026#34;Rank2\u0026#34; } else { return \u0026#34;Null\u0026#34; } } print(\u0026#34;具有较大的原始值的Rank是：\u0026#34;, compareRanks(rankVal1: Rank1.ace.rawValue, rankVal2: Rank2.ace.rawValue)) --- output: 具有较大的原始值的Rank是： Rank2 默认情况下，Swift按照从0开始每次加1的方式为原始值进行赋值，原始值可以通过显式赋值来修改。当然了，也可以选择使用字符串或者浮点数作为枚举的原始值，使用rawValue属性来访问一个枚举成员的原始值。\n使用init?(rawValue:)初始化构造器从原始值创近啊一个枚举实例。如果存在于原始值相应的枚举成员就返回该枚举成员，否则就返回nil。\nif let convertedRank = Rank(rawValue: 11) { let elevenDescription = convertedRank.simpleDescription() print(elevenDescription) } --- output: jack 枚举的关联值是实际值，并不是原始值的另一种表达方式。实际上，如果没有比较有意义的原始值，就不要提供原始值。\nenum Suit { case spaeds, hearts, diamonds, clubs func simpleDescription() -\u0026gt; String { switch self { case .spaeds: return \u0026#34;speedsDescription\u0026#34; case .hearts: return \u0026#34;heartsDescription\u0026#34; case .diamonds: return \u0026#34;diamondsDescription\u0026#34; case .clubs: return \u0026#34;clubsDescription\u0026#34; } } } let hearts = Suit.hearts print(\u0026#34;Suit.hearts: \u0026#34;, hearts) let heartsDescription = hearts.simpleDescription() print(\u0026#34;heartsDescription: \u0026#34;, heartsDescription) --- output: Suit.hearts: hearts heartsDescription: heartsDescription 小练习:\n给Suit添加一个color()方法，对spades和clubs返回“blcak”，对hearts和diamonds返回“red”\n参考答案：\nenum SuitTest { case spaeds, hearts, diamonds, clubs func simpleDescription() -\u0026gt; String { switch self { case .spaeds: return \u0026#34;speedsDescription\u0026#34; case .hearts: return \u0026#34;heartsDescription\u0026#34; case .diamonds: return \u0026#34;diamondsDescription\u0026#34; case .clubs: return \u0026#34;clubsDescription\u0026#34; } } func color() -\u0026gt; String { switch self { case .spaeds: return \u0026#34;black\u0026#34; case .clubs: return \u0026#34;black\u0026#34; case .hearts: return \u0026#34;red\u0026#34; case .diamonds: return \u0026#34;red\u0026#34; } } } let clubs = SuitTest.clubs print(\u0026#34;Suits.clubs: \u0026#34;, clubs) let clubsColor = clubs.color() print(\u0026#34;clubsColor: \u0026#34;, clubsColor) --- output: Suits.clubs: clubs clubsColor: black 注意在上面的例子中使用了两种方式引用hearts枚举成员：\n给clubs常量赋值时，枚举成员Suits.clubs需要使用全名来引用，因为常量没有显示指定类型\n在switch里，枚举成员使用缩写.clubs来引用，因为self的值已经是一个Suits类型\n在任何已知变量类型的情况下都可以使用缩写。\n如果枚举成员的实例有原始值，那么这些值是在声明时候就已经决定了，这意味着不同枚举实例的枚举成员总会有一个相同的原始值。当然我们也可以为枚举成员设定关联值，关联值是在创建实例时决定的。这意味着同一枚举成员不同实例的关联值可以不同。\nenum ServerResponse { case result(String, String) case failure(String) } var response = ServerResponse.result(\u0026#34;6:00 am\u0026#34;, \u0026#34;8:09 pm\u0026#34;) response = ServerResponse.failure(\u0026#34;Out of memory.\u0026#34;) switch response { case let .result(sunrise, sunset): print(\u0026#34;Sunrise is at \\(sunrise) and sunset is at \\(sunset).\u0026#34;) case let .failure(message): print(\u0026#34;Failure... \\(message)\u0026#34;) } --- output: Failure... Out of memory. 小练习:\n给ServerReponse和switch添加第三种情况\n参考答案：\nenum ServerResponses { case result(String, String) case rain(String) case failure(String) } var responses = ServerResponses.result(\u0026#34;6:00 am\u0026#34;, \u0026#34;8:09 pm\u0026#34;) responses = ServerResponses.failure(\u0026#34;Out of memory.\u0026#34;) responses = ServerResponses.rain(\u0026#34;Today is rain.\u0026#34;) switch responses { case let .result(sunrise, sunset): // 注意ServerResponses的值在于switch的分支匹配时，日升和日落时间是如何从该值中提取出来的 print(\u0026#34;Sunrise is at \\(sunrise) and sunset is at \\(sunset).\u0026#34;) case let .rain(message): print(\u0026#34;Sorry! \\(message)\u0026#34;) case let .failure(message): print(\u0026#34;Failure... \\(message)\u0026#34;) } --- output: Sorry! Today is rain. 使用struct来创建一个结构体。结构体和类有很多相同的地方，包括方法和构造器。结构体与类最大的一个区别就是结构体是值传递，类是引用传递。\nstruct Card { var rank: Rank var suit: Suit func simpleDescription() -\u0026gt; String { return \u0026#34;The \\(rank.simpleDescription()) of \\(suit.simpleDescription()).\u0026#34; } } let threeOfSpades = Card(rank: .three, suit: .spaeds) let threeOfSpadesDescription = threeOfSpades.simpleDescription() print(\u0026#34;结构体传引用：\u0026#34;, threeOfSpadesDescription) --- output: 结构体传引用： The 3 of speedsDescription. 小练习:\n写一个方法，创建一副完整的扑克牌，这些牌是所有rank和suit的组合\n参考答案：\nenum Ranks: CaseIterable { case ace case two, three, four, five, six, seven, eight, nine, ten case jack, queen, king } enum Suits: CaseIterable { case spades, clubs, hearts, diamonds } struct Cards { var rank: Ranks var suit: Suits } func allCards() { for suit in Suits.allCases { for rank in Ranks.allCases { Cards(rank: rank, suit: suit) } } } 协议与拓展 使用protocol来声明一个协议。\nprotocol ExampleProtocol { var simpleDescription: String { get } mutating func adjust() } 类、枚举和结构体都可以遵循协议，有点类似Java中的接口（Interface）。\nclass SimpleClass: ExampleProtocol { // 类遵循协议 var simpleDescription: String = \u0026#34;A very simple class.\u0026#34; var anotherProperty: Int = 69105 func adjust() { simpleDescription += \u0026#34; Now 100% adjusted.\u0026#34; } } var a = SimpleClass() a.adjust() print(\u0026#34;Adjusted Class\u0026#39;s Description: \u0026#34;, a.simpleDescription) struct SimpleStructure: ExampleProtocol { var simpleDescription: String = \u0026#34;A simple structure.\u0026#34; mutating func adjust() { // 实现协议中的mutating方法时，若是类类型，则不用写mutating关键字，对于结构体和枚举（即值类型），则必须写mutating关键字 simpleDescription += \u0026#34; (adjusted)\u0026#34; } } var b = SimpleStructure() b.adjust() print(\u0026#34;Adjusted Struct\u0026#39;s Description: \u0026#34;, b.simpleDescription) --- output: Adjusted Class\u0026#39;s Description: A very simple class. Now 100% adjusted. Adjusted Struct\u0026#39;s Description: A simple structure. (adjusted) 小练习:\n给ExampleProtocol再增加一个要求。需要怎么改SimpleClass和SimpleStructure才能保证它们仍旧遵循这个协议？\n参考答案： 在SimpleClass和SimpleStructure增加一个方法实现该要求\n注意声明SimpleStructure时候，mutating关键字用来标记一个会修改结构体的方法。SimpleClass的声明不需要标记任何方法，因为类中的方法通常是可以修改类的属性（类的性质）。\n使用extension来为现有的类型添加功能，比如新的方法和计算属性。可以使用扩展让某个在别处声明的类型类遵守某个协议，这同样适用于从外部库或者框架引入的类型。\nextension Int: ExampleProtocol { var simpleDescription: String { return \u0026#34;The number \\(self)\u0026#34; } mutating func adjust() { self += 0 } } print(\u0026#34;Extension \u0026gt; Int: \u0026#34;, 7.simpleDescription) --- output: Extension \u0026gt; Int: The number 7 小练习:\n给Double类型写一个扩展，添加roundValue方法\n参考答案：\nprotocol DoubleProtocol { func roundValue() -\u0026gt; Int } extension Double: DoubleProtocol { func roundValue() -\u0026gt; Int { return Int((self).rounded()) } } print(\u0026#34;Extension \u0026gt; Double: \u0026#34;, (3.14).roundValue()) --- output: Extension \u0026gt; Double: 3 可以像使用其他命名类型一样使用协议名。例如，创建一个具有不同类型但是都实现一个协议的对象合集。当处理类型是协议的值时，协议外定义的方法不可用。\nlet protocolValue: ExampleProtocol = a print(protocolValue.simpleDescription) // print(protocolValue.anotherProperty) // 如果取消前面的注释，这句程序便会报错 --- output: A very simple class. Now 100% adjusted. 即使protocolValue变量运行时的类型时simpleClass，编译器还是会把它的类型当作ExampleProtocol，此时表示不能调用在协议之外的方法或者属性。\n错误处理 使用采用Error协议的类型来表示错误。\nenum PrinterError: Error { case outofPaper case noToner case onFire } 使用throw来抛出一个错误和使用throws来表示一个可以抛出错误的函数。如果在函数中抛出一个错误，这个函数会立刻返回并且调用该函数代码会进行错误处理。\nfunc send(job: Int, toPrinter printerName: String) throws -\u0026gt; String { if printerName == \u0026#34;Never has Toner\u0026#34; { throw PrinterError.noToner } return \u0026#34;\\(printerName), Job sent.\u0026#34; } print(\u0026#34;ErrorDemo: \u0026#34;, try send(job: 10, toPrinter: \u0026#34;Okay\u0026#34;)) --- output: ErrorDemo: Okay, Job sent. 有多种方式可以用来进行错误处理。一种方式时使用do-catch。在do代码块中，使用try来标记可以抛出错误的代码。在catch代码块中，除非另外命名，否则错误会自动命名为error。\ndo { let printerResponse = try send(job: 1040, toPrinter: \u0026#34;Jensen\u0026#34;) print(printerResponse) } catch { print(error) } --- output: Jensen, Job sent. 小练习:\n将printerName改成“Never has Toner”使得send(job:toPrinter:)函数抛出错误\n参考答案：\ndo { let printerResponse = try send(job: 0, toPrinter: \u0026#34;Never has Toner\u0026#34;) print(printerResponse) } catch { print(error) } --- output: noToner 可以使用多个catch块来处理特定的错误，参照switch中的case风格来写catch。\ndo { let printerResponse = try send(job: 0, toPrinter: \u0026#34;Never has Toner\u0026#34;) print(printerResponse) } catch PrinterError.onFire { print(\u0026#34;I\u0026#39;ll just put this over here, with the rest of the fire.\u0026#34;) } catch let printerError as PrinterError { print(\u0026#34;Printer error: \\(printerError)\u0026#34;) } catch { print(error) } --- output: Printer error: noToner 小练习:\n在do代码块中添加抛出错误的代码，需要抛出哪种错误来使第一个catch块进行接收？怎么使第二个和第三个catch进行接收呢\n参考答案： 要使第一个catch块接收，需要抛出onFire错误；抛出PrinterError中除onFire之外其他错误即可被第二个catch块接收；抛出非PrinterError的错误即可被第三个catch块接收\n另一种处理错误的方式时使用try?将结果转换为可选的。如果函数抛出错误，该错误会被抛弃切结果为nil。否则，结果会是一个包含函数返回值的可选值。\nlet printerSuccess = try? send(job: 1884, toPrinter: \u0026#34;Jensen is handsome\u0026#34;) let printerFailure = try? send(job: 1885, toPrinter: \u0026#34;Never has Toner\u0026#34;) print(\u0026#34;printerSuccess: \\(printerSuccess)\\nprinterFailure: \\(printerFailure)\u0026#34;) --- output: printerSuccess: Optional(\u0026#34;Jensen is handsome, Job sent.\u0026#34;) printerFailure: nil --- warning: String interpolation produces a debug description for an optional value; did you mean to make this explicit? 使用defer代码块来表示在函数返回前，函数中最后执行的代码。无论函数是否会抛出错误，这段代码都将执行。使用defer，可以把函数调用之初就要执行的代码和函数调用结束时的扫尾代码写在一起，虽然这两者的执行时机截然不同。\nvar fridgeIsOpen = false let fridgeContent = [\u0026#34;milk\u0026#34;, \u0026#34;eggs\u0026#34;, \u0026#34;leftovers\u0026#34;] func fridgeContains(_ food: String) -\u0026gt; Bool { fridgeIsOpen = true defer { fridgeIsOpen = false } let result = fridgeContent.contains(food) return result } print(\u0026#34;Do this fridge contains banana? \u0026#34;, fridgeContains(\u0026#34;banana\u0026#34;)) print(\u0026#34;FridgeIsOpen: \u0026#34;, fridgeIsOpen) --- output: Do this fridge contains banana? false FridgeIsOpen: false 泛型 在尖括号里写一个名字来创建一个泛型函数或者类型。\nfunc makeArray\u0026lt;Item\u0026gt;(repeating item: Item, numberOfTimes: Int) -\u0026gt; [Item] { var result: [Item] = [] for _ in 0..\u0026lt;numberOfTimes { result.append(item) } return result } let repeatNum: [String] = makeArray(repeating: \u0026#34;Test\u0026#34;, numberOfTimes: 5) print(repeatNum) --- output: [\u0026#34;Test\u0026#34;, \u0026#34;Test\u0026#34;, \u0026#34;Test\u0026#34;, \u0026#34;Test\u0026#34;, \u0026#34;Test\u0026#34;] 也可以创建泛型函数、方法、类、枚举和结构体\n// （重新实现Swift标准库中的可选类型） enum OptionalValue\u0026lt;Wrapped\u0026gt; { case none case some(Wrapped) } var possibleInteger: OptionalValue\u0026lt;Int\u0026gt; = .none possibleInteger = .some(100) print(possibleInteger) --- output: some(100) 在类型名后面使用where来指定对类型的一系列需求，比如，限定类型实现某一个协议，限定两个类型是相同的，或者限定某个类必须有一个特定的父类。\nfunc anyCommonElements\u0026lt;T: Sequence, U: Sequence\u0026gt;(_ lhs: T, _ rhs: U) -\u0026gt; Bool where T.Element: Equatable, T.Element == U.Element // 遵循Equatable协议可以包含对 == 和 != 的实现 { for lhsItem in lhs { for rhsItem in rhs { if lhsItem == rhsItem { return true } } } return false } print(\u0026#34;WHERE Test: \u0026#34;, anyCommonElements([1, 2 ,3], [3])) --- output: WHERE Test: true 小练习:\n修改anyCommonElements(_ :_ :)函数来创建一个函数，返回一个数组，内容是两个序列的共有元素\n参考答案：\nfunc anyCommonElementsInArray\u0026lt;T: Sequence, U: Sequence\u0026gt;(_ lhs: T, _ rhs: U) -\u0026gt; [T.Element] where T.Element: Equatable, T.Element == U.Element { var outArray: [T.Element] = [] for lhsItem in lhs { for rhsItem in rhs { if lhsItem == rhsItem { outArray.append(lhsItem) } } } return outArray } print(\u0026#34;CommonArray: \u0026#34;, anyCommonElementsInArray([0, 1, 2, 3, 4], [0, 3, 4, 5, 6])) --- output: CommonArray: [0, 3, 4] \u0026lt;T: Equatable\u0026gt;和\u0026lt;T\u0026gt; ... where T: Equatable的写法是等价的。\n本帖只是对Swift语言做一个概括性的介绍，后续将给大家继续分享Swift语言的详细教程。\n","date":"2021-08-04T00:00:00Z","permalink":"https://jen-jon.github.io/posts/swiftfirst/","tags":"iOS; Swift; Apple","title":"Swift学习(1)-初•见（代码完善版）","type":"technology"},{"contents":"0. 测试0 这里是测试0，文章暂未上传！这里是测试0，文章暂未上传！这里是测试0，文章暂未上传！这里是测试0，文章暂未上传！\n1. 测试1 这里是测试1，文章暂未上传！这里是测试1，文章暂未上传！这里是测试1，文章暂未上传！这里是测试1，文章暂未上传！这里是测试1，文章暂未上传！\n2. 测试2 这里是测试2，文章暂未上传！这里是测试2，文章暂未上传！这里是测试2，文章暂未上传！这里是测试2，文章暂未上传！这里是测试2，文章暂未上传！这里是测试2，文章暂未上传！\n","date":"2021-06-29T00:00:00Z","permalink":"https://jen-jon.github.io/posts/20210629/","tags":"Docker; Proxy; Linux","title":"在Docker中配置代理实现“科学”开发","type":"technology"},{"contents":"音频（仅作测试使用，侵权删除） 关键词.mp3-林俊杰\n您的浏览器不支持 audio 元素。 关键词.mp3-蒋笛含\n您的浏览器不支持 audio 元素。 视频（仅作测试使用，侵权删除） 渣男Ma Junxiang.mp4-许磊\n司藤的150个镜头 | 景甜回眸大赏.mp4-Jensen\n","date":"2021-06-18T00:00:00Z","permalink":"https://jen-jon.github.io/mediatest/","tags":null,"title":"多媒体测试（视频、音频）","type":null},{"contents":"临近毕业，寝室里还放有一些图书，计划免费送给有缘人。现将这些图书列成书单，共分成六大类，感兴趣的朋友请自行查找是否有需要的图书。如果有您想要的图书，可以通过微信、QQ或者邮件（jensen.acm@gmail.com）与我联系。安徽农业大学的学生可以上门自取（校内学生宿舍10栋309室），外地同学需到付快递。本书单北京时间每天下午4点更新，有删除线标记的即意味着该书已被送出。\n本书单中的书籍全部免费赠予有需要的同学，希望大家不要将书籍倒卖牟利！\n外语类 全新版大学英语综合教程2-学生用书-第二版 [ISBN]:9787544637176 [出版社]:上海外语教育出版社 全新版大学英语综合教程4-学生用书-第二版 [ISBN]:9787544637152 [出版社]:上海外语教育出版社 新探索大学英语快速阅读教程-四六级新题型版-第一册 [ISBN]:9787100140102 [出版社]:上海外语音像出版社 新探索大学英语快速阅读教程-四六级新题型版-第二册 [ISBN]:9787100140096 [出版社]:上海外语音像出版社 新探索大学英语快速阅读教程-四六级新题型版-第三册 [ISBN]:9787100140089 [出版社]:上海外语音像出版社 新探索大学英语快速阅读教程-四六级新题型版-第四册 [ISBN]:9787100140072 [出版社]:复旦大学出版社 21世纪大学英语应用型视听说教程1-第三版 [ISBN]:9787309121933 [出版社]:复旦大学出版社 21世纪大学英语应用型视听说教程2-第三版(2本) [ISBN]:9787309121995 [出版社]:复旦大学出版社 21世纪大学英语应用型视听说教程3-第三版 [ISBN]:9787309122015 [出版社]:复旦大学出版社 四级词汇词根+联想记忆法 [ISBN]:9787560530444 [出版社]:西安交通大学出版社 六级词汇词根+联想记忆法 [ISBN]:9787560530451 [出版社]:西安交通大学出版社 牛津袖珍英汉双解词典-第十版 [ISBN]:9787560082561 [出版社]:外语教学与研究出版社 Cambridge English IELTS 5 [ISBN]:9780521698894 [出版社]:CAMBRIDGE UNIVERSITY PRESS Cambridge English IELTS 6 [ISBN]:9780521719063 [出版社]:CAMBRIDGE UNIVERSITY PRESS Cambridge English IELTS 7 [ISBN]:9780521146944 [出版社]:CAMBRIDGE UNIVERSITY PRESS 文学类 当呼吸化为空气 [ISBN]:9787533946562 [出版社]:浙江文艺出版社 大学语文新编 [ISBN]:9787109173217 [出版社]:中国农业出版社 偷影子的人 [ISBN]:9787540455958 [出版社]:湖南文艺出版社 向着光亮那方 [ISBN]:9787508659442 [出版社]:中信集团出版社 线 [ISBN]:9787544271011 [出版社]:南海出版社 雨季不再来 [ISBN]:9787530211106 [出版社]:北京十月文艺出版社 左手海子 右手顾城 [ISBN]:9787503971587 [出版社]:文化艺术出版社 看不见的爱 [ISBN]:9787559600059 [出版社]:北京联合出版公司 极简未来史 [ISBN]:9787505740129 [出版社]:中国友谊出版公司 习近平的七年知青岁月 [ISBN]:9787503561634 [出版社]:中共中央党校出版社 信息技术类 C Primer Plus-中文版-第六版 [ISBN]:9787115390592 [出版社]:人民邮电出版社 Python数据分析基础教程-NumPy学习指南-第二版 [ISBN]:9787115339409 [出版社]:人民邮电出版社 大话数据结构 [ISBN]:9787302255659 [出版社]:清华大学出版社 数据库系统简明教程 [ISBN]:9787040154733 [出版社]:高等教育出版社 计算机组成原理-第二版 [ISBN]:9787040223903 [出版社]:高等教育出版社 新编16/32位微型计算机原理及应用-第五版 [ISBN]:9787302326984 [出版社]:清华大学出版社 C语言程序设计教程 [ISBN]:9787109173330 [出版社]:中国农业出版社 C语言程序设计教程实验指导(2本) [ISBN]:9787109173323 [出版社]:中国农业出版社 离散数学-第二版 [ISBN]:9787040419085 [出版社]:高等教育出版社 电路分析基础-第三版 [ISBN]:9787121205927 [出版社]:电子工业出版社 信息技术基础教程 [ISBN]:9787109191891 [出版社]:中国农业出版社 科技信息检索-第六版(2本) [ISBN]:9787030428905 [出版社]:科学出版社 信息技术基础实验指导 [ISBN]:9787109191907 [出版社]:中国农业出版社 农业信息技术-第二版 [ISBN]:9787030287397 [出版社]:科学出版社 思想政治类 毛泽东思想和中国特色社会主义理论体系概论-2018年版 [ISBN]:978704049815 [出版社]:高等教育出版社 中国近代史纲要-2018年版 [ISBN]:978704049839 [出版社]:高等教育出版社 马克思主义基本原理概论-2018年版 [ISBN]:978704049792）[出版社]:高等教育出版社 思想道德修养与法律基础-2015年修订版(2本) [ISBN]:9787040431988 [出版社]:高等教育出版社 2017-2018年形势与政策(2本) [ISBN]:9787561631304 [出版社]:安徽师范大学出版社 大学生职业发展与就业指导(2本) [ISBN]:9787109170537 [出版社]:中国农业出版社 大学体育(2本) [ISBN]:9787109157392 [出版社]:中国农业出版社 新编大学军事学教程 [ISBN]:9787313154347）[出版社]:上海交通大学出版社 高等理工类 线性代数-第二版 [ISBN]:9787109214941 [出版社]:中国农业出版社 概率论与数理统计-第二版 [ISBN]:9787565520648 [出版社]:中国农业出版社 大学物理学 [ISBN]:9787109178748 [出版社]:中国农业出版社 高等数学-上册-第二版(2本) [ISBN]:9787109157576 [出版社]:中国农业出版社 高等数学-下册-第二版(2本) [ISBN]:9787109157507 [出版社]:中国农业出版社 大学物理实验(2本) [ISBN]:9787040493351 [出版社]:高等教育出版社 画法几何及机械制图-第二版 [ISBN]:9787568021166 [出版社]:华中科技大学出版社 画法几何及机械制图习题集-第二版 [ISBN]:9787568021159 [出版社]:华中科技大学出版社 高等数学(第七版上册)同步辅导及习题全解 [ISBN]:9787517026228 [出版社]:中国水利水电出版社 高等数学(第七版下册)同步辅导及习题全解 [ISBN]:9787517026235 [出版社]:中国水利水电出版社 高等数学习题详解(同济第七版) [ISBN]:9787544163422 [出版社]:沈阳出版社 生命科学导论-第三版 [ISBN]:9787040445633 [出版社]:高等教育出版社 期刊杂志类 中国计算机学会通讯第14卷第11期总第1533期 旅游新报2018年01总558期 ","date":"2021-06-17T00:00:00Z","permalink":"https://jen-jon.github.io/booklist/","tags":null,"title":"免费赠送图书书单","type":null},{"contents":"也许是因为到了快要离别的季节，最近总感觉丧气爆满！也许是鸣宝回家了，最近我每天都一个人来来往往了？也许是学校里有什么令我不舍的事情？具体是什么我也不知道了，其实我挺舍不得663实验室的这群小伙伴的，回首大学四年，自从大一寒假进入663实验室（那会门牌号还叫511）后，几乎很少在寝室待了，也就是每天晚上十点多回来后睡个觉，紧接着第二天早上又早早地赶往实验室。很确切地说，663是我大学待过时间最长的地方，也将会是毕业后怀念最深的地方。有时候晚上失眠的时候，脑子里像放电影一样把这四年我经历的大大小小的事情重映一遍，还是会觉得很过瘾。转眼间，老马、舵实、大海都毕业一年了，说起来还是有点可惜，这一年没有机会和他们见上一面。欣慰的是，许磊兜兜转转还是回到了663实验室读研，这也是除了鸣宝为数不多的能经常联系的老朋友。除了老朋友的离开，也结识了一些新朋友如庆宝，663除了是做研究的场所，也能结识更多志同道合的人。希望我毕业去工大后，能继续和这些朋友保持联系吧。 五月份，在忙着写毕业论文挤出的闲暇时间里，看了一部奇幻电视剧《司藤》。其实我本人并不对电视剧感兴趣，尤其是这种奇幻仙侠剧，而且电视剧又具有连续性，需要花一段时间才能看完，对于我这种天生爱快节奏的人来说，简直是折磨。好吧，我承认我是在王姐的强烈推荐下不得已决定去看《司藤》的，当我得知《司藤》的主演是景甜时，我已经对这部剧没有任何期待了。毕竟大甜甜之前的电影、电视剧几乎全是差评。早些年也看过大甜甜的《超时空救兵》、《长城》等电影，的确\u0026hellip;\u0026hellip;大甜甜真好看。抱着看烂剧的心理看了《司藤》第一集，不得了了，第一次觉得景甜的演技有救了、大女主奇幻剧有救了。讲实话，李木戈导演的《司藤》确实拍的不错，而且景甜在这部剧里的妆容实在太好看了。 看到《司藤》的结尾时，其实很容易发现这是一个悲剧式的结尾，但是导演或者编剧可能是害怕被寄刀片吧，又推出了一个番外的圆满的结局，但是作为一个理性的观众，这个圆满的结局不过是个乌托邦罢了，我打心底认可悲剧的结尾，毕竟原本的结局就是悲剧，看到最后再结合着要毕业的心情，可以说是有点意难平了。看完《司藤》已经快半个月了，我似乎还是没有从这个“意难平”的情绪中走出来，也许从侧面反应了这部剧确实拍的不错吧。过去这么久了，我依然经常单曲循环《司藤》的主题曲《千万勇敢》，这首歌配上剧里的情节，实在让人太上头了\u0026hellip;\u0026hellip;不得不说，景甜yyds！！！！\n好了，我也不剧透了，大家有时间可以去看看。\n","date":"2021-06-10T00:00:00Z","permalink":"https://jen-jon.github.io/posts/20210610/","tags":"阶段总结; 剧评","title":"那些五六月的思绪，意难平","type":"summary"},{"contents":"0. 装前须知 ROS官方发行了许多版本，它们与Ubuntu的发行版本存在对应关如下表：\nROS版本 Ubuntu版本 ROS Kinetic Kame Ubuntu 16.04 ROS Melodic Morenia Ubuntu 18.04 ROS Noetic Ninjemys Ubuntu 20.04 因此本文介绍与Ubuntu18.04对应的ROS Melodic Morenia的安装方式。ROS官网提供了Ubuntu平台下编译好的ROS软件包和源码（不推荐），本文推荐大家直接下载官方编译好的软件包。\n1. 安装 1.1. 配置Ubuntu软件仓库 配置你的Ubuntu软件仓库（repositories）以允许使用“restricted”“universe”和“multiverse”存储库。你可以根据Ubuntu软件仓库指南来完成这项工作。\n1.2. 设置sources.list 设置电脑以安装来自packages.ros.org的软件。\nsudo sh -c \u0026#39;echo \u0026#34;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\u0026#34; \u0026gt; /etc/apt/sources.list.d/ros-latest.list\u0026#39; 若下载速度缓慢，推荐就近选择一个镜像源替换上面的命令。例如，Tsinghua University为\nsudo sh -c \u0026#39;. /etc/lsb-release \u0026amp;\u0026amp; echo \u0026#34;deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ `lsb_release -cs` main\u0026#34; \u0026gt; /etc/apt/sources.list.d/ros-latest.list\u0026#39; 如果依旧遇到连接问题，请尝试为Ubuntu apt换源（非ROS网站）。\n1.3. 设置密钥 sudo apt-key adv --keyserver \u0026#39;hkp://keyserver.ubuntu.com:80\u0026#39; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 若无法连接到密钥服务器，可以尝试替换上面命令中的hkp://keyserver.ubuntu.com:80为hkp://pgp.mit.edu:80。\n你也可以使用curl命令替换apt-key命令，这在使用代理服务器的情况下比较有用：\ncurl -sSL \u0026#39;http://keyserver.ubuntu.com/pks/lookup?op=get\u0026amp;search=0xC1CF6E31E6BADE8868B172B4F42ED6FBAB17C654\u0026#39; | sudo apt-key add - 1.4. 安装 首先，确保你的 Debian 包索引是最新的\nsudo apt update 在 ROS 中有很多不同的库和工具。我们提供了四种默认选项供你开始。你也可以单独安装ROS的软件包。\n如果下面的步骤出现问题，你可以用这个源来替代上面提到的源：ros-shadow-fixed（英文页面）\n桌面完整版（推荐）：包含ROS、rqt、rviz、机器人通用库、2D/3D模拟器、导航以及2D/3D感知包。\nsudo apt install ros-melodic-desktop-full 桌面版：包含ROS，rqt、rviz和机器人通用库。\nsudo apt install ros-melodic-desktop ROS-基础包： 包含ROS包，构建和通信库。没有图形界面工具。\nsudo apt install ros-melodic-ros-base 单独的包： 你也可以安装某个指定的ROS软件包（使用软件包名称替换掉下面的PACKAGE）：\nsudo apt install ros-melodic-PACKAGE 如：\nsudo apt install ros-melodic-slam-gmapping 要查找可用软件包，请运行：\napt search ros-melodic 1.5. 初始化Rosdep 在你使用ROS之前，需要初始化rosdep。rosdep让你能够轻松地安装被想要编译的源代码，或被某些ROS核心组件需要的系统依赖。\nsudo rosdep init rosdep update 1.6. 设置环境 将ROS环境变量自动添加到新zsh会话会很方便：\necho \u0026#34;source /opt/ros/melodic/setup.zsh\u0026#34; \u0026gt;\u0026gt; ~/.zshrc source ~/.zshrc 如果你只想在当前zsh会话中设置ROS的环境变量，只需要输入：\nsource /opt/ros/melodic/setup.zsh 1.7. 构建工厂依赖 到目前为止，你已经安装了运行核心ROS包所需的内容。为了创建和管理自己的ROS工作区，有各种各样的工具和需求分别分布。例如：rosinstall是一个经常使用的命令行工具，它使你能够轻松地从一个命令下载许多ROS包的源树。\n要安装这个工具和其他构建ROS包的依赖项，请运行:\nsudo apt-get install python-rosinstall python-rosinstall-generator python-wstool build-essential 2. 测试ROS 完成上述步骤的安装过程后需要验证ROS是否安装成功，请输入：\nroscore 看到如started core service [/rosout]的输出即表示安装成功！\n","date":"2021-05-25T00:00:00Z","permalink":"https://jen-jon.github.io/posts/20210525/","tags":"ROS; Ubuntu","title":"在Ubuntu18.04系统中安装ROS(Robot Operate System)","type":"technology"},{"contents":"Note This document mainly introduces the use of ADM PV-RCNN Docker container, details can be seen here.\nThis Docker container contains a complete pipline working files from LiDAR to algorithm model. This Docker container can process the Pcap format data packets collected by LiDAR. Currently, it only supports data collected by four types of LiDAR produced by Robosense: RS-LiDAR-16, RS-LiDAR-32, RS-LiDAR-64 and RS-LiDAR-128. More brands and types of lidar will be supported in the future.\nDescription ADM PV-RCNN full name is Adaptive Deformable Module PV-RCNN, is a new Point-based and Voxel-based 3D object detection model designed based on PV-RCNN (See github.com/open-mmlab/OpenPCDet). We add adaptive deformation convolution module and context fusion module on the basis of PV-RCNN. Adaptive deformation convolution module can solve the problem of poor recognition accuracy of PV-RCNN model in fuzzy scene and long-distance scene, and context fusion module can reduce the probability of false positive of PV-RCNN model in the area of uneven distribution of point cloud. We tested the proposed ADM PV-RCNN model on KITTI datasets, and the results show that the proposed model were much higher than PV-RCNN and other similar models.\nDownload Simply type docker pull 663lab/ adm-pv-rcnn:v1.0 on the machine where Docker is installed, and you can download the Docker container.\nUsage 1. Parse the LiDAR pcap packet Enter the Docker container and mount the Pcap format data packet collected by Robosense lidar into the Docker container.\na. Go to the Robosense LiDAR SDK folder cd ~/catkin_ws/src/rslidar_sdk/ b. Convert Pcap packets to Pcd data ▪︎ Modify the parameters in the config.yaml file under the config directory to the corresponding parameters, such as changing msg_source to 3, changing pcap_path to the path of pcap packet, and changing lidar_type to the type of LiDAR. ▪︎ Turn the Pcap packets into ROSBag packets by running the following command: roslaunch rslidar_sdk start.launch ▪︎ Go to the directory where Pcap packets are stored ▪︎ Repair ROSBag packet by running the following command: rosbag reindex xxx.bag.active rosbag fix xxx.bag.active result.bag ▪︎ Turn the ROSBag packets into Pcd data by running following command: rosrun pcl_ros bag_to_pcd result.bag ~/pcdfiles The converted Pcd data files are stored in the /root/pcdfiles/directory.\n2. Convert LiDAR point clouds to standardized bin files a. Convert Pcd data files to binary bin data files ▪︎ Go to the Pcd-to-bin project folder cd ~/pcd2bin/ ▪︎ Modify the pcd2bin.cpp file in the current directory, and change pcd_path and bin_path to corresponding paths. ▪︎ Compile and install the Pcd-to-bin project by running following command: mkdir build \u0026amp;\u0026amp; cd build cmake .. \u0026amp;\u0026amp; make ▪︎ Generate binary bin data files by running following command: zsh ./bin2pcd b. Modify bin data files to standardized bin files ▪︎ Go to Modbin project folder: cd ~/modbin/ ▪︎ Generate standardized bin data files by running following command: mkdir ~/modfiles conda activate model python modbin.py --ori_path ~/binfiles mod_path ~/modfiles 3. Usages of ADM PV-RCNN a. Go to the ADM PV-RCNN project folder: cd ~/ADM-PV-RCNN/ b. Copy ADM PV-RCNN src into OpenPCDet: zsh ./init.sh c. Prepare KITTI dataset: ▪︎ Please download the official KITTI 3D object detection dataset and organize the downloaded files as follows (the road planes could be downloaded from [road plane], which are optional for data augmentation in the training): ADM-PV-RCNN ├── OpenPCDet │ ├── data │ │ ├── kitti │ │ │ │──ImageSets │ │ │ │──training │ │ │ │ ├──calib \u0026amp; velodyne \u0026amp; label_2 \u0026amp; image_2 \u0026amp; (optional: planes) │ │ │ │──testing │ │ │ │ ├──calib \u0026amp; velodyne \u0026amp; image_2 │ ├── pcdet │ ├── tools ▪︎ Generate the data infos by running the following command: python -m pcdet.datasets.kitti.kitti_dataset create_kitti_infos tools/cfgs/dataset_configs/kitti_dataset.yaml d. Run experiments with a specific configuration file: ▪︎ Test and evaluate the pretrained model,You can download our pretrained model here. • Go to tools: cd OpenPCDet/tools • Test with a pretrained model: python test.py --cfg_file ${CONFIG_FILE} --batch_size ${BATCH_SIZE} --ckpt ${CKPT} • For example: python test.py --cfg_file cfgs/kitti_models/def_pv_rcnn.yaml --batch_size 4 --ckpt ${SAVED_CKPT_PATH}/def_pv_rcnn.pth ▪︎ Train a model: • Train with multiple GPUs: sh scripts/dist_train.sh ${NUM_GPUS} --cfg_file ${CONFIG_FILE} --batch_size ${BATCH_SIZE} --epochs 80 • For example: sh scripts/dist_train.sh 8 --cfg_file cfgs/kitti_models/def_pv_rcnn.yaml --batch_size 16 --epochs 100 • Train with a single GPU: python train.py --cfg_file ${CONFIG_FILE} --batch_size ${BATCH_SIZE} --epochs 100 e. Quick demo ▪︎ Run the demo with a pretrained model and your custom point cloud data by running following command: python demo.py --cfg_file cfgs/kitti_models/adm_pv_rcnn.yaml --ckpt adm_pv_rcnn_epoch_100.pth --data_path ${POINT_CLOUD_DATA} Here ${POINT_CLOUD_DATA} could be the following format:\n1). Your transformed custom data with a single numpy file like my_data.npy.\n2). Your transformed custom data with a single bin file like my_data.bin.\n3). Your transformed custom data with a directory to test with multiple point cloud data.\n4). The original KITTI .bin data within data/kitti, like data/kitti/testing/velodyne/000010.bin.\nP.s. : If you have any questions, please email me at jensen.acm@gmail.com (please indicate \u0026ldquo;ADM PV-RCNN\u0026rdquo; as the subject of the email). ","date":"2021-05-23T00:00:00Z","permalink":"https://jen-jon.github.io/posts/20210523/","tags":"Docker; LiDAR; 3D CV","title":"The Usage of ADM PV-RCNN","type":"technology"},{"contents":"","date":"2021-05-22T00:00:00Z","permalink":"https://jen-jon.github.io/types/lifestyle/","tags":null,"title":"Lifestyle Blogs","type":null},{"contents":"","date":"2021-05-22T00:00:00Z","permalink":"https://jen-jon.github.io/types/summary/","tags":null,"title":"Summary Blogs","type":null},{"contents":"","date":"2021-05-22T00:00:00Z","permalink":"https://jen-jon.github.io/types/technology/","tags":null,"title":"Technology Blogs","type":null},{"contents":"听闻最近京东的全球第二家电器超级体验店开业了，居然在合肥。打开地图搜了搜，发现也不远，坐地铁经过五站就可以到达，目测骑车也就十来分钟的事。 下地铁后，远处就能看到超体外玻璃幕墙上“爬”着一个巨大的“狗东（京东的拟人形象就是一只狗，简称‘狗东’）”，由于目前还是试营业阶段，所以门口还是能看出很多正在施工的痕迹。不过好在体验店的里面已经基本能够投入使用了。\n整个超体一共有六层，其中地上五层，地下一层。地上五层都是京东运营的，地下那一层是百大运营的合家福超市，估计是怕大家逛超体逛累了，可以在超市买点吃喝的。\n走进大厅，首先映入眼帘的就是偌大的京东苹果授权店和其他手机厂商的授权店，貌似一楼都是和手机有关的展品。苹果授权店的人也是最多的，一大批顾客都挤在陈列苹果设备的吧台上。我也顺道去看了看前不久发布的搭载M1芯片的多彩iMac，怎么说呢，这款iMac的屏幕边框太大，可能不是我想要的那种电脑，其次，我是真的很受不了苹果的秒控鼠标，这种扁平式的鼠标也太反人类了吧？！苹果的触控板完全吊打鼠标啊！ 除了苹果，小米的展台也人头攒动，不过有一说一，小米新出的11 Utral的摄像模组也太突出了吧，这玩意揣口袋里不怕被钥匙什么的划坏吗？要是再戴个手机壳，那这手机可真有半斤了！妥妥的“米半斤”！ 小米的Mix Fold也忒像三星Galaxy Fold一代了吧？极度怀疑小米是不是买了三星的解决方案。然后这个外屏比例实在难以接受，整的就像米家AI多亲至尊纪念版手机一样\u0026hellip;\u0026hellip; 华为的展台还依旧是中规中矩，一副简洁的风格。 除了手机之外，一楼还留有一小部分展示有相机、音乐播放器、无人机等产品，不过这索尼家的展台是不是小的有点过分了（好像五楼还有索尼电视的展台，不知道算不算一家的）？ 这次体验主要集中在一楼，其他楼层就简单逛了逛，二楼主要是电脑厂商的授权店和展台；三楼主要是小型智能家居、按摩椅的天下；四楼是热水器空调冰箱的王国；五楼就是各家电视厂商争奇斗艳的舞台了，不过索尼、三星、LG这三家真的是太强了，国产显示面板还是有很长的路要走啊。\nP.s.: 合肥京东电器超级体验店位置=\u0026gt;潜山路与望江路交口，港汇广场（地铁三号线洪岗站下即可） ","date":"2021-05-21T00:00:00Z","permalink":"https://jen-jon.github.io/posts/20210521/","tags":"京东; 电子产品; 探店","title":"逛合肥京东电气超级体验店","type":"lifestyle"},{"contents":"About Me def welcome(): print(\u0026#34;Hello! This is Jensen J. ZHANG!\u0026#34;) return 😊 if __name__ == \u0026#34;__main__\u0026#34;: welcome() Hello everyone! Welcome to visit my homepage! I\u0026rsquo;m a postgraduate of CS in the Lab for Media Computing of HFUT (Hefei University of Technology). I\u0026rsquo;m mainly engaged in the reasearch of Low-light Image Enhancement algorithms and Computational Photography. Some research has also been done on Few-shot Learning and 3D Object Detection based on Lidar. The blogs in my homepage were divided into three content sections, Technology, Lifestyle and Summary. I will share my insights and interesting things in my life and work from time to time.\nHello everyone! Thank you for visiting my homepage. I am currently pursuing my postgraduate studies in Computer Science at the Laboratory for Media Computing, Hefei University of Technology. My primary research focus is on Low-light Image Enhancement algorithms and Computational Photography. I have also explored Few-shot Learning and 3D Object Detection using Lidar technology.\nThis website serves as a platform where I categorize my blogs into three main sections: Technology, Lifestyle and Summary. In the Technology section, I delve into the latest advancements and my own research in the field of Computer Science. The Lifestyle section is where I share intriguing aspects of my daily life and experiences. Lastly, the Summary section provides an overview of my thoughts and reflections on various topics.\nStay tuned for updates where I will share more about my professional journey and personal experiences!\nHobbies Lego, Astronomy and Photography Snowboard, Mountain cycling All interesting things are worth exploring\u0026hellip; Education Experiences My academic background is outlined below, presented in chronological order:\nPeriod Institution Degree/Course August 2017 - June 2021 School of Information and Computer Sciences, Anhui Agricultural University Bachelor of Engineering in Computer Science (CS) July 2021 - Present Laboratory for Media Computing, Hefei University of Technology Postgraduate Studies in Computer Science Research Interests Low-Light Image Enhancement Algorithms and Computational Photography (Main Research Area) Behavioral Analysis and Identification of Captive Animals Few-Shot Learning for Plant Disease Identification Fruit Identification and Localization in Orchards Using 3D Point Clouds Publications [Citations: 118 | h-index: 3] Source: Google Scholar | ResearchGate\nIn chronological order:\n苏军, 饶元, 张敬尧, 李绍稳. 基于GA优化SVM的干制红枣品种分类方法[J]. 洛阳理工学院学报(自然科学版), 2018, 28(04): 65-69+93. 姜敏, 沈一鸣, 张敬尧, 饶元, 董伟. 基于深度学习的水稻病虫害诊断方法研究[J]. 洛阳理工学院学报(自然科学版), 2019, 29(04): 78-83. 饶元, 赵刚, 张敬尧, 等. 一种基于压缩感知和模型驱动的数据收集方法: , CN109921952A[P]. 2019. 饶元, 姜敏, 张敬尧, 等. 一种基于深度学习的圈养动物行为分析方法: , CN110490161A[P]. 2019. Rao Y, Zhao G, Wang W, Zhang Jingyao, et al. Adaptive data acquisition with energy efficiency and critical-sensing guarantee for wireless sensor networks[J]. Sensors, 2019, 19(12): 2654. Jiang M, Rao Y, Zhang Jingyao, et al. Automatic behavior recognition of group-housed goats using deep learning[J]. Computers and Electronics in Agriculture, 2020, 177: 105706. Zhang Jingyao, Rao Y, Man C, et al. Identification of cucumber leaf diseases using deep learning and small sample size for agricultural Internet of Things[J]. International Journal of Distributed Sensor Networks, 2021, 17(4): 15501477211007407. 王丰仪, 饶元, 罗庆, 张通, 万天宇, 张敬尧, 等. 毛桃多模态图像目标检测数据集[J]. 中国科学数据(中英文网络版), 2022, 7(4): 367-379. DOI: 10.57760/sciencedb.j00001.00470. Major Awards/Honors Throughout my undergraduate studies, I have been fortunate to receive several prestigious awards and honors. Below is a selection of these recognitions, presented in chronological order:\nYear Collaborator(s) Award/Honor 2018 Yu Xiaoyu; Ma Junxiang First Prize in Anhui Province Network and Distributed System Innovation Contest 2019 Ma Junxiang; Shen Yiming First Prize in Anhui Province, Second Prize Nationally in Chinese Undergraduate Computer Design Contest 2020 - Recommended for Direct Admission to Master’s Degree Program as an Outstanding Graduate, Anhui Agricultural University 2021 - First-Class Scholarship at Hefei University of Technology Work Experiences My professional journey, in chronological order, reflects a diverse range of roles and responsibilities in the field of technology and research:\nPeriod Organization Position Oct 2017 - Mar 2018 Network Department, Information Center, Anhui Agricultural University Operation and Maintenance Engineer Mar 2018 - Dec 2019 Key Laboratory of IoT Technology Integration and Application, Ministry of Agriculture and Village, PRC Trainee Software Engineer Jan 2020 - Aug 2021 Anhui Provincial Key Laboratory of Smart Agricultural Technology and Equipment, PRC Computer Vision Algorithm Researcher Sep 2021 - Present Present\tLaboratory for Media Computing, Hefei University of Technology Apple Developer \u0026amp; AI Algorithm Researcher I am on the verge of commencing my professional journey with Meituan, Inc., where I will be contributing to technical research and development in their innovative projects\u0026hellip;\nContact Me Email: jensen.acm(AT)gmail.com (Please replace (AT) with @ when sending email) WeChat: Jensen-Jon WeChat QR Code: Mailing Address Room 903, Lab for Media Computing Block A, Feicui Kejiao Building, Hefei University of Technology\n485 DanxiaXi Rd., Shushan District\nHefei City, Anhui Province, P.R.China\nDigital Map: Social Github Bilibili DockerHub ResearchGate ","date":null,"permalink":"https://jen-jon.github.io/about/","tags":null,"title":"About","type":null},{"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","date":null,"permalink":"https://jen-jon.github.io/search/","tags":null,"title":"Search Results","type":null}]