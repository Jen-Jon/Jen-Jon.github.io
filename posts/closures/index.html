<!DOCTYPE html>
<html lang=""><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <title>Swift学习(9)-闭包（代码完善版）</title>
    <meta name="description" content="A simple homepage of Jensen Zhang.">
    <meta name="author" content='Jensen Zhang'>

    <link href="https://cdn.jsdelivr.net/gh/Jen-Jon/CDN_Bank/srcs/homepage_css2.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/gh/Jen-Jon/CDN_Bank/srcs/buttonsstyle.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous">

    <script defer src="https://cdn.jsdelivr.net/gh/Jen-Jon/CDN_Bank/srcs/backbutton.js"></script>
    <script async src="https://cdn.jsdelivr.net/gh/Jen-Jon/CDN_Bank/srcs/busuanzi.pure.mini.js"></script>

    
    <script>
        WIDGET = {
        "CONFIG": {
            "modules": "0124",
            "background": "5",
            "tmpColor": "fff",
            "tmpSize": "16",
            "tmpPadding": "10px",
            "cityColor": "000",
            "citySize": "16",
            "aqiColor": "fff",
            "aqiSize": "16",
            "weatherIconSize": "24",
            "alertIconSize": "18",
            "padding": "0px",
            
            "language": "en",
            "key": "06a49925209149af84e325a6c7e5c521"
        }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/gh/Jen-Jon/CDN_Bank/srcs/he-simple-common-v2.0.js"></script>
    

    
    <script>
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?a4cacad7bf6ee4f58534d26d5b23ad14";
          var s = document.getElementsByTagName("script")[0]; 
          s.parentNode.insertBefore(hm, s);
        })();
    </script>
    

    
    <link rel="stylesheet" href="/sass/researcher.min.css">

    
        <link rel="icon" type="image/ico" href="https://jen-jon.github.io/images/favicon.ico">
    

    
        
    
</head>

    <body><div id="ukraine" style="background-color: #e14859; ">
    <a class="cba fas fa-window-close" onclick="test()" style="display:block; float:right; width:30px; height:29px;" href="#"></a>
    <div style="height: 50px; display: flex; text-align: center; justify-content: center; align-items: center;">
        <div style="margin: 0 10px;">
            <div style="font-size: 45px;">🇺🇦</div>
        </div>
        <div style="margin: 0 10px;">
            <a style="color: white;" href="/we-stand-with-ukraine">
                <div style="color: white; font-weight: bold; font-size: large;">We stand with Ukraine!</div>
                <div style="color: white; font-weight: bold; font-size: large;">我们支持乌克兰！</div>
            </a>
        </div>
    </div>
</div>
<script>
    function test() {
        document.getElementById("ukraine").parentElement.removeChild(document.getElementById("ukraine"));
    }
</script>

<div class="container mt-5" style="text-align: right;">
    
    <div style="display: inline-flex; background-color: #e14859;">
        <div id="he-plugin-simple"></div>
    </div>
    
    <nav class="navbar navbar-expand-sm flex-column flex-sm-row text-nowrap p-0">
        <a class="navbar-brand mx-0 mr-sm-auto" href="https://jen-jon.github.io/" title="Jensen&#39;s Homepage">
          
          <i class="fas fa-home"></i>
          Jensen&#39;s Homepage
        </a>
        <div class="navbar-nav flex-row flex-wrap justify-content-center">
            
                
                
                    <a class="nav-item nav-link" href="/about" title="About">
                        About
                    </a>
                    
                        <span class="nav-item navbar-text mx-1">/</span>
                    
                
                    <a class="nav-item nav-link" href="/posts" title="Posts">
                        Posts
                    </a>
                    
                        <span class="nav-item navbar-text mx-1">/</span>
                    
                
                    <a class="nav-item nav-link" href="/contact" title="Contact">
                        Contact
                    </a>
                    
                        <span class="nav-item navbar-text mx-1">/</span>
                    
                
                    <a class="nav-item nav-link" href="/tools" title="Tools">
                        Tools
                    </a>
                    
                
            
        </div>
    </nav>
</div>
<hr><div id="content">
<div class="container">
    
    <h1 style="color: #dc3545;">Swift学习(9)-闭包（代码完善版）</h1>
    
    <h5>Posted by <a href="https://jen-jon.github.io/">Jensen Zhang</a> on <em>August 23, 2021</em> | <spa id="busuanzi_container_page_pv"><i class="fas fa-eye"></i> <em><span id="busuanzi_value_page_pv"></span></em> readings</span> </h5>
    
    <h5>This article is about <em>9164</em> words and may take <em>19</em> minutes to read.</h5>
    <hr>
    
    
    <p><img src="https://cdn.jsdelivr.net/gh/Jen-Jon/Jen-Jon.github.io/images/closures.png" alt="Logo"/></p>
    <hr>
    
    
    <blockquote>
        <p><strong>Type: technology blog</strong></p>
        <p><strong>Tags: iOS; Swift; Apple</strong></p>
    </blockquote>
    <hr>
    
    
    <h1 style="color: #dc3545;">Content</h1>
    <br>
    
    <p>闭包是自包含的函数代码块，可以在代码中被传递和使用。<code>Swift</code>中的闭包与<code>C</code>和<code>Objective-C</code>中的代码块（blocks）以及Python语言中的匿名函数（Lambdas）比较相似。</p>
<p>闭包可以捕获和存储其所在上下文中任意常量和变量的引用。被称为包裹常量和变量。<code>Swift</code>会管理在捕获过程中涉及到的所有内存操作。</p>
<blockquote>
<p><strong>注意</strong></p>
<p>如果不熟悉捕获这个概念（Capturing）也不必担心，在值补货章节有它更详细的介绍。】</p>
</blockquote>
<p>在函数章节中介绍的全局和嵌套函数实际上也是一种特殊的闭包，闭包采用如下三种形式之一：</p>
<ul>
<li>全剧函数是一个有名字但不会捕获任何值的闭包</li>
<li>嵌套函数是一个有名字且可以捕获其封闭函数域内值的闭包</li>
<li>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包</li>
</ul>
<p><code>Swift</code>的闭包表达式拥有简洁的风格，并鼓励在常见场景中进行语法优化，主要优化如下：</p>
<ul>
<li>利用上下文推断出参数和返回值类型</li>
<li>隐式返回单表达式闭包，即单表达式闭包可以省略<code>return</code>关键字</li>
<li>参数名称缩写</li>
<li>尾随闭包语法</li>
</ul>
<hr>
<h2 id="闭包表达式">闭包表达式</h2>
<p>嵌套函数作为复杂函数的一部分时，它自包含代码块式的定义和命名形式在使用上带来了方便。当然，编写未完整声明和没有函数名的类函数结构代码是很有用的，尤其是在编码中涉及到函数作为参数的那些方法时。</p>
<p>闭包表达式是一种构建内联闭包的方式，它的语法简洁，在保证不丢失它语法清晰明了的同时，闭包表达式提供了几种优化的语法简写形式。下面通过对<code>sorted(by:)</code>这一案例的多次迭代改进来展示这个过程，每次迭代都使用了更加简明的方式描述了相同的功能。</p>
<h3 id="排序方法">排序方法</h3>
<p><code>Swift</code>标准库提供了名为<code>sorted(by:)</code>的方法，它会基于开发者提供的排序闭包表达式的判断结果对数组中的值（类型确定）进行排序。一旦它完成排序过程，<code>sorted(by:)</code>方法会返回一个与旧数组类型大小相同的类型的新数组，该数组的元素有着正确的排序顺序。原数组不会被<code>sorted(by:)</code>方法修改。</p>
<p>下面的闭包表达式示例使用<code>sorted(by:)</code>方法对一个<code>String</code>类型的数组进行字母逆序排序。以下是初始数组：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> names = [<span style="color:#e6db74">&#34;Chris&#34;</span>, <span style="color:#e6db74">&#34;Alex&#34;</span>, <span style="color:#e6db74">&#34;Ewa&#34;</span>, <span style="color:#e6db74">&#34;Barry&#34;</span>, <span style="color:#e6db74">&#34;Jensen&#34;</span>]
</span></span></code></pre></div><p><code>sorted(by:)</code>方法接受一个闭包，该闭包函数需要传入与数组元素类型相同的两个值，并返回一个布尔类型值来表明当排序结束后传入的第一个参数排在第二个参数的前面还是后面。如果第一个参数值出现在第二个参数值的前面，排序闭包函数需要返回<code>true</code>，反之返回<code>false</code>。</p>
<p>该例子对一个<code>String</code>类型的数组进行排序，因此排序闭包函数类型需为<code>(String, String) -&gt; Bool</code>。</p>
<p>提供排序闭包函数的一种方式是撰写一个复合其要求的普通函数，并将其作为<code>sorted(by:)</code>方法的参数传入：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">backward</span>(<span style="color:#66d9ef">_</span> s1: String, <span style="color:#66d9ef">_</span> s2: String) -&gt; Bool {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> s1 <span style="color:#f92672">&gt;</span> s2
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> reversedNames = names.sorted(by: backward)  <span style="color:#75715e">// reversedNames为[&#34;Jensen&#34;, &#34;Ewa&#34;, &#34;Chris&#34;, &#34;Barry&#34;, &#34;Alex&#34;]</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;复杂闭包逆序：</span><span style="color:#e6db74">\(</span>reversedNames<span style="color:#e6db74">)</span><span style="color:#e6db74">.&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">---</span>
</span></span><span style="display:flex;"><span>output: <span style="color:#960050;background-color:#1e0010">复杂闭包逆序：</span>[<span style="color:#e6db74">&#34;Jensen&#34;</span>, <span style="color:#e6db74">&#34;Ewa&#34;</span>, <span style="color:#e6db74">&#34;Chris&#34;</span>, <span style="color:#e6db74">&#34;Barry&#34;</span>, <span style="color:#e6db74">&#34;Alex&#34;</span>].
</span></span></code></pre></div><p>如果第一个字符串（s1）大于第二个字符串（s2），<code>backward(_:_:)</code>函数会返回<code>true</code>，表示在新的数组中<code>s1</code>应该出现在<code>s2</code>之前。对于字符串中的字符来说，“大于”表示“按照字母顺序较晚出现”。这意味着字母“B”大于字母“A”，字符串“Tom”大于字符串“Tim”。该闭包将进行字母的逆序排序，“Jensen”将会排在“Eva”的前面。</p>
<p>然而，以这种方式来编写一个实际上很简单的表达式（a &gt; b），确实太过繁琐了。对于这个例子来说，利用闭包表达式语法可以更好地构造一个内联排序闭包。</p>
<h3 id="闭包表达式语法">闭包表达式语法</h3>
<p>闭包表达式语法有如下的一般形式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> { (parameters) -&gt; return type in
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     statements
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span></code></pre></div><p>闭包表达式参数可以是<code>in-out</code>参数，但不能设定默认值。如果命名了可变参数，也可以使用此可变参数，元组可以作为参数和返回值。</p>
<p>下面的例子展示了之前<code>backward(_:_:)</code>函数对应的闭包表达式版本的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span>reversedNames = names.sorted(by: { (s1: String, s2: String) -&gt; Bool <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> s1 <span style="color:#f92672">&gt;</span> s2
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;内联闭包表达式逆序：</span><span style="color:#e6db74">\(</span>reversedNames<span style="color:#e6db74">)</span><span style="color:#e6db74">.&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">---</span>
</span></span><span style="display:flex;"><span>output: <span style="color:#960050;background-color:#1e0010">内联闭包表达式逆序：</span>[<span style="color:#e6db74">&#34;Jensen&#34;</span>, <span style="color:#e6db74">&#34;Ewa&#34;</span>, <span style="color:#e6db74">&#34;Chris&#34;</span>, <span style="color:#e6db74">&#34;Barry&#34;</span>, <span style="color:#e6db74">&#34;Alex&#34;</span>].
</span></span></code></pre></div><p>需要注意的是内联闭包参数和返回值类型声明与<code>backward(_:_:)</code>函数类型声明相同。这两种方式中，都写成了<code>(s1: String, s2: String) -&gt; Bool</code>。然而在内联闭包表达式中，函数和返回值类型都写在大括号内，而不是大括号外。</p>
<p>闭包的函数体部分由关键字<code>in</code>引入。该关键字表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。</p>
<p>由于这个闭包的函数体部分如此短，以至于可以将其改写成一行代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span>reversedNames = names.sorted(by: {(s1: String, s2: String) -&gt; Bool <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">return</span> s1 <span style="color:#f92672">&gt;</span> s2})
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;简洁内联闭包表达式逆序：</span><span style="color:#e6db74">\(</span>reversedNames<span style="color:#e6db74">)</span><span style="color:#e6db74">.&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">---</span>
</span></span><span style="display:flex;"><span>output: <span style="color:#960050;background-color:#1e0010">简洁内联闭包表达式逆序：</span>[<span style="color:#e6db74">&#34;Jensen&#34;</span>, <span style="color:#e6db74">&#34;Ewa&#34;</span>, <span style="color:#e6db74">&#34;Chris&#34;</span>, <span style="color:#e6db74">&#34;Barry&#34;</span>, <span style="color:#e6db74">&#34;Alex&#34;</span>].
</span></span></code></pre></div><p>该例中<code>sorted(by:)</code>方法的整体调用保持不变，一对圆括号依然包裹住了方法的整个参数。然而，参数现在变成了内联闭包。</p>
<h3 id="根据上下文推断类型">根据上下文推断类型</h3>
<p>因为排序闭包函数是作为<code>sorted(by:)</code>方法的参数传入的，<code>Swift</code>可以推断其参数和返回值类型。<code>sorted(by:)</code>方法被一个字符串数组调用，因此其参数必须是<code>(String, String) -&gt; Bool</code>类型的函数。这意味着<code>(String, String)</code>和<code>Bool</code>类型并不需要作为闭包表达式定义的一部分。因为所有的类型都可以被正确推断，返回箭头<code>-&gt;</code>和围绕在参数周围的括号也可以被省略：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span>reversedNames = names.sorted(by: {s1, s2 <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">return</span> s1 <span style="color:#f92672">&gt;</span> s2})
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;隐式推断类型闭包表达式逆序：</span><span style="color:#e6db74">\(</span>reversedNames<span style="color:#e6db74">)</span><span style="color:#e6db74">.&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">---</span>
</span></span><span style="display:flex;"><span>output: <span style="color:#960050;background-color:#1e0010">隐式推断类型闭包表达式逆序：</span>[<span style="color:#e6db74">&#34;Jensen&#34;</span>, <span style="color:#e6db74">&#34;Ewa&#34;</span>, <span style="color:#e6db74">&#34;Chris&#34;</span>, <span style="color:#e6db74">&#34;Barry&#34;</span>, <span style="color:#e6db74">&#34;Alex&#34;</span>].
</span></span></code></pre></div><p>实际上，通过内联闭包表达式构建的闭包作为参数传递给函数或方法时，总是能够推断出闭包的参数和返回值类型。这意味着闭包作为函数或者方法的参数时，几乎不需要利用完整格式构造内联闭包。</p>
<p>尽管如此，仍然可以明确写出有者完整格式的闭包。如果完整格式的闭包能够提高代码的可读性，则<code>Swift</code>更鼓励采用完整格式的闭包。而在<code>sorted(by:)</code>方法这个例子里，显然闭包的目的就是排序，因此读者能够推测出这个闭包时用于字符串处理的。</p>
<h3 id="单表达式闭包的隐式返回">单表达式闭包的隐式返回</h3>
<p>单行表达式闭包可以通过省略<code>return</code>关键字来隐式返回单行表达式的结果，如上版本的例子可以改写为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span>reversedNames = names.sorted(by: {s1, s2 <span style="color:#66d9ef">in</span> s1 <span style="color:#f92672">&gt;</span> s2})
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;极致省略闭包逆序： </span><span style="color:#e6db74">\(</span>reversedNames<span style="color:#e6db74">)</span><span style="color:#e6db74">.&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">---</span>
</span></span><span style="display:flex;"><span>output: <span style="color:#960050;background-color:#1e0010">极致省略闭包逆序：</span> [<span style="color:#e6db74">&#34;Jensen&#34;</span>, <span style="color:#e6db74">&#34;Ewa&#34;</span>, <span style="color:#e6db74">&#34;Chris&#34;</span>, <span style="color:#e6db74">&#34;Barry&#34;</span>, <span style="color:#e6db74">&#34;Alex&#34;</span>].
</span></span></code></pre></div><p>在这个例子中，<code>sorted(by:)</code>方法的参数类型明确了闭包必须返回一个<code>Bool</code>类型值。因为闭包函数体只包含了一个单一表达式（s1 &gt; s2），该表达式返回<code>Bool</code>类型值，因此这里没有歧义，<code>return</code>关键字可以省略。</p>
<h3 id="参数名称缩写">参数名称缩写</h3>
<p><code>Swift</code>自动为内联闭包提供了参数名称缩写功能，可以直接通过<code>$0</code>，<code>$1</code>和<code>$2</code>来顺序调用闭包的参数，以此类推。</p>
<p>如果在闭包表达式中使用参数名称缩写，可以在闭包定义中省略参数列表，并且对应参数名称缩写的类型会通过函数类型进行推断。闭包接受的参数数量取决于所使用的缩写参数的最大编号。<code>    in</code>关键字同样可以被忽略，因为此时闭包表达式完全由闭包函数体构成：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span>reversedNames = names.sorted(by: { $0 <span style="color:#f92672">&gt;</span> $1 })
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;省略参数名称闭包逆序：</span><span style="color:#e6db74">\(</span>reversedNames<span style="color:#e6db74">)</span><span style="color:#e6db74">.&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">---</span>
</span></span><span style="display:flex;"><span>output: <span style="color:#960050;background-color:#1e0010">省略参数名称闭包逆序：</span>[<span style="color:#e6db74">&#34;Jensen&#34;</span>, <span style="color:#e6db74">&#34;Ewa&#34;</span>, <span style="color:#e6db74">&#34;Chris&#34;</span>, <span style="color:#e6db74">&#34;Barry&#34;</span>, <span style="color:#e6db74">&#34;Alex&#34;</span>].
</span></span></code></pre></div><p>在这个例子中，<code>$0</code>和<code>$1</code>表示闭包中第一个和第二个<code>String</code>类型的参数，因为<code>$1</code>是编号最大的缩写参数，所以可以理解为：该闭包需要两个参数。这里的<code>sorted(by:)</code>函数希望得到一个参数都是字符串的闭包，因此缩写参数<code>$0</code>和<code>$1</code>的类型均为<code>String</code>。</p>
<h3 id="运算符方法">运算符方法</h3>
<p>实际上还有一种更简短的方式来编写上面的闭包表达式。<code>Swift</code>的<code>String</code>类型定义了关于大于号<code>&gt;</code>的字符串实现，其作为一个函数接受两个<code>String</code>类型的参数并返回<code>Bool</code>类型的值。而这正好与<code>sorted(by:)</code>方法的参数需要的函数类型相符合。因此，可以简单地传递一个大于号，<code>Swift</code>可以自动推断找到系统自带的那个字符串函数的实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span>reversedNames = names.sorted(by: <span style="color:#f92672">&gt;</span>)
</span></span></code></pre></div><p>更多关于运算符方法的内容请查看<a href="https://jen-jon.github.io/posts/advancedop/">运算符方法</a></p>
<hr>
<h2 id="尾随闭包">尾随闭包</h2>
<p>如果需要将一个很长的闭包表达式作为最后一个参数传递给函数，将这个闭包替换成尾随闭包的形式很有用。尾随闭包是一个书写在函数圆括号之后的闭包表达式，函数支持将其作为最后一个参数调用。在使用尾随闭包时，不用写出它的参数标签：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> func someFunctionThatTakesAClosure(closure: () -&gt; Void) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     // 函数体部分
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> // 以下是不使用尾随闭包进行函数调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> someFunctionThatTakesAClosure(closure: {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     // 闭包主体部分
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> })
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> // 以下是使用尾随闭包进行函数调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> someFunctionThatTakesAClosure {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     // 闭包主体部分
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span></code></pre></div><p>在<a href="https://jen-jon.github.io/posts/closures/">闭包表达式语法</a>上章节的字符串排序闭包可以作为尾随闭包的形式改写在<code>sorted(by:)</code>方法圆括号的外面：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span>reversedNames = names.sorted() { $0 <span style="color:#f92672">&gt;</span> $1 }
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;尾随闭包：</span><span style="color:#e6db74">\(</span>reversedNames<span style="color:#e6db74">)</span><span style="color:#e6db74">.&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">---</span>
</span></span><span style="display:flex;"><span>output: <span style="color:#960050;background-color:#1e0010">尾随闭包：</span>[<span style="color:#e6db74">&#34;Jensen&#34;</span>, <span style="color:#e6db74">&#34;Ewa&#34;</span>, <span style="color:#e6db74">&#34;Chris&#34;</span>, <span style="color:#e6db74">&#34;Barry&#34;</span>, <span style="color:#e6db74">&#34;Alex&#34;</span>].
</span></span></code></pre></div><p>如果闭包表达式是函数或方法的唯一参数，则当使用尾随闭包时，甚至可以吧<code>()</code>省略掉：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span>reversedNames = names.sorted { $0 <span style="color:#f92672">&gt;</span> $1 }
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;尾随闭包省略（）： </span><span style="color:#e6db74">\(</span>reversedNames<span style="color:#e6db74">)</span><span style="color:#e6db74">.&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">---</span>
</span></span><span style="display:flex;"><span>output: <span style="color:#960050;background-color:#1e0010">尾随闭包省略（）：</span> [<span style="color:#e6db74">&#34;Jensen&#34;</span>, <span style="color:#e6db74">&#34;Ewa&#34;</span>, <span style="color:#e6db74">&#34;Chris&#34;</span>, <span style="color:#e6db74">&#34;Barry&#34;</span>, <span style="color:#e6db74">&#34;Alex&#34;</span>].
</span></span></code></pre></div><p>当闭包非常长以至于不能在一行中进行书写的时候，尾随闭包变得非常有用。举例来说，<code>Swift</code>的<code>Array</code>类型有一个<code>map(_:)</code>方法，这个方法获取一个闭包表达式作为其唯一参数，该闭包表达式会为数组中的每个元素调用一次，并返回该元素所映射的值。具体的映射方式和返回值的类型由闭包来指定。</p>
<p>当提供给数组的闭包应用于每个数组元素后，<code>map(_:)</code>方法返回一个新的数组，数组中包含了与原数组中元素一一对应的映射后的值。</p>
<p>下例介绍了如何在<code>map(_:)</code>方法中使用尾随闭包将<code>Int</code>类型数组[16, 58, 510]转换为包含对应<code>String</code>类型的值的数组[&ldquo;OneSix&rdquo;, &ldquo;FiveEight&rdquo;, &ldquo;FiveOneZero&rdquo;]：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> digitNames = [
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>: <span style="color:#e6db74">&#34;Zero&#34;</span>, <span style="color:#ae81ff">1</span>: <span style="color:#e6db74">&#34;One&#34;</span>, <span style="color:#ae81ff">2</span>: <span style="color:#e6db74">&#34;Two&#34;</span>, <span style="color:#ae81ff">3</span>: <span style="color:#e6db74">&#34;Three&#34;</span>, <span style="color:#ae81ff">4</span>: <span style="color:#e6db74">&#34;Four&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">5</span>: <span style="color:#e6db74">&#34;Five&#34;</span>, <span style="color:#ae81ff">6</span>: <span style="color:#e6db74">&#34;Six&#34;</span>, <span style="color:#ae81ff">7</span>: <span style="color:#e6db74">&#34;Seven&#34;</span>, <span style="color:#ae81ff">8</span>: <span style="color:#e6db74">&#34;Eight&#34;</span>, <span style="color:#ae81ff">9</span>: <span style="color:#e6db74">&#34;Nine&#34;</span>
</span></span><span style="display:flex;"><span>]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> numbers = [<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">58</span>, <span style="color:#ae81ff">510</span>]
</span></span></code></pre></div><p>如上代码创建了一个整型数位和它们的英文版本名字相映射的字典，同时还定义了一个准备转换为字符串数组的整形数组。</p>
<p>现在可以通过传递一个尾随闭包给<code>numbers</code>数组的<code>map(_:)</code>方法来创建对应的字符串版本数组：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> strings = numbers.map {
</span></span><span style="display:flex;"><span>    (number) -&gt; String <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> number = number
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> output = <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">repeat</span> {
</span></span><span style="display:flex;"><span>        output = digitNames[number <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>]<span style="color:#f92672">!</span> <span style="color:#f92672">+</span> output
</span></span><span style="display:flex;"><span>        number <span style="color:#f92672">/=</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">while</span> number <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> output
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// `string`常量被推断为字符串类型数组，即[String]</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 其值为[&#34;OneSix&#34;, &#34;FiveEight&#34;, &#34;FiveOneZero&#34;]</span>
</span></span></code></pre></div><p><code>map(_:)</code>为数组中每一个元素调用了一次闭包表达式，不需要指定闭包的输入参数<code>number</code>的类型，因为可以通过要映射的数组类型进行推断。</p>
<p>在该例中，局部变量<code>number</code>的值由闭包中的<code>number</code>参数获得，因此可以在闭包函数体内对其进行修改，<strong>（闭包或者函数的参数总是常量）</strong>，闭包表达式指定了返回类型为<code>String</code>，以表明存储映射值的新数组类型为<code>String</code>。</p>
<p>闭包表达式在每次被调用的时候创建了一个叫做<code>output</code>的字符串并返回。其使用求余运算符（number % 10）计算最后一位数字并利用<code>digitNames</code>字典获取所映射的字符串。这个闭包能够用于创建任意正整数的字符串表示。</p>
<blockquote>
<p><strong>注意</strong></p>
<p>字典digitNames下标后跟着一个叹号（！），因为字典下标返回一个可选值（Optional Value），表明改键不存在时会查找失败，在上例中，由于可以确定number % 10总是digitNames字典的有效下标，因此叹号可以用于强制解包（Force-Unwrap）存储在下标的可选类型的返回值中的String类型值。</p>
</blockquote>
<p>从<code>digitNames</code>字典中获取的字符串被添加到<code>output</code>的前部，逆序建立了一个字符串版本的数字。（在表达式number % 10中，如果number为16，则返回6，58则返回8，510则返回0。）</p>
<p><code>number</code>变量之后除以10。因为其是整数，在计算过程中未除尽部分被忽略，因此16变成了1，58变成了5，510变成了51。</p>
<p>整个或称重复进行，直到<code>number /= 10</code>为0，这时闭包会将字符串<code>output</code>返回，而<code>map(_:)</code>方法则会将字符串添加到映射的数组中。</p>
<p>在上面的例子中，通过尾随闭包语法，优雅地在函数后封装了闭包的具体功能，而不再需要将整个闭包包裹在<code>map(_:)</code>方法的括号内。</p>
<hr>
<h2 id="值捕获">值捕获</h2>
<p>闭包可以在其被定义的上下文中捕获常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包依然可以在闭包函数体内引用和修改这些值。</p>
<p><code>Swift</code>中，可以捕获值的闭包的最简单形式是嵌套函数，也就是定义在其他函数的函数体内的函数。嵌套函数可以捕获其外部函数的所有的参数以及定义的常量和变量。</p>
<p>举个例子，这有个叫做<code>makeIncrementer</code>的函数，其包含了一个叫做<code>incrementer</code>的嵌套函数。嵌套函数<code>incrementer()</code>从上下文中捕获了两个值，<code>runningTotal</code>和<code>amount</code>。捕获这些值之后，<code>makeIncrementer</code>将<code>incrementer</code>作为闭包返回。每次调用<code>intermenter</code>时，其会以<code>amount</code>为增量增加<code>runningTotal</code>的值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">makeIncrementer</span>(forIncrement amount: Int) -&gt; () -&gt; Int {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> runningTotal = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">incrementer</span>() -&gt; Int {
</span></span><span style="display:flex;"><span>        runningTotal <span style="color:#f92672">+=</span> amount
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> runningTotal
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> incrementer
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> testIncrementer = makeIncrementer(forIncrement: <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>testIncrementer()  <span style="color:#75715e">// 此时testIncrementer()的值为10</span>
</span></span><span style="display:flex;"><span>print(testIncrementer())  <span style="color:#75715e">// 打印输出20， 10 + 10</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">---</span>
</span></span><span style="display:flex;"><span>output: <span style="color:#ae81ff">20</span>
</span></span></code></pre></div><p><code>makeIncrementer</code>返回类型为<code>() -&gt; Int</code>。这意味着其返回的是一个函数，而非一个简单类型的值。该函数在每次调用时不接受参数，只返回一个<code>Int</code>类型的值。关于函数返回其他函数的内容，请查看<a href="https://jen-jon.github.io/posts/function/">函数类型作为返回类型</a>。</p>
<p><code>makeIncrementer(forIncrement:)</code>函数定义了一个初始值为0的整型变量<code>runningTotal</code>，用来存储当前总计数值。该值为<code>incrementer</code>的返回值。</p>
<p><code>makeIncrementer(forIncrementer:)</code>有一个<code>Int</code>类型的参数，其外部参数名为<code>forIncrement</code>，内部参数名为<code>amount</code>，该参数表示每次<code>incrementer</code>被调用时<code>runningTotal</code>将要增加的量。<code>makeIncrementer</code>函数还定义了一个嵌套函数<code>incrementer</code>，用来执行实际的增加操作。该函数简单地使<code>runningTotal</code>增加<code>amount</code>，并将其返回。</p>
<p>如果我们单独考虑嵌套函数<code>incrementer()</code>，会发现它有些不同寻常：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">func incrementer() -&gt; Int {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    runningTotal += amount
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    return runningTotal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span></code></pre></div><p><code>incrementer()</code>函数并没有任何参数，但是在函数体内访问了<code>runningTotal</code>和<code>amount</code>变量。这是因为它从外围函数捕获了<code>runningTotal</code>和<code>amount</code>变量的引用。捕获引用保证了<code>runningTotal</code>和<code>amount</code>变量在调用完<code>makeIncrementer</code>后不会消失，并且保证了在下一次执行<code>incrementer</code>函数时，<code>runningTotal</code>依旧存在。</p>
<blockquote>
<p><strong>注意</strong></p>
<p>为了优化，如果一个值不会被闭包改变，或者在闭包创建后不会改变，Swift可能会改为捕获并保存一份对值的拷贝。</p>
<p>Swift也会负责被捕获变量的所有内存管理操作，包括释放不再需要的变量。</p>
</blockquote>
<p>下面是一个使用<code>makeIncrementer</code>的例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> incrementByTen = makeIncrementer(forIncrement: <span style="color:#ae81ff">10</span>)
</span></span></code></pre></div><p>该例子定义了一个叫做<code>incrementByTen</code>的常量，该常量指向一个每次调用会将其<code>runningTotal</code>变量增加10的<code>incrementer</code>函数。调用这个函数多次可以得到以下结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span>incrementByTen()  <span style="color:#75715e">// 返回的值为10</span>
</span></span><span style="display:flex;"><span>incrementByTen()  <span style="color:#75715e">// 返回的值为20</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> result = incrementByTen()  <span style="color:#75715e">// 返回的值为30</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;三次调用IncrementByTen()返回的结果为：</span><span style="color:#e6db74">\(</span>result<span style="color:#e6db74">)</span><span style="color:#e6db74">。&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">---</span>
</span></span><span style="display:flex;"><span>output: <span style="color:#960050;background-color:#1e0010">三次调用</span>IncrementByTen()<span style="color:#960050;background-color:#1e0010">返回的结果为：</span><span style="color:#ae81ff">30</span><span style="color:#960050;background-color:#1e0010">。</span>
</span></span></code></pre></div><p>如果创建了另外一个<code>incrementer</code>，它会有属于自己的引用，指向一个全新、独立的<code>runningTotal</code>变量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> incrementBySeven = makeIncrementer(forIncrement: <span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>result = incrementBySeven()  <span style="color:#75715e">// 返回值为7</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Result：</span><span style="color:#e6db74">\(</span>result<span style="color:#e6db74">)</span><span style="color:#e6db74">.&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">---</span>
</span></span><span style="display:flex;"><span>output: Result<span style="color:#960050;background-color:#1e0010">：</span><span style="color:#ae81ff">7.</span>
</span></span></code></pre></div><p>再次调用原来的<code>incrementByTen</code>会继续增加它自己的<code>runningTotal</code>变量，该变量和<code>incrementBySeven</code>中捕获的变量没有任何联系：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span>incrementByTen()  <span style="color:#75715e">// 返回值为40</span>
</span></span></code></pre></div><blockquote>
<p><strong>注意</strong></p>
<p>如果将闭包赋值给一个类实例的属性，并且该闭包通过访问该实例或其成员而捕获了该实例，那将在闭包和该实例之间构建一个<strong>循环强引用</strong>。Swift使用捕获列表来打破这种循环强引用。</p>
</blockquote>
<hr>
<h2 id="闭包是引用类型">闭包是引用类型</h2>
<p>上面的例子中，<code>incrementBySeven</code>和<code>incrementByTen</code>都是常量，但是这些常量指向的闭包仍然可以增加其捕获的变量的值。这是因为函数和闭包都是引用类型。</p>
<p>无论将函数或闭包赋值给一个常量还是变量，实际上都是将变量或者常量的值设置为对应函数或闭包的引用。上面的例子中，指向闭包的引用<code>incrementByTen</code>是一个常量，而非闭包内容本身。</p>
<p>这也就意味着如果将闭包赋值给了两个不同的常量或变量，两个值都会指向同一个闭包：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> alsoIncrementByTen = incrementByTen
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;alsoIncrementByTen的值是：</span><span style="color:#e6db74">\(</span>alsoIncrementByTen<span style="color:#e6db74">())</span><span style="color:#e6db74">.&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">---</span>
</span></span><span style="display:flex;"><span>output: alsoIncrementByTen的值是<span style="color:#960050;background-color:#1e0010">：</span><span style="color:#ae81ff">50.</span>
</span></span></code></pre></div><hr>
<h2 id="逃逸闭包">逃逸闭包</h2>
<p>当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回后才被执行，我们称该闭包从函数中逃逸。当定义接受闭包作为参数的函数时，可以在参数类型前标注<code>@escaping</code>来指明这个闭包是允许“逃逸”出这个函数的。</p>
<p>一种能使闭包“逃逸”出函数的方法是，将这个闭包保存在一个函数外部定义的变量中。举个例子，很多启动异步操作的函数接受一个闭包参数作为<code>completion handler</code>。这类函数会在异步操作开始之后立刻返回。但是闭包直到异步操作结束时才会被调用。在这种情况下，闭包需要“逃逸”出函数，因为闭包需要在函数返回之后被调用。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> completionHandlers: [() -&gt; Void] = []
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">someFunctionWithEscapingClosure</span>(completionHandler: @escaping () -&gt; Void) {
</span></span><span style="display:flex;"><span>    completionHandlers.append(completionHandler)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>someFunctionWithEscapingClosure(_:)</code>函数接受一个闭包作为参数，该闭包被添加到一个函数外定义的数组中。如果不将这个参数标记为<code>@escaping</code>，就会得到一个编译错误(Converting non-escaping parameter &lsquo;completionHandler&rsquo; to generic parameter &lsquo;Element&rsquo; may allow it to escape)。</p>
<p>将一个闭包标记为<code>@escaping</code>意味着必须在闭包中显式地引用<code>self</code>。比如说，在下面的代码中，传递到<code>someFunctionWithEscapingClosure(_:)</code>中的闭包是一个逃逸闭包，这意味着它需要显式地引用<code>self</code>。相对的，传递到<code>someFunctionWithNoneEscapingClosure(_:)</code>中的闭包是一个非逃逸闭包，这意味着它可以隐式引用<code>self</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">someFunctionWithNoneEscapingClosure</span>(closure: () -&gt; Void) {
</span></span><span style="display:flex;"><span>    closure()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">someClass</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> x = <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doSometing</span>() {
</span></span><span style="display:flex;"><span>        someFunctionWithEscapingClosure {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">self</span>.x = <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        someFunctionWithNoneEscapingClosure {
</span></span><span style="display:flex;"><span>            x = <span style="color:#ae81ff">200</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> instance = someClass()
</span></span><span style="display:flex;"><span>instance.doSometing()
</span></span><span style="display:flex;"><span>print(instance.x)  <span style="color:#75715e">// 打印输出“200”</span>
</span></span><span style="display:flex;"><span>completionHandlers.first?()  <span style="color:#75715e">// someFunctionWithEscapingClosure的闭包已经逃逸到外部，函数在返回后，可以调用逃逸的闭包  // xxx.first?() 可选链式调用</span>
</span></span><span style="display:flex;"><span>print(instance.x)  <span style="color:#75715e">// 打印输出“100”</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">---</span>
</span></span><span style="display:flex;"><span>output: <span style="color:#ae81ff">200</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">100</span>
</span></span></code></pre></div><hr>
<h2 id="自动闭包">自动闭包</h2>
<p>自动闭包是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。<strong>这种闭包不接受任何参数</strong>，当它被调用的时候，会返回被包装在其中的表达式的值。这种便利语法能够省略闭包的花括号，用一个普通的表达式来替代显式的闭包。</p>
<p>我们经常会调用采用自动闭包的函数，但是很少去实现这样的函数。举个例子来说，<code>assert(condition:message:file:line:)</code>函数接受自动闭包作为其<code>condition</code>参数和<code>message</code>参数；它的<code>condition</code>参数仅会在<code>debug</code>模式下被求值，它的<code>message</code>参数仅当<code>condition</code>参数为<code>false</code>时被计算求值。</p>
<p>自动闭包让开发者能够延迟求值，因为直到调用这个闭包时，代码段才会被执行。延迟求值对于那些有副作用（Side Effect）和高计算成本的代码来说是很有益处的，因为它使得开发者能够控制代码执行的时机。下面的代码展示了闭包如何延时求值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> customersInLine = [<span style="color:#e6db74">&#34;Chris&#34;</span>, <span style="color:#e6db74">&#34;Jensen&#34;</span>, <span style="color:#e6db74">&#34;Ewa&#34;</span>, <span style="color:#e6db74">&#34;Alex&#34;</span>, <span style="color:#e6db74">&#34;Barry&#34;</span>]
</span></span><span style="display:flex;"><span>print(customersInLine.count)  <span style="color:#75715e">// 打印输出“5”</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> customerProvider = { customersInLine.remove(at: <span style="color:#ae81ff">0</span>) }
</span></span><span style="display:flex;"><span>print(customersInLine.count)  <span style="color:#75715e">// 打印输出“5”</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;NOW SERVING </span><span style="color:#e6db74">\(</span>customerProvider<span style="color:#e6db74">())</span><span style="color:#e6db74">!&#34;</span>)  <span style="color:#75715e">// 打印输出“NOW SERVING Chris!”</span>
</span></span><span style="display:flex;"><span>print(customersInLine.count)  <span style="color:#75715e">// 打印输出“4”</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">---</span>
</span></span><span style="display:flex;"><span>output: <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>NOW SERVING Chris!
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>
</span></span></code></pre></div><p>尽管在闭包的代码中，<code>customersInLine</code>的第一个元素被移除了，不过在闭包被调用之前，这个元素是不会被移除的。如果这个闭包永远不被调用，那么在闭包里面的表达式将永远不会被执行，那意味着列表中的元素永远不会被移除。请注意，<code>customerProvider</code>的类型不是<code>String</code>，而是<code>() -&gt; String</code>，一个没有参数且返回值为<code>String</code>的函数。</p>
<p>将闭包作为参数传递给函数时，能获得同样的延时求值行为。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span><span style="color:#75715e">// customersInLine is [&#34;Jensen&#34;, &#34;Ewa&#34;, &#34;Alex&#34;, &#34;Barry&#34;]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">server</span>(customer customerProvider: () -&gt; String) {
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Now serving </span><span style="color:#e6db74">\(</span>customerProvider<span style="color:#e6db74">())</span><span style="color:#e6db74">!&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>server(customer: { customersInLine.remove(at: <span style="color:#ae81ff">0</span>) })  <span style="color:#75715e">// 打印出“Now serving Jensen!”</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">---</span>
</span></span><span style="display:flex;"><span>output: Now serving Jensen!
</span></span></code></pre></div><p>上面的<code>server(customer:)</code>函数接受一个返回顾客的名字的显式的闭包。下面这个版本的<code>server(customer:)</code>完成了相同的操作，不过它没有接受一个显示的闭包，而是通过将参数标记为<code>@autoclosure</code>来接收一个自动闭包。现在可以将该函数当做接受<code>String</code>类型参数（而非闭包）的函数来调用。<code>customerProvider</code>参数将自动转化为一个闭包，因为该参数被标记了<code>@autoclosure</code>特性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span><span style="color:#75715e">// customersInLine is [&#34;Ewa&#34;, &#34;Alex&#34;, &#34;Barry&#34;]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">server</span>(customer customerProvider: <span style="color:#66d9ef">@autoclosure</span> () -&gt; String) {
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Now Serving </span><span style="color:#e6db74">\(</span>customerProvider<span style="color:#e6db74">())</span><span style="color:#e6db74">!&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>server(customer: customersInLine.remove(at: <span style="color:#ae81ff">0</span>))  <span style="color:#75715e">// 打印输出“Now Serving Ewa!”</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">---</span>
</span></span><span style="display:flex;"><span>output: Now Serving Ewa!
</span></span></code></pre></div><blockquote>
<p><strong>注意</strong></p>
<p>过度使用autoclosures会让代码变得难以理解。上下文和函数名应该能够清晰地表明求值是被延迟执行的。</p>
</blockquote>
<p>如果想让一个自动闭包可以“逃逸”，则应该同时使用<code>@autoclosure</code>和<code>@escaping</code>属性。<code>@escaping</code>属性的讲解见上面的逃逸闭包。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span><span style="color:#75715e">// customersInLine is [&#34;Alex&#34;, &#34;Barry&#34;]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> customerProviders: [() -&gt; String] = []
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">collectCustomerProviders</span>(<span style="color:#66d9ef">_</span> customerProvider: <span style="color:#66d9ef">@autoclosure</span> @escaping () -&gt; String) {
</span></span><span style="display:flex;"><span>    customerProviders.append(customerProvider)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>collectCustomerProviders(customersInLine.remove(at: <span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>collectCustomerProviders(customersInLine.remove(at: <span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Collected </span><span style="color:#e6db74">\(</span>customerProviders.count<span style="color:#e6db74">)</span><span style="color:#e6db74"> closures.&#34;</span>)  <span style="color:#75715e">// 打印输出“Collected 2 closures.” 现在有两个闭包传入了外部的customerProviders数组</span>
</span></span><span style="display:flex;"><span>print(customersInLine)  <span style="color:#75715e">// customersInLine is still [&#34;Alex&#34;, &#34;Barry&#34;]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> customerProvider <span style="color:#66d9ef">in</span> customerProviders {
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Now serving </span><span style="color:#e6db74">\(</span>customerProvider<span style="color:#e6db74">())</span><span style="color:#e6db74">!&#34;</span>)
</span></span><span style="display:flex;"><span>}  <span style="color:#75715e">// 打印输出“Now serving Alex!”  // 打印输出“Now serving Barry!”</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//print(customersInLine)  // 此时customersInLine数组为空</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">---</span>
</span></span><span style="display:flex;"><span>output: Collected <span style="color:#ae81ff">2</span> closures.
</span></span><span style="display:flex;"><span>[<span style="color:#e6db74">&#34;Alex&#34;</span>, <span style="color:#e6db74">&#34;Barry&#34;</span>]
</span></span><span style="display:flex;"><span>Now serving Alex!
</span></span><span style="display:flex;"><span>Now serving Barry!
</span></span></code></pre></div><p>在上面的代码中，<code>collectCustomerProviders(_:)</code>函数并没有调用传入的<code>customerProvider</code>闭包，而是将闭包追加到了<code>customerProviders</code>数组中，这个数组定义在函数作用域范围外，这意味着数组内的闭包能够在函数返回之后被调用。因此，<code>customerProvider</code>参数必须允许“逃逸”出函数作用域。</p>

    <div class="CornerButtons">
        <div class="CornerAnimayedFlex">
            <div class="CornerButton" title="Back to the top">
                <a href="#top" class="cba fas fa-hand-middle-finger" ></a>
            </div>
        </div>
    </div>

<hr>

<h1 style="color: #dc3545;">Comments</h1>
<script defer src="https://utteranc.es/client.js" 
repo="Jen-Jon/Jen-Jon.github.io" 
issue-term="title" 
theme="github-light" 
crossorigin="anonymous" async></script>


</div>

<h5 style="text-align: center; font-size: large;">This blog is licensed under <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">CC BY-NC-ND 4.0</a>, please indicate the source for non-commercial reposted.</h5>


        </div><strong id="footer" class="mb-5">
    <hr>
    
    <div class="container text-center">
        
            <a href="https://github.com/Jen-Jon/" class="fab fa-github fa-1x" title="Github" style="text-decoration: none;"></a>
        
            <a href="https://hub.docker.com/u/ijerry22" class="fab fa-docker fa-1x" title="DockerHub" style="text-decoration: none;"></a>
        
            <a href="https://www.researchgate.net/profile/Jingyao-Zhang-4" class="fab fa-researchgate fa-1x" title="researchgate" style="text-decoration: none;"></a>
        
            <a href="mailto:jensen.acm@gmail.com" class="fas fa-envelope fa-1x" title="E-mail" style="text-decoration: none;"></a>
        
    </div>
    
        <div class="container text-center">
            <h5 class="text-center" style="font-size: small;">Copyright © 2020-2022 <a href="https://github.com/Jen-Jon/" style="color: #dc3545;" title="Jensen-Jon">Jensen-Jon</a>. All rights reserved.</h5>
        </div>
    
</div>
</body>
</html>
